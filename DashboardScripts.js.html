<script>
    let currentActiveSidebarTabId = null; // Initialize to null or the default tab ID

    function openSettingsDialog() {
      document.getElementById('settingsModal').style.display = 'flex';
      document.getElementById('settingsStatus').textContent = '';
      google.script.run.withSuccessHandler(function(data) {
        document.getElementById('asanaPat').value = data.asanaToken || '';
        document.getElementById('sheetId').value = data.sheetId || '';
        document.getElementById('projectColor').value = data.projectColor || '#26717D';
      }).getSettings();
    }
    function closeSettingsDialog() {
      document.getElementById('settingsModal').style.display = 'none';
    }
    function saveSettings(e) {
      e.preventDefault();
      var token = document.getElementById('asanaPat').value.trim();
      var sheetId = document.getElementById('sheetId').value.trim();
      var projectColor = document.getElementById('projectColor').value;
      document.getElementById('settingsStatus').textContent = 'Saving...';
      google.script.run.withSuccessHandler(function() {
        document.getElementById('settingsStatus').textContent = 'Settings saved!';
        // Apply the color to existing project cards
        applyProjectCardColor(projectColor);
        setTimeout(closeSettingsDialog, 1000);
      }).withFailureHandler(function(err) {
        document.getElementById('settingsStatus').textContent = 'Error: ' + err.message;
      }).saveSettings(token, sheetId, projectColor);
    }
    
    // Apply color to project card headers
    function applyProjectCardColor(color) {
      const projectCardHeaders = document.querySelectorAll('.project-card-header');
      projectCardHeaders.forEach(header => {
        header.style.setProperty('background-color', color, 'important');
        header.style.setProperty('color', '#FFFFFF', 'important'); // Set text color to white for better contrast
      });
    }
    
    // Apply color when dashboard loads
    function applyColorToProjectCards() {
      google.script.run.withSuccessHandler(function(data) {
        if (data.projectColor) {
          // Only apply default color to cards that don't have a custom color
          const projectCardHeaders = document.querySelectorAll('.project-card-header');
          projectCardHeaders.forEach(header => {
            // Check if this card's parent has a data attribute for project color
            const cardElement = header.closest('.project-card');
            if (!cardElement || !cardElement.getAttribute('data-project-color')) {
              header.style.setProperty('background-color', data.projectColor, 'important');
              header.style.setProperty('color', '#FFFFFF', 'important');
            }
          });
        }
      }).getSettings();
    }
    
    // Dashboard Loading functions
    function showDashboardLoading(message) {
      document.getElementById('dashboardLoadingMessage').textContent = message || 'Loading...';
      document.getElementById('dashboardLoadingOverlay').style.display = 'flex';
    }
    
    function hideDashboardLoading() {
      document.getElementById('dashboardLoadingOverlay').style.display = 'none';
    }
    
    // Global variables for Gantt
    let ganttInstance = null;
    let ganttViewMode = 'Month';  // Changed default from 'Week' to 'Month'
    let ganttDataMode = 'sections';  // Changed default from 'tasks' to 'sections'
    let ganttData = null; // Store the original task data
    let ganttObserver = null; // MutationObserver for detecting chart rendering
    let currentProjectFilter = 'all'; // Track the currently selected project filter
    let activeGanttScrollHandler = null; // For sticky header JS
    let ganttStructureObserver = null; // New observer for SVG structure
    
    function setGanttViewMode(mode) {
      ganttViewMode = mode;
      updateGanttView();
      
      // Update active button
      document.querySelectorAll('.gantt-view-btn').forEach(btn => {
        if (btn.textContent.trim() === mode) {
          btn.classList.add('active');
        } else if (btn.id !== 'ganttTaskViewBtn' && btn.id !== 'ganttSectionViewBtn') {
          btn.classList.remove('active');
        }
      });
    }
    
    function setGanttDataMode(mode) {
      ganttDataMode = mode;
      
      // Update active button
      document.getElementById('ganttTaskViewBtn').classList.toggle('active', mode === 'tasks');
      document.getElementById('ganttSectionViewBtn').classList.toggle('active', mode === 'sections');
      
      // Redraw the Gantt chart with the new mode if we have data
      if (ganttData) {
        console.log('DEBUG - Switching to', mode, 'view mode');
        drawFrappeGantt(ganttData);
      }
    }
    
    // bringHeaderElementsToFrontV4.2: Corrects internal order within the overlay group.
    function bringHeaderElementsToFrontV4() { 
        // console.log('[DEBUG] Sticky Gantt (Overlay V4.2): CALLED.');
        const svg = document.querySelector('#frappeGantt .gantt');
        if (!svg) {
            // console.warn('[DEBUG] Sticky Gantt (Overlay V4.2): SVG element not found.');
            return;
        }

        let headerOverlayGroup = svg.querySelector('#ganttHeaderOverlay');
        if (!headerOverlayGroup) {
            // console.log('[DEBUG] Sticky Gantt (Overlay V4.2): Creating #ganttHeaderOverlay group.');
            headerOverlayGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            headerOverlayGroup.setAttribute('id', 'ganttHeaderOverlay');
            svg.appendChild(headerOverlayGroup); 
        }

        const mainGridGroupForHeaderParts = svg.querySelector('g.grid:not(#ganttHeaderOverlay g.grid)');
        const dateGroup = svg.querySelector('g.date:not(#ganttHeaderOverlay g.date)');

        if (mainGridGroupForHeaderParts) {
            const gridHeaderRect = mainGridGroupForHeaderParts.querySelector('rect.grid-header');
            if (gridHeaderRect && gridHeaderRect.parentNode !== headerOverlayGroup) {
                 // console.log('[DEBUG] Sticky Gantt (Overlay V4.2): Moving rect.grid-header into #ganttHeaderOverlay (first).');
                 if (headerOverlayGroup.firstChild) {
                    headerOverlayGroup.insertBefore(gridHeaderRect, headerOverlayGroup.firstChild);
                 } else {
                    headerOverlayGroup.appendChild(gridHeaderRect);
                 }
            }
            const tickPaths = mainGridGroupForHeaderParts.querySelectorAll('path.tick, path.thick');
            tickPaths.forEach(tick => {
                if (tick.parentNode !== headerOverlayGroup) {
                    headerOverlayGroup.appendChild(tick);
                }
            });
        } else {
             // console.warn('[DEBUG] Sticky Gantt (Overlay V4.2): Main g.grid (for header parts) not found. Some header elements might be missing.');
        }

        if (dateGroup && dateGroup.parentNode !== headerOverlayGroup) {
            // console.log('[DEBUG] Sticky Gantt (Overlay V4.2): Moving g.date into #ganttHeaderOverlay (last within overlay).');
            headerOverlayGroup.appendChild(dateGroup); 
        }
        
        const mainGridForOrder = svg.querySelector('g.grid:not(#ganttHeaderOverlay g.grid)');
        const barGroup = svg.querySelector('g.bar');

        if (mainGridForOrder) {
            svg.appendChild(mainGridForOrder); 
        }
        if (barGroup) {
            svg.appendChild(barGroup);
        }
        svg.appendChild(headerOverlayGroup);
    }

    // ensureHeaderOverlayIsLastPersistentV3: Simplified observer, only manages #ganttHeaderOverlay position.
    function ensureHeaderOverlayIsLastPersistentV3() {
        const svg = document.querySelector('#frappeGantt .gantt');
        if (!svg) {
            // console.warn('[Sticky Header Sync V3] Main SVG not found to observe.');
            return;
        }
        if (ganttStructureObserver) {
            ganttStructureObserver.disconnect(); 
        }
        ganttStructureObserver = new MutationObserver((mutationsList, observer) => {
            const headerOverlayGroup = svg.querySelector('#ganttHeaderOverlay');
            if (headerOverlayGroup && svg.lastChild !== headerOverlayGroup) {
                // console.log('[Sticky Header Sync V3] #ganttHeaderOverlay is not last child. Re-appending.');
                svg.appendChild(headerOverlayGroup);
            }
        });
        ganttStructureObserver.observe(svg, { childList: true });
        // console.log('[Sticky Header Sync V3] Persistent observer set up for #ganttHeaderOverlay position.');
        
        setTimeout(() => {
            const stillSvg = document.querySelector('#frappeGantt .gantt');
            if (stillSvg) {
                 const overlay = stillSvg.querySelector('#ganttHeaderOverlay');
                 if (overlay && stillSvg.lastChild !== overlay) {
                    // console.log('[Sticky Header Sync V3] Initial check: #ganttHeaderOverlay not last. Re-appending.');
                    stillSvg.appendChild(overlay);
                 }
            }
        }, 50); 
    }

    // REVISED makeGanttHeaderSticky (V4 - selectors find elements in overlay)
    function makeGanttHeaderSticky() {
      let scrollContainer = document.getElementById('frappeGantt'); 
      if (!scrollContainer || (getComputedStyle(scrollContainer).overflowY !== 'auto' && getComputedStyle(scrollContainer).overflowY !== 'scroll')) {
        scrollContainer = document.querySelector('#frappeGantt .gantt-container');
      }
      if (!scrollContainer) {
        console.error('Sticky Gantt: No suitable scroll container found.'); // KEPT: This is an actual error condition.
        return;
      }
      if (activeGanttScrollHandler) {
        if (activeGanttScrollHandler.container && typeof activeGanttScrollHandler.container.removeEventListener === 'function') {
            activeGanttScrollHandler.container.removeEventListener('scroll', activeGanttScrollHandler.handler);
        }
        activeGanttScrollHandler = null;
      }
      const handleScroll = () => {
        const currentGridHeader = document.querySelector('#ganttHeaderOverlay rect.grid-header, #frappeGantt .gantt rect.grid-header'); 
        const currentDateGroup = document.querySelector('#ganttHeaderOverlay g.date, #frappeGantt .gantt g.date');
        const currentTicks = document.querySelectorAll('#ganttHeaderOverlay path.tick, #ganttHeaderOverlay path.thick');

        if (!currentDateGroup) { 
          return;
        }
        const scrollTop = scrollContainer.scrollTop;

        if (currentGridHeader) {
            currentGridHeader.setAttribute('y', scrollTop);
        }
        currentDateGroup.style.transform = `translateY(${scrollTop}px)`;
        currentTicks.forEach(tick => {
            tick.style.transform = `translateY(${scrollTop}px)`;
        });
      };
      scrollContainer.addEventListener('scroll', handleScroll);
      activeGanttScrollHandler = { handler: handleScroll, container: scrollContainer }; 
      requestAnimationFrame(() => { handleScroll(); }); 
      // console.log('Sticky Gantt (V4): Header stickiness initialized/re-initialized.');
    }

    // MODIFIED setupGanttObserver (V2.5 - uses V4 functions)
    function setupGanttObserver() {
      if (ganttObserver) {
        ganttObserver.disconnect();
      }
      ganttObserver = new MutationObserver((mutations) => {
        const ganttSVGRoot = document.querySelector('#frappeGantt .gantt'); 
        if (ganttSVGRoot && ganttInstance) { 
          // console.log('Gantt chart rendered - initial setup (V2.5).');
          ganttObserver.disconnect(); 

          if (ganttStructureObserver) ganttStructureObserver.disconnect();

          colorizeGanttBars();
          makeGanttHeaderSticky(); 
          
          setTimeout(() => { 
            // console.log('[Setup V2.5] Post-colorize/sticky: Initializing Overlay V4.');
            bringHeaderElementsToFrontV4(); 
            ensureHeaderOverlayIsLastPersistentV3(); 
          }, 300); 
        }
      });
      const frappeGantt = document.getElementById('frappeGantt');
      if (frappeGantt) {
        ganttObserver.observe(frappeGantt, { childList: true, subtree: true });
      }
    }
    
    // MODIFIED updateGanttView (V2.5 - uses V4 functions)
    function updateGanttView() {
      if (!ganttInstance) return;
      ganttInstance.change_view_mode(ganttViewMode);
      setTimeout(() => {
        if (ganttStructureObserver) ganttStructureObserver.disconnect();

        colorizeGanttBars();
        makeGanttHeaderSticky(); 

        setTimeout(() => { 
            // console.log('[UpdateView V2.5] Post-colorize/sticky: Initializing Overlay V4.');
            bringHeaderElementsToFrontV4(); 
            ensureHeaderOverlayIsLastPersistentV3(); 
        }, 300); 
      }, 450);
    }
    
    function loadFrappeGantt() {
      // Only use the dashboard loading overlay, not secondary loading indicator
      showDashboardLoading('Loading Gantt chart...');
      document.getElementById('frappeGantt').innerHTML = ''; // Clear the container
      
      // Setup observer to detect when chart is rendered
      setupGanttObserver();
      
      google.script.run
        .withSuccessHandler(function(data) {
          drawFrappeGantt(data);
          // Force a refresh after a short delay to ensure proper rendering
          setTimeout(function() {
            if (ganttInstance) {
              ganttInstance.refresh(ganttInstance.tasks);
              // Apply colors again after refresh
              colorizeGanttBars();
            }
          }, 300);
        })
        .withFailureHandler(function(error) {
          document.getElementById('frappeGantt').innerHTML = '<div class="error-box">Error loading Gantt chart: ' + error + '</div>';
          hideDashboardLoading();
        })
        .getAsanaTasksForGantt();
    }
    
    function drawFrappeGantt(data) {
      if (typeof Gantt === 'undefined') {
        document.getElementById('frappeGantt').innerHTML = '<div class="error-box">Frappe Gantt library not loaded.</div>';
        console.error('Frappe Gantt library not loaded.');
        hideDashboardLoading();
        return;
      }
      
      if (!data.success) {
        document.getElementById('frappeGantt').innerHTML = '<div class="error-box">' + (data.error || 'Error loading Gantt chart') + '</div>';
        hideDashboardLoading();
        return;
      }
      
      if (!data.tasks || data.tasks.length === 0) {
        document.getElementById('frappeGantt').innerHTML = '<div class="info-box">No tasks with start and due dates found in the selected projects.</div>';
        hideDashboardLoading();
        return;
      }
      
      // Store the original data for view switching
      ganttData = data;
      
      // Setup observer to detect when chart is rendered
      setupGanttObserver();
      
      // Create a project color map for consistent coloring across all views
      const projectColorMap = {};
      data.tasks.forEach(task => {
        if (task.project && task.projectColor && !projectColorMap[task.project]) {
          projectColorMap[task.project] = task.projectColor;
        }
      });
      
      console.log('Current view mode:', ganttDataMode);
      
      // Filter by project if a specific project is selected
      let filteredTasks = data.tasks;
      
      console.log('Filtering tasks - Available projects:', [...new Set(data.tasks.map(t => t.project))]);
      console.log('Current project filter:', currentProjectFilter);
      
      if (currentProjectFilter && currentProjectFilter !== 'all') {
        // Keep only tasks that belong to the selected project
        filteredTasks = data.tasks.filter(task => {
          return task.project === currentProjectFilter;
        });
        
        console.log(`Filtered to ${filteredTasks.length} tasks with project=${currentProjectFilter}`);
        
        // If no tasks are found after filtering, display a message
        if (filteredTasks.length === 0) {
          document.getElementById('frappeGantt').innerHTML = 
            '<div class="info-box">No tasks found for project "' + currentProjectFilter + '".</div>';
          hideDashboardLoading();
          return;
        }
      }
      
      // Get tasks based on the current view mode
      const tasksToRender = _prepareTasksForGanttRender(filteredTasks, ganttDataMode, projectColorMap);
      
      console.log('Rendering', tasksToRender.length, 'items in', ganttDataMode, 'mode');
      
      // Clear previous chart
      document.getElementById('frappeGantt').innerHTML = '';
      
      // Initialize the Gantt chart
      ganttInstance = new Gantt('#frappeGantt', tasksToRender, {
        view_mode: ganttViewMode,
        date_format: 'YYYY-MM-DD',
        bar_height: 20,
        bar_corner_radius: 3,
        arrow_curve: 5,
        padding: 18,
        popup_on: 'hover',
        view_modes: ['Day', 'Week', 'Month', 'Year'],
        on_click: function(task) {
          if (task.project) {
            console.log('Filtering to project:', task.project);
            toggleProjectFilter(task.project);
          }
        },
        on_date_change: function(task, start, end) {
          console.log('Task ' + task.name + ' date changed: ' + start + ' to ' + end);
        },
        custom_popup_html: _createGanttPopupHtml
      });
      
      // The Observer will detect when the chart is rendered and apply colors
      
      // Add legend for projects
      addProjectLegend(tasksToRender);
      
      hideDashboardLoading();
    }
    
    /**
     * Creates the HTML content for the Gantt chart task popup.
     * @param {object} task - The task object from Frappe Gantt.
     * @return {string} HTML string for the popup.
     */
    function _createGanttPopupHtml(task) {
      const isSection = task.custom_class === 'section-bar';
      const dateFormat = new Intl.DateTimeFormat('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric'
      });
      
      const startDate = new Date(task.start);
      const endDate = new Date(task.end);
      
      const formattedStart = dateFormat.format(startDate);
      const formattedEnd = dateFormat.format(endDate);
      
      const durationMs = endDate - startDate;
      const durationDays = Math.ceil(durationMs / (1000 * 60 * 60 * 24));
      
      let htmlContent = '<div class="gantt-popup-content">';
      htmlContent += '<div class="popup-title">' + task.name + '</div>';
      
      if (isSection) {
        const taskPlural = task.taskCount !== 1 ? 's' : '';
        htmlContent += '<div class="popup-task-count">' + task.taskCount + ' task' + taskPlural + '</div>';
      } else {
        htmlContent += '<div class="popup-project">' + task.project + '</div>';
        htmlContent += '<div class="popup-section">Section: ' + task.section + '</div>';
      }
      
      htmlContent += '<div class="popup-dates">';
      htmlContent += '<span>' + formattedStart + '</span> - <span>' + formattedEnd + '</span>';
      htmlContent += '<span>(' + durationDays + ' day' + (durationDays !== 1 ? 's' : '') + ')</span>';
      htmlContent += '</div>';
      
      htmlContent += '<div class="popup-progress">';
      htmlContent += '<div class="progress-label">Progress: ' + task.progress + '%</div>';
      htmlContent += '<div class="progress-bar">';
      htmlContent += '<div class="progress-fill" style="width: ' + task.progress + '%"></div>';
      htmlContent += '</div></div>';
      
      if (task.url) {
        htmlContent += '<div class="popup-action-button">';
        htmlContent += '<a href="' + task.url + '" target="_blank" class="popup-link-button">Open in Asana</a>';
        htmlContent += '</div>';
      }
      
      htmlContent += '</div>';
      return htmlContent;
    }
    
    /**
     * Prepares tasks for Gantt rendering based on the selected data mode (tasks or sections).
     * @param {Array<object>} filteredTasks - The array of tasks already filtered by project (if applicable).
     * @param {string} dataMode - 'tasks' or 'sections'.
     * @param {object} projectColorMap - A map of project names to their colors.
     * @return {Array<object>} The array of tasks formatted and ready for Gantt rendering.
     */
    function _prepareTasksForGanttRender(filteredTasks, dataMode, projectColorMap) {
      let tasksToRender;
      if (dataMode === 'sections') {
        console.log('Creating section view for Gantt');
        tasksToRender = aggregateTasksBySection(filteredTasks, projectColorMap);
      } else {
        console.log('Creating task view for Gantt');
        tasksToRender = filteredTasks.map(task => ({
          id: task.id,
          name: task.name,
          start: task.start_on,
          end: task.due_on,
          progress: task.completed ? 100 : 0,
          dependencies: '',
          custom_class: task.completed ? 'task-completed' : 'task-pending',
          project: task.project,
          section: task.section,
          projectId: task.projectId,
          projectColor: task.projectColor || projectColorMap[task.project] || '#26717D',
          url: task.url
        }));
        // Sort tasks by start date for task view
        tasksToRender.sort((a, b) => new Date(a.start) - new Date(b.start));
      }
      return tasksToRender;
    }
    
    /**
     * Extracts a project URL from a given Asana task URL.
     * @param {string} taskUrl - The URL of an Asana task.
     * @return {string|null} The derived project URL or null if not derivable.
     */
    function _extractProjectUrlFromTask(taskUrl) {
      if (!taskUrl) return null;

      // Try to extract the project ID using patterns that match project/xxxx pattern
      const projectIdRegex = /\/project\/(\d+)/;
      const projectMatch = taskUrl.match(projectIdRegex);

      if (projectMatch && projectMatch[1]) {
        // If we found a project ID in the URL
        const projectId = projectMatch[1];
        // Assuming a common workspace ID. This might need to be more dynamic if it varies.
        return 'https://app.asana.com/1/1205851800440605/project/' + projectId; 
      } else {
        // Fallback: try to extract any numeric ID that might be the project ID
        // This is less reliable and assumes a certain URL structure.
        const numericIds = taskUrl.match(/\/(\d+)/g) || [];
        if (numericIds.length >= 2) { 
          // Use the second numeric ID as the project ID (often workspace/project)
          const projectId = numericIds[1].replace('/', '');
          // Assuming a common workspace ID or a generic URL structure that works with /0/
          return 'https://app.asana.com/0/0/project/' + projectId; // Or use a known workspace ID if available
        }
      }
      return null; // Could not derive project URL
    }

    /**
     * Creates a formatted section bar object for the Gantt chart from a group of tasks.
     * @param {object} group - An object representing a group of tasks for a specific project/section.
     *                         Expected properties: tasks (array), project, section, projectId, projectColor.
     * @return {object} A formatted object ready for Frappe Gantt, representing the section bar.
     */
    function _createSectionBarFromGroup(group) {
      // Find earliest start date and latest end date in the section
      const startDates = group.tasks.map(t => new Date(t.start_on));
      const endDates = group.tasks.map(t => new Date(t.due_on));
      
      const earliestStart = new Date(Math.min(...startDates));
      const latestEnd = new Date(Math.max(...endDates));
      
      // Calculate overall progress as average of all tasks
      const totalProgress = group.tasks.reduce((sum, task) => sum + (task.completed ? 100 : 0), 0);
      const avgProgress = group.tasks.length > 0 ? Math.round(totalProgress / group.tasks.length) : 0;
      
      let projectUrl = null;
      if (group.tasks.length > 0 && group.tasks[0].url) {
        projectUrl = _extractProjectUrlFromTask(group.tasks[0].url);
      }
      
      return {
        id: 'section-' + group.project + '-' + group.section.replace(/\s+/g, '-'),
        name: group.project + ' - ' + group.section,
        start: earliestStart.toISOString().split('T')[0],
        end: latestEnd.toISOString().split('T')[0],
        progress: avgProgress,
        dependencies: '',
        custom_class: 'section-bar',
        project: group.project,
        section: group.section,
        projectId: group.projectId,
        projectColor: group.projectColor,
        url: projectUrl, 
        taskCount: group.tasks.length
      };
    }

    function aggregateTasksBySection(tasks, projectColorMap) {
      console.log('Aggregating tasks by section, total tasks:', tasks.length);
      
      // Group tasks by project and section
      const sectionGroups = {};
      
      tasks.forEach(task => {
        const key = task.project + '::' + task.section;
        
        if (!sectionGroups[key]) {
          // Get project color from task or from the color map
          const projectColor = task.projectColor || (projectColorMap && projectColorMap[task.project]) || '#26717D';
          
          sectionGroups[key] = {
            tasks: [],
            project: task.project,
            section: task.section,
            projectId: task.projectId,
            projectColor: projectColor,
          };
        }
        
        sectionGroups[key].tasks.push(task);
      });
      
      // Create aggregated tasks for each section
      const sectionTasks = Object.values(sectionGroups).map(group => _createSectionBarFromGroup(group));
      
      // Sort section tasks by start date
      sectionTasks.sort((a, b) => new Date(a.start) - new Date(b.start));
      
      console.log('Created', sectionTasks.length, 'section bars');
      
      return sectionTasks;
    }
    
    // Function to render project legend and filters
    function renderProjectLegend(projectColors) {
      const legendContainer = document.createElement('div');
      legendContainer.className = 'gantt-legend';
      
      // Add "All Projects" option
      const allProjectsItem = document.createElement('div');
      allProjectsItem.className = 'legend-item active';
      allProjectsItem.innerHTML = `
        <span class="legend-color all-projects"></span>
        <span class="legend-label">All Projects</span>
      `;
      allProjectsItem.onclick = function() {
        toggleProjectFilter('all');
      };
      legendContainer.appendChild(allProjectsItem);
      
      // Add each project with its color
      Object.keys(projectColors).forEach(projectName => {
        const legendItem = document.createElement('div');
        legendItem.className = 'legend-item';
        legendItem.innerHTML = `
          <span class="legend-color ${projectColors[projectName]}"></span>
          <span class="legend-label">${projectName}</span>
        `;
        legendItem.onclick = function() {
          toggleProjectFilter(projectName);
        };
        legendContainer.appendChild(legendItem);
      });
      
      // Add legend before the Gantt chart
      const ganttContainer = document.getElementById('ganttContainer');
      const existingLegend = document.querySelector('.gantt-legend');
      if (existingLegend) {
        ganttContainer.removeChild(existingLegend);
      }
      ganttContainer.insertBefore(legendContainer, document.getElementById('frappeGantt'));
    }
    
    // Function to filter tasks by project
    function toggleProjectFilter(projectName) {
      // Update active state in legend
      document.querySelectorAll('.legend-item').forEach(item => {
        if ((projectName === 'all' && item.querySelector('.legend-label').textContent === 'All Projects') ||
            item.querySelector('.legend-label').textContent === projectName) {
          item.classList.add('active');
        } else {
          item.classList.remove('active');
        }
      });
      
      // Store the current project filter
      currentProjectFilter = projectName;
      console.log('Current project filter:', currentProjectFilter);
      
      // If we have gantt data, redraw the chart with the new filter
      if (ganttData) {
        drawFrappeGantt(ganttData);
      }
    }
    
    // Variable to track if Gantt has been loaded
    let ganttLoaded = false;
    
    // Function to toggle Gantt chart visibility
    function toggleGanttChart() {
      const ganttContainer = document.getElementById('ganttContainer');
      const welcomeMessage = document.querySelector('.welcome-message');
      const projectsContainer = document.getElementById('projectsContainer');
      const toggleButton = document.getElementById('toggleGanttButton');
      
      if (ganttContainer.style.display === 'none') {
        // Show Gantt chart
        ganttContainer.style.display = 'block';
        
        // Update button text and icon to show Dashboard option
        if (toggleButton) {
          toggleButton.innerHTML = '<i class="material-icons">dashboard</i> Dashboard';
        }
        
        // Hide welcome message and projects if they exist
        if (welcomeMessage) {
          welcomeMessage.style.display = 'none';
        }
        
        if (projectsContainer) {
          projectsContainer.style.display = 'none';
        }
        
        // Only load Gantt data if it hasn't been loaded yet
        if (!ganttLoaded) {
          // Show loading indicator only for first load
          loadFrappeGantt();
          ganttLoaded = true;
        } else {
          // Force a refresh after a short delay to ensure proper rendering
          setTimeout(function() {
            if (ganttInstance) {
              ganttInstance.refresh(ganttInstance.tasks);
              // Apply colors again after refresh
              colorizeGanttBars();
            }
          }, 300);
        }
      } else {
        // Hide Gantt chart
        ganttContainer.style.display = 'none';
        
        // Update button text and icon to show Gantt option
        if (toggleButton) {
          toggleButton.innerHTML = '<i class="material-icons">timeline</i> Gantt';
        }
        
        // Check if we have projects to display
        if (projectsContainer && projectsContainer.children.length > 0 && 
            !projectsContainer.querySelector('.error-message')) {
          // Show projects if we have them
          projectsContainer.style.display = 'grid';
        } else {
          // Otherwise show welcome message
          if (welcomeMessage) {
            welcomeMessage.style.display = 'flex';
          }
        }
      }
    }
    
    // Initialize components on document ready
    document.addEventListener('DOMContentLoaded', function() {
      // Don't load Gantt automatically - will be loaded when button is clicked
    });
    
    // Load projects from Google Sheet
    function loadProjects() {
      showDashboardLoading('Loading projects...');
      google.script.run
        .withSuccessHandler(function(result) {
          const projectsContainer = document.getElementById('projectsContainer');
          hideDashboardLoading();
          
          if (result.success && result.projects && result.projects.length > 0) {
            // Hide welcome message and show projects
            document.querySelector('.welcome-message').style.display = 'none';
            projectsContainer.style.display = 'grid';
            
            // Clear existing projects
            projectsContainer.innerHTML = '';
            
            // Create and append project cards
            result.projects.forEach(function(project) {
              const card = createProjectCard(project);
              projectsContainer.appendChild(card);
            });
            
            // Apply color to project cards
            applyColorToProjectCards();
          } else {
            // Show welcome message
            document.querySelector('.welcome-message').style.display = 'flex';
            projectsContainer.style.display = 'none';
          }
        })
        .withFailureHandler(function(error) {
          hideDashboardLoading();
          showErrorMessage(error);
        })
        .getProjects();
    }
    
    // The createProjectCard function has been moved to ProjectCard.html
    
    // Handle the Add Project modal
    // function setupAddProjectModal() {
    //   const addProjectButton = document.getElementById('addProjectButton');
    //   const modal = document.getElementById('addProjectModal');
    //   const closeBtn = document.getElementById('closeModal');
    //   const cancelBtn = document.getElementById('cancelAddProject');
    //   const form = document.getElementById('addProjectForm');
    //   const submitBtn = document.getElementById('submitAddProject');
    //   const errorMessage = document.getElementById('formErrorMessage');
    //   const modalTitle = document.getElementById('modalTitle');
    //   const projectIdField = document.getElementById('projectId');
    //   const isEditModeField = document.getElementById('isEditMode');
      
    //   /**
    //    * Populates the add/edit project form with existing project data.
    //    * @param {object} project - The project data object.
    //    */
    //   function _populateProjectForm(project) {
    //     document.getElementById('projectNameInput').value = project.name;
    //     document.getElementById('projectClient').value = project.client || '';
    //     document.getElementById('projectClientEmail').value = project.clientEmail || '';
    //     document.getElementById('projectClientAddress').value = project.clientAddress || '';
    //     document.getElementById('projectArchitect').value = project.architect || '';
    //     document.getElementById('projectArchitectEmail').value = project.architectEmail || '';
    //     document.getElementById('projectContractor').value = project.contractor || '';
    //     document.getElementById('projectContractorEmail').value = project.contractorEmail || '';
    //     document.getElementById('projectStatus').value = project.status || 'Not Started';
    //     document.getElementById('asanaProjectId').value = project.asanaProjectId ? project.asanaProjectId.replace(/["']/g, '') : '';
    //     document.getElementById('projectSheetId').value = project.sheetId || '';
    //     document.getElementById('projectFolderId').value = project.folderId || '';
    //     document.getElementById('projectColorInput').value = project.projectColor || '#26717D';
    //   }

    //   /**
    //    * Collects and returns data from the add/edit project form.
    //    * @return {object} An object containing the project form data.
    //    */
    //   function _getProjectFormData() {
    //     return {
    //       name: document.getElementById('projectNameInput').value.trim(),
    //       client: document.getElementById('projectClient').value.trim(),
    //       clientEmail: document.getElementById('projectClientEmail').value.trim(),
    //       clientAddress: document.getElementById('projectClientAddress').value.trim(),
    //       architect: document.getElementById('projectArchitect').value.trim(),
    //       architectEmail: document.getElementById('projectArchitectEmail').value.trim(),
    //       contractor: document.getElementById('projectContractor').value.trim(),
    //       contractorEmail: document.getElementById('projectContractorEmail').value.trim(),
    //       status: document.getElementById('projectStatus').value,
    //       asanaProjectId: document.getElementById('asanaProjectId').value ? 
    //                       document.getElementById('asanaProjectId').value.replace(/["']/g, '').trim() : '',
    //       sheetId: document.getElementById('projectSheetId').value.trim() || '',
    //       folderId: document.getElementById('projectFolderId').value.trim() || '',
    //       projectColor: document.getElementById('projectColorInput').value || '#26717D'
    //     };
    //   }

    //   /**
    //    * Handles the success response from adding or updating a project.
    //    * @param {object} response - The response object from the server.
    //    * @param {boolean} isEditMode - True if the operation was an update, false for an add.
    //    * @param {HTMLElement} submitBtn - The submit button element.
    //    * @param {function} closeModalFn - The function to close the modal.
    //    * @param {HTMLElement} errorMessageElement - The error message display element.
    //    */
    //   function _handleProjectFormSubmitSuccess(response, isEditMode, submitBtn, closeModalFn, errorMessageElement) {
    //     submitBtn.disabled = false;
    //     submitBtn.textContent = isEditMode ? 'Update Project' : 'Add Project';
    //     hideDashboardLoading();

    //     if (!response.success) {
    //       errorMessageElement.textContent = response.error;
    //       errorMessageElement.style.display = 'block';
    //       return;
    //     }
        
    //     closeModalFn();
    //     const welcomeMessage = document.querySelector('.welcome-message');
    //     if (welcomeMessage) {
    //       welcomeMessage.style.display = 'none';
    //     }
    //     loadProjects(); // Reload projects on success
    //   }

    //   /**
    //    * Handles the failure response from adding or updating a project.
    //    * @param {object} error - The error object from the server call.
    //    * @param {boolean} isEditMode - True if the operation was an update, false for an add.
    //    * @param {HTMLElement} submitBtn - The submit button element.
    //    * @param {HTMLElement} errorMessageElement - The error message display element.
    //    */
    //   function _handleProjectFormSubmitError(error, isEditMode, submitBtn, errorMessageElement) {
    //     submitBtn.disabled = false;
    //     submitBtn.textContent = isEditMode ? 'Update Project' : 'Add Project';
    //     hideDashboardLoading();
    //     errorMessageElement.textContent = 'Error ' + (isEditMode ? 'updating' : 'adding') + ' project: ' + (error.message || error.toString());
    //     errorMessageElement.style.display = 'block';
    //   }

    //   // Open modal for new project
    //   addProjectButton.addEventListener('click', function() {
    //     // Reset form and set to Add mode
    //     form.reset();
    //     modalTitle.textContent = 'Add New Project';
    //     submitBtn.textContent = 'Add Project';
    //     projectIdField.value = '';
    //     isEditModeField.value = 'false';
        
    //     modal.classList.add('visible');
    //   });
      
    //   // Close modal functions
    //   function closeModal() {
    //     modal.classList.remove('visible');
    //     form.reset();
    //     errorMessage.style.display = 'none';
        
    //     // Reset any edit buttons that might be in loading state
    //     document.querySelectorAll('.edit-project-btn.loading').forEach(button => {
    //       button.classList.remove('loading');
    //     });
    //   }
      
    //   closeBtn.addEventListener('click', closeModal);
    //   cancelBtn.addEventListener('click', closeModal);
      
    //   // Close when clicking outside the modal
    //   modal.addEventListener('click', function(event) {
    //     if (event.target === modal) {
    //       closeModal();
    //     }
    //   });
      
    //   // Open modal for editing an existing project
    //   document.addEventListener('click', function(event) {
    //     if (event.target.classList.contains('edit-project-btn') || 
    //         (event.target.parentElement && event.target.parentElement.classList.contains('edit-project-btn'))) {
    //       // Get the button and project ID
    //       const button = event.target.classList.contains('edit-project-btn') ? 
    //                      event.target : event.target.parentElement;
    //       const projectId = button.getAttribute('data-project-id');
          
    //       // Show loading state on the button
    //       button.classList.add('loading');
          
    //       // Fetch project data
    //       google.script.run
    //         .withSuccessHandler(function(response) {
    //           // Reset loading state
    //           button.classList.remove('loading');
              
    //           if (!response.success) {
    //             alert('Error loading project: ' + response.error);
    //             return;
    //           }
              
    //           // Fill form with project data
    //           _populateProjectForm(response.project);
              
    //           // Set form to Edit mode
    //           modalTitle.textContent = 'Edit Project';
    //           submitBtn.textContent = 'Update Project';
    //           projectIdField.value = projectId;
    //           isEditModeField.value = 'true';
              
    //           // Show modal
    //           modal.classList.add('visible');
    //         })
    //         .withFailureHandler(function(error) {
    //           // Reset loading state on error
    //           button.classList.remove('loading');
    //           alert('Error loading project: ' + error);
    //         })
    //         .getProjectById(projectId);
    //     }
    //   });
      
    //   // Form submission
    //   submitBtn.addEventListener('click', function() {
    //     const nameInput = document.getElementById('projectNameInput');
        
    //     if (!nameInput || !nameInput.value.trim()) {
    //       errorMessage.textContent = 'Project name is required';
    //       errorMessage.style.display = 'block';
    //       return;
    //     }
        
    //     // Get form data
    //     const formData = _getProjectFormData();
        
    //     // Disable submit button and show loading state
    //     submitBtn.disabled = true;
    //     submitBtn.textContent = isEditModeField.value === 'true' ? 'Updating...' : 'Adding...';
    //     errorMessage.style.display = 'none';
        
    //     // Determine whether to add or update
    //     const isEditMode = isEditModeField.value === 'true';
    //     const projectId = projectIdField.value;
        
    //     // Show loading overlay
    //     showDashboardLoading(isEditMode ? 'Updating project...' : 'Adding project...');
        
    //     if (isEditMode) {
    //       // Update existing project
    //       google.script.run
    //         .withSuccessHandler(function(response) {
    //           _handleProjectFormSubmitSuccess(response, true, submitBtn, closeModal, errorMessage);
    //         })
    //         .withFailureHandler(function(error) {
    //           _handleProjectFormSubmitError(error, true, submitBtn, errorMessage);
    //         })
    //         .updateProject(projectId, formData);
    //     } else {
    //       // Add new project
    //       google.script.run
    //         .withSuccessHandler(function(response) {
    //           _handleProjectFormSubmitSuccess(response, false, submitBtn, closeModal, errorMessage);
    //         })
    //         .withFailureHandler(function(error) {
    //           _handleProjectFormSubmitError(error, false, submitBtn, errorMessage);
    //         })
    //         .addProject(formData);
    //     }
    //   });
    // }
    
    
    // Render the Gantt chart with the provided tasks
    function renderGanttChart(tasks) {
      if (!tasks || tasks.length === 0) {
        showGanttError('No timeline data available. Make sure your Asana tasks have start and due dates.');
        return;
      }
      
      // Format tasks for Frappe Gantt
      const ganttTasks = tasks.map(task => {
        return {
          id: task.id,
          name: task.name,
          start: task.start_on,
          end: task.due_on,
          progress: task.completed ? 100 : 0,
          dependencies: '', // No dependencies in this version
          custom_class: task.completed ? 'task-completed' : 'task-pending',
          project: task.project,
          section: task.section,
          url: task.url,
          projectColor: task.projectColor
        };
      });
      
      // Initialize the Gantt chart
      const ganttElement = document.getElementById('ganttChart');
      if (ganttElement) {
        // Clear previous chart
        ganttElement.innerHTML = '';
        
        const gantt = new Gantt(ganttElement, ganttTasks, {
          view_mode: 'Week',
          date_format: 'YYYY-MM-DD',
          popup_on: 'hover',
          on_click: function(task) {
            window.open(task.url, '_blank');
          },
          on_date_change: function(task, start, end) {
            console.log('Task ' + task.name + ' changed. New dates: ' + start + ' to ' + end);
            // We're not saving changes in this version
          },
          custom_popup_html: function(task) {
            return `
              <div class="gantt-task-popup">
                <h5>${task.name}</h5>
                <p><strong>Project:</strong> ${task.project}</p>
                <p><strong>Section:</strong> ${task.section}</p>
                <p><strong>Start:</strong> ${new Date(task.start).toLocaleDateString()}</p>
                <p><strong>End:</strong> ${new Date(task.end).toLocaleDateString()}</p>
                <p><strong>Status:</strong> ${task.progress === 100 ? 'Completed' : 'In Progress'}</p>
                <p class="popup-action">Click to open in Asana</p>
              </div>
            `;
          }
        });
        
        // Setup zoom controls
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const viewModeSelect = document.getElementById('viewModeSelect');
        
        if (zoomInBtn) {
          zoomInBtn.addEventListener('click', function() {
            const modes = ['Quarter Day', 'Half Day', 'Day', 'Week', 'Month', 'Year'];
            const currentIdx = modes.indexOf(gantt.options.view_mode);
            if (currentIdx > 0) {
              gantt.change_view_mode(modes[currentIdx - 1]);
              viewModeSelect.value = modes[currentIdx - 1];
            }
          });
        }
        
        if (zoomOutBtn) {
          zoomOutBtn.addEventListener('click', function() {
            const modes = ['Quarter Day', 'Half Day', 'Day', 'Week', 'Month', 'Year'];
            const currentIdx = modes.indexOf(gantt.options.view_mode);
            if (currentIdx < modes.length - 1) {
              gantt.change_view_mode(modes[currentIdx + 1]);
              viewModeSelect.value = modes[currentIdx + 1];
            }
          });
        }
        
        if (viewModeSelect) {
          viewModeSelect.addEventListener('change', function() {
            gantt.change_view_mode(this.value);
          });
        }
      }
    }
    
    function showGanttError(message) {
      const loadingIndicator = document.getElementById('ganttLoading');
      const errorElement = document.getElementById('ganttErrorMessage');
      
      if (loadingIndicator) {
        loadingIndicator.style.display = 'none';
      }
      
      if (errorElement) {
        errorElement.textContent = message;
        errorElement.style.display = 'block';
      }
    }
    
    function colorizeGanttBars() {
      if (!ganttInstance) return;
      
      console.log('Applying colors to bars...');
      
      // Store projects that need colors applied
      const coloredTasks = [];
      
      // Add color styling for each task based on project color
      ganttInstance.tasks.forEach(task => {
        if (task.projectColor) {
          coloredTasks.push(task);
        }
      });
      
      // Apply colors to all tasks with a slight delay between each
      // to ensure the DOM has time to process each update
      coloredTasks.forEach((task, index) => {
        setTimeout(() => {
          // Use more specific and robust selectors
          let barWrappers = document.querySelectorAll(`.gantt .bar-wrapper[data-id="${task.id}"]`);
          let barElements = document.querySelectorAll(`.gantt .bar-wrapper[data-id="${task.id}"] .bar`);
          let progressElements = document.querySelectorAll(`.gantt .bar-wrapper[data-id="${task.id}"] .bar-progress`);
          
          if (barElements.length === 0) {
            // Try with CSS escaping for IDs with special characters
            const escapedId = CSS.escape(task.id);
            barWrappers = document.querySelectorAll(`.gantt .bar-wrapper[data-id="${escapedId}"]`);
            barElements = document.querySelectorAll(`.gantt .bar-wrapper[data-id="${escapedId}"] .bar`);
            progressElements = document.querySelectorAll(`.gantt .bar-wrapper[data-id="${escapedId}"] .bar-progress`);
          }
          
          // Apply colors to all matching elements
          barElements.forEach(element => {
            // Apply the project color
            element.style.fill = task.projectColor;
            element.style.stroke = task.projectColor;
          });
          
          progressElements.forEach(element => {
            // Make progress bar a darker shade of the project color
            element.style.fill = adjustColor(task.projectColor, -20);
          });
        }, index * 10); // Stagger the updates with a small delay
      });
    }
    
    function adjustColor(color, amount) {
      let usePound = false;
      
      if (color[0] === "#") {
        color = color.slice(1);
        usePound = true;
      }
      
      const num = parseInt(color, 16);
      
      let r = (num >> 16) + amount;
      r = Math.max(Math.min(r, 255), 0);
      
      let g = ((num >> 8) & 0x00FF) + amount;
      g = Math.max(Math.min(g, 255), 0);
      
      let b = (num & 0x0000FF) + amount;
      b = Math.max(Math.min(b, 255), 0);
      
      return (usePound ? "#" : "") + (g | (r << 8) | (b << 16)).toString(16).padStart(6, '0');
    }
    
    function addProjectLegend(tasks) {
      // Remove any existing legends first
      const existingLegends = document.querySelectorAll('.gantt-legend');
      existingLegends.forEach(legend => legend.remove());
      
      // Create a map of projects and their colors
      const projectMap = {};
      
      tasks.forEach(task => {
        if (task.project && task.projectColor && !projectMap[task.project]) {
          projectMap[task.project] = task.projectColor;
        }
      });
      
      // Create legend container
      const legendContainer = document.createElement('div');
      legendContainer.className = 'gantt-legend';
      
      // Add "All Projects" option first
      const allProjectsItem = document.createElement('div');
      allProjectsItem.className = 'legend-item' + (currentProjectFilter === 'all' ? ' active' : '');
      allProjectsItem.innerHTML = `
        <span class="legend-color all-projects"></span>
        <span class="legend-label">All Projects</span>
      `;
      allProjectsItem.onclick = function() {
        toggleProjectFilter('all');
      };
      legendContainer.appendChild(allProjectsItem);
      
      // Add each project with its color
      Object.keys(projectMap).forEach(projectName => {
        const color = projectMap[projectName];
        const projectItem = document.createElement('div');
        projectItem.className = 'legend-item' + (currentProjectFilter === projectName ? ' active' : '');
        projectItem.innerHTML = `
          <div class="legend-color" style="background-color: ${color}"></div>
          <div class="legend-label">${projectName}</div>
        `;
        projectItem.onclick = function() {
          toggleProjectFilter(projectName);
        };
        legendContainer.appendChild(projectItem);
      });
      
      // Add the legend to the Gantt container
      const ganttContainer = document.getElementById('frappeGantt');
      if (ganttContainer) {
        ganttContainer.parentNode.insertBefore(legendContainer, ganttContainer);
      }
    }

    // Function to initialize the Gantt view when loaded directly
    function initializeGanttView(projectId) {
      // Show Gantt container
      const ganttContainer = document.getElementById('ganttContainer');
      const welcomeMessage = document.querySelector('.welcome-message');
      const projectsContainer = document.getElementById('projectsContainer');
      const toggleButton = document.getElementById('toggleGanttButton');
      
      // Update button text to show Dashboard option
      if (toggleButton) {
        toggleButton.innerHTML = '<i class="material-icons">dashboard</i> Dashboard';
      }
      
      // Show Gantt chart
      if (ganttContainer) {
        ganttContainer.style.display = 'block';
      }
      
      // Hide welcome message and projects
      if (welcomeMessage) {
        welcomeMessage.style.display = 'none';
      }
      
      if (projectsContainer) {
        projectsContainer.style.display = 'none';
      }
      
      // Load Gantt data
      loadFrappeGantt(projectId);
      ganttLoaded = true;
    }
    
    // Load Gantt data from the server
    function loadFrappeGantt(projectId) {
      // Only use the dashboard loading overlay, not secondary loading indicator
      showDashboardLoading('Loading Gantt chart...');
      document.getElementById('frappeGantt').innerHTML = ''; // Clear the container
      
      // Setup observer to detect when chart is rendered
      setupGanttObserver();
      
      google.script.run
        .withSuccessHandler(function(data) {
          drawFrappeGantt(data);
          // Force a refresh after a short delay to ensure proper rendering
          setTimeout(function() {
            if (ganttInstance) {
              ganttInstance.refresh(ganttInstance.tasks);
              // Apply colors again after refresh
              colorizeGanttBars();
            }
          }, 300);
        })
        .withFailureHandler(function(error) {
          document.getElementById('frappeGantt').innerHTML = '<div class="error-box">Error loading Gantt chart: ' + error + '</div>';
          hideDashboardLoading();
        })
        .getAsanaTasksForGantt(projectId);
    }

    // Project Details Modal Functionality
    // Add event delegation for View Details buttons
    document.addEventListener('click', function(event) {
      if (event.target.classList.contains('view-details-btn') || 
          (event.target.parentElement && event.target.parentElement.classList.contains('view-details-btn'))) {
        
        // Get the button element
        const button = event.target.classList.contains('view-details-btn') ? 
          event.target : event.target.parentElement;
        
        // Get project ID
        const projectId = button.getAttribute('data-project-id');
        const sheetId = button.getAttribute('data-sheet-id');
        const folderId = button.getAttribute('data-folder-id');
        const projectName = button.getAttribute('data-project-name');
        
        if (!projectId) {
          alert('Project ID not found.');
          return;
        }
        
        if (!sheetId) {
          alert('This project does not have a Sheet ID configured. Please edit the project to add a Sheet ID.');
          return;
        }
        
        // Show loading overlay with enhanced overlay effect
        const loadingEl = document.getElementById('dashboardLoadingOverlay');
        if (loadingEl) {
          loadingEl.style.display = 'flex';
          document.getElementById('dashboardLoadingMessage').textContent = 'Loading project details...';
          document.body.classList.add('loading-active'); // Add class to prevent scrolling
        }
        
        // Load the Project_Details_.html content through a server-side function
        google.script.run
          .withSuccessHandler(function(result) {
            // Hide loading overlay
            if (loadingEl) {
              loadingEl.style.display = 'none';
              document.body.classList.remove('loading-active'); // Remove class when done
            }
            
            // Get the modal and content container
            const modal = document.getElementById('projectDetailsModal');
            const contentContainer = document.getElementById('projectDetailsContent');
            
            // Clear the content container
            contentContainer.innerHTML = '';
            
            // Append the processed content
            contentContainer.innerHTML = result;
            
            // Set the project ID as a data attribute on the modal for reference
            modal.setAttribute('data-project-id', projectId);
            if (sheetId) {
              modal.setAttribute('data-sheet-id', sheetId);
            }
            // Add folder ID and project name as data attributes
            if (folderId) {
              modal.setAttribute('data-folder-id', folderId);
              console.log('Set folder ID data attribute:', folderId);
            }
            if (projectName) {
              modal.setAttribute('data-project-name', projectName);
            }
            
            // Add a class to the body to prevent scrolling behind the modal
            document.body.classList.add('modal-open');
            
            // Show the modal
            modal.style.display = 'block';
            
            // Initialize any scripts or components inside the loaded content
            if (typeof initProjectDetailsPage === 'function') {
              initProjectDetailsPage(projectId);
              console.log('Project details loaded successfully');
            }
          })
          .withFailureHandler(function(error) {
            // Hide loading overlay
            if (loadingEl) {
              loadingEl.style.display = 'none';
              document.body.classList.remove('loading-active'); // Remove class on error too
            }
            alert('Error loading project details: ' + error);
            console.log('Error loading project details: ' + error);
          })
          .getProjectDetailsContent(projectId);
      }
    });
    
    // Close modal when clicking the X
    document.addEventListener('click', function(event) {
      if (event.target.classList.contains('close-modal')) {
        const modal = document.getElementById('projectDetailsModal');
        if (modal) { // Ensure modal exists
          // Check if item selection is active before closing
          const itemSelectionContent = document.querySelector('#mainContent .item-selection-content');
          const selectItemsBtnActive = document.getElementById('selectItemsBtn')?.classList.contains('btn-active');
          if (itemSelectionContent && selectItemsBtnActive) {
            if (typeof handleSaveDraftItem === 'function') {
              console.log("[DashboardScripts.js] Modal close (X button click): Item selection active. Saving draft.");
              handleSaveDraftItem();
            } else {
              console.warn("[DashboardScripts.js] Modal close (X button click): handleSaveDraftItem not found.");
            }
          }
          modal.style.display = 'none';
          document.body.classList.remove('modal-open');
        }
      }
    });
    
    // Close modal when clicking outside the content
    window.addEventListener('click', function(event) {
      const modal = document.getElementById('projectDetailsModal');
      if (event.target === modal) {
        // Check if item selection is active before closing
        const itemSelectionContent = document.querySelector('#mainContent .item-selection-content');
        const selectItemsBtnActive = document.getElementById('selectItemsBtn')?.classList.contains('btn-active');
        if (itemSelectionContent && selectItemsBtnActive) {
          if (typeof handleSaveDraftItem === 'function') {
            console.log("[DashboardScripts.js] Modal close (click outside): Item selection active. Saving draft.");
            handleSaveDraftItem();
          } else {
            console.warn("[DashboardScripts.js] Modal close (click outside): handleSaveDraftItem not found.");
          }
        }
        modal.style.display = 'none';
        document.body.classList.remove('modal-open');
      }
    });

  /**
   * Switches between sidebar tabs
   * @param {string} tabId - The ID of the tab to switch to (without the '-content' suffix)
   */
  function switchSidebarTab(tabId) {
    console.log(`[Tabs] switchSidebarTab: Called. Current active tab: '${currentActiveSidebarTabId}', New tab: '${tabId}'`);

    // If navigating away from the 'items' tab, save the draft.
    // Ensure currentActiveSidebarTabId is not null and was indeed the items tab.
    if (currentActiveSidebarTabId === 'items' && tabId !== 'items') {
      console.log(`[Tabs] switchSidebarTab: Navigating away from '${currentActiveSidebarTabId}' tab to '${tabId}'. Triggering handleSaveDraftItem.`);
      handleSaveDraftItem();
    }

    // Hide all sidebar content sections
    const contentSections = document.querySelectorAll('.sidebar-content');
    // contentSections.forEach(section => {
    //   section.classList.remove('active');
    // });
    
    // Remove active class from all tabs
    const tabs = document.querySelectorAll('.sidebar-tab');
    // tabs.forEach(tab => {
    //   tab.classList.remove('active');
    // });
    
    // Show the selected content section
    const selectedContent = document.getElementById(tabId + '-content');
    // if (selectedContent) {
    //   selectedContent.classList.add('active');
    // }
    
    // Add active class to the selected tab
    const selectedTab = document.querySelector(`.sidebar-tab[data-tab="${tabId}"]`);
    // if (selectedTab) {
    //   selectedTab.classList.add('active');
    // }
    
    // Update the current active tab ID
    currentActiveSidebarTabId = tabId;
    console.log("Switched to tab:", currentActiveSidebarTabId);

    const sidebarElement = document.querySelector('.sidebar');
    const sidebarToggleElement = document.getElementById('sidebarToggle');
    const sidebarToggleIcon = sidebarToggleElement ? sidebarToggleElement.querySelector('.material-icons') : null;

    // Special handling for specific tabs
    if (tabId === 'items') {
      if (typeof showItemSelectionInterface === 'function') {
        // Pass handleLoadDraftItem as a callback. 
        // showItemSelectionInterface in modal_scripts.js.html now expects only the callback.
        showItemSelectionInterface(handleLoadDraftItem); 
      } else {
        // showItemSelectionInterface IS NOT a function, so we cannot load items or drafts.
        console.warn('[DashboardScripts.js] showItemSelectionInterface function not found. Cannot load items or draft.');
        const itemsContent = document.getElementById('items-content');
        if (itemsContent) {
          itemsContent.innerHTML = '<div class="error-message"><p>Error: Item selection interface loader not found.</p></div>';
        }
      }
      // Collapse the sidebar using the existing 'collapsed' class (common for 'items' tab)
      if (sidebarElement && !sidebarElement.classList.contains('collapsed')) {
        sidebarElement.classList.add('collapsed');
        if (sidebarToggleIcon) sidebarToggleIcon.textContent = 'chevron_right';
        if (sidebarToggleElement) sidebarToggleElement.classList.add('collapsed');
        console.log('[DashboardScripts.js] Sidebar collapsed for items tab.');
      }
    } else {
      // For all other tabs, ensure the sidebar is expanded
      if (sidebarElement && sidebarElement.classList.contains('collapsed')) {
        sidebarElement.classList.remove('collapsed');
        if (sidebarToggleIcon) sidebarToggleIcon.textContent = 'chevron_left';
        if (sidebarToggleElement) sidebarToggleElement.classList.remove('collapsed');
        console.log('[DashboardScripts.js] Sidebar expanded for tab:', tabId);
      }
      // Existing tab-specific content loaders
      if (tabId === 'roomCategories') {
        showRoomCategoriesMain();
      } else if (tabId === 'rooms') {
        if (typeof window.showRoomManager === 'function') {
          console.log('[DashboardScripts.js] switchSidebarTab: Calling showRoomManager() for tab: rooms');
          window.showRoomManager('main');
        } else {
          console.warn('[DashboardScripts.js] switchSidebarTab: loadSidebarRoomManager function not found when trying to load tab: rooms');
          const contentArea = document.getElementById(tabId + '-content');
          if (contentArea) {
            contentArea.innerHTML = '<div class="error-message"><p>Error: Room manager content loader not found. Please define loadSidebarRoomManager.</p></div>';
          }
        }
      } // Add other else if conditions for other tabs if necessary
    }
  }
  
  // Initialize sidebar tab click handlers
  document.addEventListener('DOMContentLoaded', function() {
    // Add click event listeners to all sidebar tabs
    document.querySelectorAll('.sidebar-tab').forEach(tab => {
      tab.addEventListener('click', function() {
        const tabId = this.getAttribute('data-tab');
        switchSidebarTab(tabId);
      });
    });

    // Add beforeunload listener to save drafts if item selection is active
    window.addEventListener('beforeunload', function(event) {
      const itemSelectionContent = document.querySelector('#mainContent .item-selection-content');
      const selectItemsBtnActive = document.getElementById('selectItemsBtn')?.classList.contains('btn-active');

      if (itemSelectionContent && selectItemsBtnActive) {
        console.log("[DashboardScripts.js] beforeunload: Item selection active. Attempting to save draft.");
        // Note: Direct call to google.script.run in beforeunload might be unreliable or blocked by browsers.
        // The handleSaveDraftItem function itself makes the server call.
        // Depending on browser behavior, this might not complete successfully if the page unloads too quickly.
        if (typeof handleSaveDraftItem === 'function') {
          handleSaveDraftItem();
          // For critical data, consider prompting the user: "You have unsaved changes. Are you sure you want to leave?"
          // event.preventDefault(); // This would show a generic browser prompt
          // event.returnValue = ''; // Necessary for some older browsers
        } else {
          console.warn("[DashboardScripts.js] beforeunload: handleSaveDraftItem function not found.");
        }
      }
    });

    // Original modal close button handler (if one exists and needs modification)
    // Assuming the close button has class 'close-modal' and is within 'projectDetailsModal'
    // const projectModal = document.getElementById('projectDetailsModal');  // REMOVE THIS BLOCK START
    // if (projectModal) {
    //     const closeButton = projectModal.querySelector('.close-modal'); // Adjust selector if needed
    //     if (closeButton) {
    //         closeButton.addEventListener('click', function() {
    //             const itemSelectionContent = document.querySelector('#mainContent .item-selection-content');
    //             const selectItemsBtnActive = document.getElementById('selectItemsBtn')?.classList.contains('btn-active');
    //             if (itemSelectionContent && selectItemsBtnActive) {
    //                 if (typeof handleSaveDraftItem === 'function') {
    //                     console.log("[DashboardScripts.js] Modal close (button click): Item selection active. Saving draft.");
    //                     handleSaveDraftItem();
    //                 } else {
    //                     console.warn("[DashboardScripts.js] Modal close (button click): handleSaveDraftItem not found.");
    //                 }
    //             }
    //             // The original event listener for closing modal will still fire and hide it.
    //             // No need to call modal.style.display = 'none' here again if it's already handled.
    //         });
    //     }
    // } // REMOVE THIS BLOCK END
  });
  
  // Room Categories Functions
  
  /**
   * Navigate from Room Manager to Room Categories.
   * This saves the selected rooms and then switches to the Room Categories tab.
   */
  function navigateToRoomCategories() {
    // Get selected rooms from the UI
    const selectedRoomCheckboxes = document.querySelectorAll('#sidebarRoomManagerContent input[type="checkbox"]:checked');
    
    // Extract room names from the labels next to the checkboxes
    const selectedRooms = Array.from(selectedRoomCheckboxes).map(checkbox => {
      // Find the associated label text which contains the actual room name
      const label = checkbox.closest('.room-checklist-item').querySelector('.room-checklist-item-label');
      return label ? label.textContent.trim() : null;
    }).filter(roomName => roomName); // Filter out any null values
    
    if (selectedRooms.length === 0) {
      alert('Please select at least one room first.');
      return;
    }
    
    // Show loading state
    document.getElementById('roomCategoriesContent').innerHTML = `
      <div class="loading-state">
        <div class="spinner"></div>
        <p>Loading categories...</p>
      </div>
    `;
    
    // Save the selected rooms
    google.script.run
      .withSuccessHandler(function(result) {
        if (result.success) {
          // Switch to the Room Categories tab
          switchSidebarTab('roomCategories');
          
          // Load the Room Categories content
          loadRoomCategoriesContent();
        } else {
          alert('Error saving selected rooms: ' + result.error);
        }
      })
      .withFailureHandler(function(error) {
        alert('Error: ' + error);
      })
      .saveSelectedRoomsCore(selectedRooms);
  }
  
  /**
   * Load the Room Categories content.
   * Gets the selected rooms and available types to build the UI.
   */
  function loadRoomCategoriesContent() {
    // Disable buttons and show loading state
    document.getElementById('btn-cat-back').disabled = true;
    document.getElementById('selectItemsBtn').disabled = true;
    document.getElementById('roomCategoriesContent').innerHTML = 
      '<div class="loading-state">' +
      '  <div class="spinner"></div>' +
      '  <p>Loading categories...</p>' +
      '</div>';
    
    google.script.run
      .withSuccessHandler(function(result) {
        if (result.success) {
          if (!result.selectedRooms || result.selectedRooms.length === 0) {
            document.getElementById('roomCategoriesContent').innerHTML = 
              '<div class="room-manager-content" style="padding: 20px; text-align: center;">' +
              '  <p>There are no rooms selected for this project. Choose them <a href="#" onclick="event.preventDefault(); switchSidebarTab(\'rooms\');" style="text-decoration: underline; color: var(--primary-color, #007bff); cursor: pointer;">here</a>.</p>' +
              '</div>';
            // Keep buttons disabled as the main UI isn't loaded
            document.getElementById('btn-cat-back').disabled = true;
            document.getElementById('selectItemsBtn').disabled = true;
            return;
          }
          buildRoomCategoriesUI(result.selectedRooms, result.availableTypes, result.roomTypes);
          // Enable buttons after successful UI build
          document.getElementById('btn-cat-back').disabled = false;
          document.getElementById('selectItemsBtn').disabled = false;
        } else {
          document.getElementById('roomCategoriesContent').innerHTML = 
            '<div class="error-message">' +
            '  <p>Error loading room categories: ' + result.error + '</p>' +
            '</div>';
          // Keep buttons disabled on error
          document.getElementById('btn-cat-back').disabled = true;
          document.getElementById('selectItemsBtn').disabled = true;
        }
      })
      .withFailureHandler(function(error) {
        document.getElementById('roomCategoriesContent').innerHTML = 
          '<div class="error-message">' +
          '  <p>Error: ' + error + '</p>' +
          '</div>';
        // Keep buttons disabled on failure
        document.getElementById('btn-cat-back').disabled = true;
        document.getElementById('selectItemsBtn').disabled = true;
      })
      .getRoomCategoriesData();
  }
  
  /**
   * Build the Room Categories UI.
   * Creates a section for each selected room with checkboxes for each type.
   * 
   * @param {Array} selectedRooms - Array of selected room names
   * @param {Array} availableTypes - Array of available type names
   * @param {Object} roomTypes - Object with room names as keys and arrays of selected types as values
   */
  function buildRoomCategoriesUI(selectedRooms, availableTypes, roomTypes) {
    if (!selectedRooms || selectedRooms.length === 0) {
      document.getElementById('roomCategoriesContent').innerHTML = `
        <div class="info-message">
          <p>No rooms selected. Please go back and select rooms first.</p>
        </div>
        <button onclick="switchSidebarTab('rooms')" class="btn">
          <i class="material-icons">arrow_back</i> Back to Room Selection
        </button>
      `;
      // Ensure buttons are disabled if this path is taken directly
      document.getElementById('btn-cat-back').disabled = true;
      document.getElementById('selectItemsBtn').disabled = true;
      return;
    }
    if (!availableTypes || availableTypes.length === 0) {
      document.getElementById('roomCategoriesContent').innerHTML = `
        <div class="info-message">
          <p>No categories found in the Data sheet. Please add categories to the Type column.</p>
        </div>
      `;
      // Keep buttons disabled, allow user to go back or fix data
      document.getElementById('btn-cat-back').disabled = false; // Allow going back
      document.getElementById('selectItemsBtn').disabled = true;
      return;
    }
    
    // Create a container element similar to room manager
    let html = `
      <div class="room-manager-content">

        <div class="room-categories-container">
    `;
    
    // For each selected room
    selectedRooms.forEach(room => {
      html += `
        <div class="room-category-section">
          <div class="room-category-header">${room}</div>
          <div class="room-category-types">
      `;
      
      // For each available type, create a checkbox
      availableTypes.forEach(type => {
        // Check if this type is selected for this room
        const isChecked = roomTypes && 
                          roomTypes[room] && 
                          Array.isArray(roomTypes[room]) && 
                          roomTypes[room].includes(type);
        
        html += `
          <label class="type-checkbox">
            <input type="checkbox" 
                   data-room="${room}" 
                   data-type="${type}"
                   ${isChecked ? 'checked' : ''}>
            <span class="room-checklist-item-label">${type}</span>
          </label>
        `;
      });
      
      html += `
          </div>
        </div>
      `;
    });
    
    html += `
        </div>
      </div>
    `;
    
    document.getElementById('roomCategoriesContent').innerHTML = html;
  }
  
  /**
   * Save the Room Categories selections.
   * Collects all checked checkboxes and organizes them by room.
   * 
   * @param {boolean} navigateToRooms - Whether to navigate to the rooms tab after saving
   */
  function saveRoomCategoriesSelections(navigateToRooms = false) {
    // Disable all sidebar action buttons to prevent double click
    const actionButtons = document.querySelectorAll('#roomCategories-content .sidebar-action-buttons button');
    actionButtons.forEach(btn => btn.disabled = true);
    // Collect all checkbox selections FIRST
    const checkboxes = document.querySelectorAll('#roomCategoriesContent input[type="checkbox"]');
    const roomTypes = {};
    checkboxes.forEach(checkbox => {
      const room = checkbox.getAttribute('data-room');
      const type = checkbox.getAttribute('data-type');
      if (checkbox.checked) {
        if (!roomTypes[room]) roomTypes[room] = [];
        roomTypes[room].push(type);
      }
    });

    // THEN show loading state
    document.getElementById('roomCategoriesContent').innerHTML = `
      <div class="loading-state">
        <div class="spinner"></div>
        <p>Saving categories...</p>
      </div>
    `;

    // Continue with the rest of the function...
    google.script.run
      .withSuccessHandler(function(result) {
        // Disable all sidebar action buttons to prevent double click
        const actionButtons = document.querySelectorAll('#roomCategories-content .sidebar-action-buttons button');
        actionButtons.forEach(btn => btn.disabled = false);

        if (navigateToRooms) {
          switchSidebarTab('rooms');
          loadSidebarRoomManager();
        } else {
          // OLD BEHAVIOR:
          // loadRoomCategoriesContent();
          // if (typeof showItemSelectionInterface === 'function') {
          //   showItemSelectionInterface();
          // }
          // NEW BEHAVIOR: Switch to the items tab
          switchSidebarTab('items');
        }
      })
      .withFailureHandler(function(error) {
        document.getElementById('roomCategoriesContent').innerHTML = `
          <div class="error-message">
            <p>Error saving categories: ${error}</p>
          </div>
        `;
      })
      .saveRoomTypeSelections(roomTypes);
  }

  // Function to save categories and navigate to rooms
  function saveAndNavigateToRooms() {
    saveRoomCategoriesSelections(true);
  }

  // --- NEW SIMPLIFIED Initial Tab Activation Logic ---
  document.addEventListener('DOMContentLoaded', function() {
    // Read the global variable set by Project_Details_.html
    var tabToOpenOnLoad = window.initialTabIdFromAppsScript;

    console.log('[DashboardScripts.js] DOMContentLoaded: initialTabIdFromAppsScript from window is:', tabToOpenOnLoad);

    if (tabToOpenOnLoad) {
      if (typeof window.switchSidebarTab === 'function') {
        console.log('[DashboardScripts.js] Attempting to call switchSidebarTab with ID:', tabToOpenOnLoad);
        try {
          window.switchSidebarTab(tabToOpenOnLoad);

          // If the opened tab is the Room Manager, call its specific content loader.
          // Assuming 'roomManagerView' is the ID passed for the "Rooms" tab, 
          // and its loader is loadSidebarRoomManager().
          // Adjust tabToOpenOnLoad === 'yourActualRoomManagerTabId' if different.
          if (tabToOpenOnLoad === 'roomManagerView' || tabToOpenOnLoad === 'rooms') { 
            if (typeof window.loadSidebarRoomManager === 'function') {
              console.log('[DashboardScripts.js] Calling loadSidebarRoomManager() for tab:', tabToOpenOnLoad);
              window.loadSidebarRoomManager();
            } else {
              console.warn('[DashboardScripts.js] loadSidebarRoomManager function not found, content for Room Manager might not load.');
            }
          }

          // Verification after a short delay for DOM updates
          setTimeout(function() {
            var expectedTabContentId = tabToOpenOnLoad + '-content';
            var activeContent = document.querySelector('.sidebar-content.active');
            var activeTabButton = document.querySelector('.sidebar-tab.active');

            if (activeContent && activeContent.id === expectedTabContentId) {
              console.log('[DashboardScripts.js] VERIFIED: Tab content "' + expectedTabContentId + '" is active.');
            } else if (activeTabButton && activeTabButton.getAttribute('data-tab') === tabToOpenOnLoad) {
              console.log('[DashboardScripts.js] VERIFIED: Tab button for "' + tabToOpenOnLoad + '" is active.');
            } else {
              console.warn('[DashboardScripts.js] switchSidebarTab was called for "' + tabToOpenOnLoad + '". Tab does not appear active. Check ID (' + tabToOpenOnLoad + ') and switchSidebarTab function.');
              if (activeContent) console.warn('[DashboardScripts.js] Current active content ID: ' + activeContent.id + ', Expected: ' + expectedTabContentId);
              if (activeTabButton) console.warn('[DashboardScripts.js] Current active tab button data-tab: ' + activeTabButton.getAttribute('data-tab') + ', Expected: ' + tabToOpenOnLoad);
            }
          }, 250); // 250ms delay
        } catch (e) {
          console.error('[DashboardScripts.js] Error calling switchSidebarTab:', e);
        }
      } else {
        console.warn('[DashboardScripts.js] switchSidebarTab function is not defined or not globally accessible. Cannot switch to tab:', tabToOpenOnLoad);
      }
    } else {
      console.log('[DashboardScripts.js] No initial tab ID specified by server. Default tab should load as per existing logic (if any).');
    }
  });
  // --- END OF NEW SIMPLIFIED Initial Tab Activation Logic ---

    // --- Temporary Item Data/Draft Functions ---

    /**
     * Collects data from the item selection interface.
     * This interface is rendered by `renderItemSelectionInterface` (in modal_scripts.js.html)
     * into the #mainContent element.
     * Assumes item name and type are not edited in this interface, only selection and quantity.
     * @returns {Array<Object> | null} An array of item objects, or null if no relevant data.
     */
    function collectDraftItemSelections() {
      console.log("[Drafts] collectDraftItemSelections: Collecting based on checkbox and quantity...");
      const mainContentContainer = document.getElementById('mainContent');
      if (!mainContentContainer) {
        console.warn("[Drafts] collectDraftItemSelections: 'fileContent' container not found.");
        return null;
      }

      const itemRows = mainContentContainer.querySelectorAll('.item-row');
      if (itemRows.length === 0) {
        console.log("[Drafts] collectDraftItemSelections: No item rows found in 'fileContent'.");
        return null;
      }

      const draftItems = [];
      itemRows.forEach(row => {
        const roomName = row.dataset.room;
        // const itemIndex = row.dataset.index; // UI index, less reliable for matching

        const checkbox = row.querySelector('.item-checkbox');
        const typeInput = row.querySelector('.type-input'); // Read its current value for matching
        const itemInput = row.querySelector('.item-input'); // Read its current value for matching
        const quantityInput = row.querySelector('.quantity-input');

        // It's crucial that renderItemSelectionInterface consistently renders these values (item, type, room)
        // or provides a stable data-original-id for robust matching.
        const currentItemName = itemInput ? itemInput.value : '';
        const currentItemType = typeInput ? typeInput.value : '';
        const currentQuantity = quantityInput ? (parseInt(quantityInput.value) || 1) : 1;
        const isSelected = checkbox ? checkbox.checked : false;

        // Only include items that are selected in the draft for simplicity,
        // as unselected items with default quantities don't need explicit restoration.
        if (isSelected) {
          draftItems.push({
            room: roomName,
            type: currentItemType, // Store the type as it appears in the UI for matching
            item: currentItemName, // Store the item name as it appears for matching
            quantity: currentQuantity, // Store the quantity
            isSelected: true
            // originalId: row.dataset.originalId // IDEAL: if renderItemSelectionInterface adds this
          });
        }
      });

      if (draftItems.length === 0) {
        console.log("[Drafts] collectDraftItemSelections: No items are currently selected for the draft.");
        return null; // Return null if nothing is selected, so handleSaveDraftItem clears any old draft.
      }

      console.log("[Drafts] collectDraftItemSelections: Collected selected items for draft:", JSON.stringify(draftItems));
      return draftItems;
    }

    /**
     * Populates the item selection interface with draft data.
     * Assumes item name and type are fixed by renderItemSelectionInterface.
     * Restores isSelected and quantity.
     * @param {Array<Object>} draftData The array of item data to populate the form with.
     */
    function populateItemForm(draftData) {
      console.log("[Drafts] populateItemForm: Applying draft to selection interface...", JSON.stringify(draftData));
      if (!draftData || !Array.isArray(draftData) || draftData.length === 0) {
        console.log("[Drafts] populateItemForm: No draft data to apply.");
        return;
      }

      const mainContentContainer = document.getElementById('mainContent');
      if (!mainContentContainer) {
        console.warn("[Drafts] populateItemForm: 'mainContent' container not found."); // Corrected 'fileContent' to 'mainContent'
        return;
      }

      const allItemRowsInUI = mainContentContainer.querySelectorAll('.item-row');
      // Reset all UI rows to default state first
      allItemRowsInUI.forEach(uiRow => {
        const uiCheckbox = uiRow.querySelector('.item-checkbox');
        if (uiCheckbox && uiCheckbox.checked) {
          uiCheckbox.checked = false;
          uiCheckbox.dispatchEvent(new Event('change', { bubbles: true }));
        }
        const uiQuantityInput = uiRow.querySelector('.quantity-input');
        if (uiQuantityInput && uiQuantityInput.value !== '1') {
           uiQuantityInput.value = '1';
           uiQuantityInput.dispatchEvent(new Event('change', { bubbles: true }));
        }
      });

      draftData.forEach(draftItem => {
        if (!draftItem.isSelected) return; 

        let foundRow = null;
        const draftRoomUpper = String(draftItem.room || '').toUpperCase();
        const draftItemNameUpper = String(draftItem.item || '').toUpperCase(); 
        const draftTypeNameUpper = String(draftItem.type || '').toUpperCase();

        console.log(`[Drafts] populateItemForm: Processing draftItem: Room='${draftRoomUpper}', Type='${draftTypeNameUpper}', Item='${draftItemNameUpper}'`);
        
        for (const row of allItemRowsInUI) {
          const domRowRoomUpper = String(row.dataset.room || '').toUpperCase();
          
          // Match by data-room (already done)
          if (draftRoomUpper === domRowRoomUpper) {
            // IDEALLY, renderItemSelectionInterface adds data-item-name and data-item-type to the row.
            // If not, this relies on input fields which is less robust.
            const domItemNameAttr = row.dataset.itemName; // Preferred: Use data attribute
            const domTypeNameAttr = row.dataset.itemType; // Preferred: Use data attribute

            let domItemNameValueUpper, domTypeNameValueUpper;

            if (domItemNameAttr !== undefined && domTypeNameAttr !== undefined) {
              // Match using data attributes if available
              domItemNameValueUpper = String(domItemNameAttr || '').toUpperCase();
              domTypeNameValueUpper = String(domTypeNameAttr || '').toUpperCase();
              console.log(`[Drafts] populateItemForm: Comparing with DOM row (DATASET): DOM Room='${domRowRoomUpper}', DOM Type='${domTypeNameValueUpper}', DOM Item='${domItemNameValueUpper}'`);
            } else {
              // Fallback: Match using input field values if data attributes are not present
              const currentItemInput = row.querySelector('.item-input');
              const currentTypeInput = row.querySelector('.type-input');
              domItemNameValueUpper = currentItemInput ? String(currentItemInput.value || '').toUpperCase() : ''; 
              domTypeNameValueUpper = currentTypeInput ? String(currentTypeInput.value || '').toUpperCase() : ''; 
              console.log(`[Drafts] populateItemForm: Comparing with DOM row (INPUT VAL): DOM Room='${domRowRoomUpper}', DOM Type='${domTypeNameValueUpper}', DOM Item='${domItemNameValueUpper}'`);
            }

            if (domItemNameValueUpper === draftItemNameUpper && domTypeNameValueUpper === draftTypeNameUpper) {
              foundRow = row;
              break; 
            }
          }
        }

        if (foundRow) {
          console.log("[Drafts] populateItemForm: Restoring draft state for item:", draftItem.item, "in room:", draftItem.room);
          const checkbox = foundRow.querySelector('.item-checkbox');
          const quantityInput = foundRow.querySelector('.quantity-input');

          if (checkbox) {
            if (!checkbox.checked) {
                checkbox.checked = true; 
                checkbox.dispatchEvent(new Event('change', { bubbles: true }));
            }
          }
          if (quantityInput && draftItem.quantity !== undefined) {
            const currentQuantity = parseInt(quantityInput.value);
            const draftQuantity = parseInt(draftItem.quantity);
            if (currentQuantity !== draftQuantity) {
                quantityInput.value = draftItem.quantity;
                quantityInput.dispatchEvent(new Event('change', { bubbles: true }));
            }
          }
        } else {
          console.warn(`[Drafts] populateItemForm: Could not find matching row in UI for draft item: Room='${draftRoomUpper}', Type='${draftTypeNameUpper}', Item='${draftItemNameUpper}'`);
        }
      });
      console.log("[Drafts] populateItemForm: Finished applying draft data.");
    }

    /**
     * Handles saving the current item form data as a draft.
     */
    function handleSaveDraftItem() {
      console.log("[Drafts] handleSaveDraftItem: Initiated.");

      // Check if the item selection interface is actually active/visible
      const itemSelectionContent = document.querySelector('#mainContent .item-selection-content');
      const selectItemsBtnActive = document.getElementById('selectItemsBtn')?.classList.contains('btn-active');

      if (!itemSelectionContent || !selectItemsBtnActive) {
        console.log("[Drafts] handleSaveDraftItem: Item selection interface not active. Aborting draft save.");
        return; // Exit if item selection UI is not active
      }

      const draftData = collectDraftItemSelections(); // MODIFIED
      if (draftData) {
        console.log("[Drafts] handleSaveDraftItem: Saving draft item data:", JSON.stringify(draftData));
        google.script.run
          .withSuccessHandler(function(response) {
            if (response && response.success) {
              console.log("[Drafts] Draft saved successfully via server.");
              if (typeof showDashboardStatusMessage === 'function') {
                showDashboardStatusMessage("Draft saved successfully!", false, 'main'); // Show success message
              } else {
                console.warn("[Drafts] showDashboardStatusMessage function not found. Cannot display draft saved message.");
              }
            } else {
              console.error("[Drafts] Failed to save draft via server:", response ? response.error : 'Unknown error');
              if (typeof showDashboardStatusMessage === 'function') {
                showDashboardStatusMessage("Error saving draft. See console for details.", true, 'main'); // Show error message
              } else {
                console.warn("[Drafts] showDashboardStatusMessage function not found. Cannot display draft error message.");
              }
            }
          })
          .withFailureHandler(function(error) {
            console.error("[Drafts] Error calling server to save draft:", error.message);
            if (typeof showDashboardStatusMessage === 'function') {
              showDashboardStatusMessage("Error saving draft: " + error.message, true, 'main'); // Show error message
            }
          })
          .saveTemporaryItemData(draftData);
      } else {
        console.log("[Drafts] handleSaveDraftItem: No item data to save as draft. Attempting to clear any existing server draft.");
        handleClearDraftItem(); 
      }
    }

    /**
     * Handles loading any existing draft item data into the form.
     */
    function handleLoadDraftItem() {
      console.log("Attempting to load draft item data...");
      // showDashboardLoading("Loading draft..."); // Optional: Show loading indicator
      google.script.run
        .withSuccessHandler(function(response) {
          // hideDashboardLoading(); // Optional: Hide loading indicator
          if (response && response.success) {
            if (response.data) {
              console.log("Draft data found, populating form:", response.data);
              populateItemForm(response.data);
              // Optionally, you could ask the user: "We found a saved draft. Restore it?"
            } else {
              console.log("No draft data found to load.");
            }
          } else {
            console.error("Failed to load draft data:", response ? response.error : 'Unknown server error');
          }
        })
        .withFailureHandler(function(error) {
          // hideDashboardLoading(); // Optional: Hide loading indicator
          console.error("Error loading draft data:", error.message);
        })
        .loadTemporaryItemData();
    }

    /**
     * Handles clearing the temporary item data from the server.
     */
    function handleClearDraftItem() {
      console.log("Clearing draft item data...");
      // showDashboardLoading("Clearing draft..."); // Optional: Show loading indicator
      google.script.run
        .withSuccessHandler(function(response) {
          // hideDashboardLoading(); // Optional: Hide loading indicator
          if (response && response.success) {
            console.log("Draft cleared successfully.");
          } else {
            console.error("Failed to clear draft:", response ? response.error : 'Unknown error');
          }
        })
        .withFailureHandler(function(error) {
          // hideDashboardLoading(); // Optional: Hide loading indicator
          console.error("Error clearing draft:", error.message);
        })
        .clearTemporaryItemData();
    }

    // --- Integration Points (TODO: Implement these based on your UI structure) ---
    // Example: When the relevant page/tab/section for item entry loads:
    // document.addEventListener('DOMContentLoaded', function() { // Or a more specific event
    //   if (isItemEntryPageActive()) { // Replace with your condition
    //     handleLoadDraftItem();
    //   }
    // });

    // Example: When navigating away from item entry (e.g., clicking another tab)
    // const categoryTabButton = document.getElementById('categoryTabButton'); // Replace with your selector
    // if (categoryTabButton) {
    //   categoryTabButton.addEventListener('click', function() {
    //     if (isCurrentlyOnItemEntryTab()) { // Replace with your condition
    //       handleSaveDraftItem();
    //     }
    //   });
    // }
    
    // Example: Before the window unloads (more generic, might catch too much but good fallback)
    // window.addEventListener('beforeunload', function() {
    //    if (isCurrentlyOnItemEntryTab() && hasUnsavedItemData()) { // your conditions
    //        handleSaveDraftItem();
           // Note: synchronous google.script.run calls are not allowed in beforeunload.
           // You might need a more sophisticated way or accept that some data might be lost if relying solely on beforeunload for this.
           // Better to save on explicit navigation actions like tab clicks.
    //    }
    // });


    // Example: After successfully submitting an item to the Master List:
    // function onItemSuccessfullyAddedToMasterList() {
    //   handleClearDraftItem();
    //   // ... your existing success logic ...
    // }

    // Example: If you have a "Discard" or "Cancel" button for the item entry:
    // const discardItemButton = document.getElementById('discardItemEntryButton'); // Replace with your selector
    // if (discardItemButton) {
    //   discardItemButton.addEventListener('click', function() {
    //     clearItemForm(); // Your function to clear the form fields
    //     handleClearDraftItem();
    //   });
    // }

    // MODIFIED setupGanttObserver (V2.5 - uses V4 functions)
    function setupGanttObserver() {
      if (ganttObserver) {
        ganttObserver.disconnect();
      }
      ganttObserver = new MutationObserver((mutations) => {
        const ganttSVGRoot = document.querySelector('#frappeGantt .gantt'); 
        if (ganttSVGRoot && ganttInstance) { 
          // console.log('Gantt chart rendered - initial setup (V2.5).');
          ganttObserver.disconnect(); 

          if (ganttStructureObserver) ganttStructureObserver.disconnect();

          colorizeGanttBars();
          makeGanttHeaderSticky(); 
          
          setTimeout(() => { 
            // console.log('[Setup V2.5] Post-colorize/sticky: Initializing Overlay V4.');
            bringHeaderElementsToFrontV4(); 
            ensureHeaderOverlayIsLastPersistentV3(); 
          }, 300); 
        }
      });
      const frappeGantt = document.getElementById('frappeGantt');
      if (frappeGantt) {
        ganttObserver.observe(frappeGantt, { childList: true, subtree: true });
      }
    }
    
    // MODIFIED updateGanttView (V2.5 - uses V4 functions)
    function updateGanttView() {
      if (!ganttInstance) return;
      ganttInstance.change_view_mode(ganttViewMode);
      setTimeout(() => {
        if (ganttStructureObserver) ganttStructureObserver.disconnect();

        colorizeGanttBars();
        makeGanttHeaderSticky(); 

        setTimeout(() => { 
            // console.log('[UpdateView V2.5] Post-colorize/sticky: Initializing Overlay V4.');
            bringHeaderElementsToFrontV4(); 
            ensureHeaderOverlayIsLastPersistentV3(); 
        }, 300); 
      }, 450);
    }
    
    // NEW function to show Room Categories in the main content area
    /**
     * Shows the Room Categories management interface in the main content area.
     * Fetches selected rooms and master categories, then renders the UI.
     */
    function showRoomCategoriesMain() {
      console.log('showRoomCategoriesMain called');
      const mainContentContainer = document.getElementById('mainContent');
      const projectNameHeader = document.getElementById('projectName');

      if (projectNameHeader) {
        if (!window.originalProjectName) {
          window.originalProjectName = projectNameHeader.innerText;
        }
        projectNameHeader.innerText = 'Set Categories';
      }
      setActiveMainContentButton('setCategoriesBtn'); // Added this line

      if (!mainContentContainer) {
        console.error('showRoomCategoriesMain: Main content container (mainContent) not found!');
        alert('Critical Error: UI container for Room Categories is missing.');
        return;
      }

      renderUIState(mainContentContainer, 'loading', 'Loading room categories...');

      // Call the single comprehensive function to get all category-related data
      google.script.run
        .withSuccessHandler(function(result) {
          if (result && result.success) {
            if (!result.selectedRooms || result.selectedRooms.length === 0) {
              renderUIState(mainContentContainer, 'empty', 'No rooms selected for the project. Please select rooms first in the "Select Rooms" section.');
              return;
            }
            // Pass the data to the rendering function
            // Ensure the data structure matches what renderRoomCategoriesUI expects:
            // { selectedRooms: array, masterCategories: array, assignedCategoriesByRoom: object }
            renderRoomCategoriesUI({
              selectedRooms: result.selectedRooms,
              masterCategories: result.availableTypes || [], // Corresponds to masterCategories
              assignedCategoriesByRoom: result.roomTypes || {} // Corresponds to assignedCategoriesByRoom
            }, 'mainContent', 'main');
          } else {
            const errorMsg = (result && result.error) ? result.error : 'Failed to load category data.';
            renderUIState(mainContentContainer, 'error', errorMsg);
          }
        })
        .withFailureHandler(function(err) {
          renderUIState(mainContentContainer, 'error', 'Error loading category data: ' + (err.message || err));
        })
        .getRoomCategoriesData(); // Use the existing function that fetches all required data
    }


    /**
     * Renders the UI for assigning/managing categories for rooms.
     * @param {object} data - Object containing selectedRooms, masterCategories, and assignedCategoriesByRoom.
     * @param {string} targetContainerId - The ID of the HTML element to render the UI into.
     * @param {string} location - 'sidebar' or 'main', to control UI elements/behavior.
     */
    function renderRoomCategoriesUI(data, targetContainerId, location = 'main') { // Default location to main, and simplify
      console.log(`renderRoomCategoriesUI called for ${location}. Target ID: ${targetContainerId}. Data:`, data);
      const container = document.getElementById(targetContainerId);

      if (!container) {
        console.error(`renderRoomCategoriesUI: Target container '${targetContainerId}' not found.`);
        return;
      }

      // This function now ONLY handles the 'main' location.
      if (location !== 'main') {
        console.warn(`renderRoomCategoriesUI was called with location = '${location}'. It is now dedicated to 'main' location. Call buildRoomCategoriesUI for sidebar.`);
        // Optionally, call buildRoomCategoriesUI here if an old call path still exists, or just return.
        // For safety, let's clear the container if it was for sidebar and an old call reached here.
        if (targetContainerId === 'roomCategoriesContent') container.innerHTML = '<p>Please use main interface for categories.</p>';
        return;
      }

      if (!data || !data.selectedRooms || !data.masterCategories || !data.assignedCategoriesByRoom) {
        renderUIState(container, 'error', 'Incomplete data for rendering room categories.');
        console.error('renderRoomCategoriesUI: Missing critical data components.', data);
        return;
      }

      const { selectedRooms, masterCategories, assignedCategoriesByRoom } = data;

      if (selectedRooms.length === 0) {
        renderUIState(container, 'empty', 'No rooms selected for this project. Please go to "Select Rooms" to add rooms.');
        return;
      }
      
      if (masterCategories.length === 0) {
        renderUIState(container, 'empty', 'No master categories found. Please add categories in the master data sheet or via admin settings.');
        // Potentially add a link or instruction for admins if relevant.
        return;
      }

      let html = '';

      // Main location specific UI (with room tabs)
      html += `
        <div class="category-management-container main-content-area">
          <p class="instructions">Select a room, then check the categories you want to assign to it. Changes are saved automatically.</p>
          <div class="room-tabs-container horizontal-tabs">
      `;
      data.selectedRooms.forEach((room, index) => {
        html += `<button class="tab-button room-tab-btn ${index === 0 ? 'active' : ''}" onclick="switchCategoryRoomTab(this, '${escapeHtml(room)}', 'main')">${escapeHtml(room)}</button>`;
      });
      html += `</div>`; // close room-tabs-container

      html += `<div id="mainCategorySelectionContent" class="category-selection-content tab-content-container">`; // ID is now specific to main

      data.selectedRooms.forEach((room, roomIndex) => {
        const isActiveRoom = roomIndex === 0;
        const roomDisplayStyle = !isActiveRoom ? 'display: none;' : '';

        html += `<div id="mainRoomCategories_${escapeHtml(room.replace(/\s+/g, '_'))}" class="main-category-assignment-section tab-content-panel" style="${roomDisplayStyle}" data-room-name="${escapeHtml(room)}">`;
        
        html += `<ul class="category-checkbox-list checkbox-list-styled">`;
        data.masterCategories.forEach(category => {
          const categoryId = `main_${escapeHtml(room.replace(/\s+/g, '_'))}_cat_${escapeHtml(category.replace(/\s+/g, '_'))}`;
          const isChecked = (data.assignedCategoriesByRoom[room] && data.assignedCategoriesByRoom[room].includes(category));
          html += `
            <li class="checkbox-item">
              <input type="checkbox" class="styled-checkbox" id="${categoryId}" data-room="${escapeHtml(room)}" data-category="${escapeHtml(category)}" 
                     onchange="handleCategorySelectionChange(this, 'main')" ${isChecked ? 'checked' : ''}>
              <label for="${categoryId}" class="checkbox-label">${escapeHtml(category)}</label>
            </li>`;
        });
        html += `</ul>`;
        html += `</div>`; // close main-category-assignment-section
      });

      html += `</div>`; // close category-selection-content
      
      html += `
        </div>`; // close category-management-container

      renderUIState(container, 'success'); // Clear loading/error
      container.innerHTML = html;

      // If in 'main' and there are rooms, ensure the first tab's content is active.
      if (location === 'main' && selectedRooms.length > 0) {
        const firstRoomId = `mainRoomCategories_${escapeHtml(selectedRooms[0].replace(/\s+/g, '_'))}`;
        const firstRoomSection = document.getElementById(firstRoomId);
        if (firstRoomSection) {
          firstRoomSection.style.display = 'block';
        }
      }
    }

    /**
     * Handles switching visibility of category lists when a room tab is clicked in 'main' view.
     * @param {HTMLElement} tabElement - The clicked tab button.
     * @param {string} roomName - The name of the room to show categories for.
     * @param {string} location - Expected to be 'main'.
     */
    function switchCategoryRoomTab(tabElement, roomName, location) {
      if (location !== 'main') return; // Only for main view

      // Deactivate all tabs
      const tabs = tabElement.parentElement.querySelectorAll('.room-tab-btn');
      tabs.forEach(tab => tab.classList.remove('active'));

      // Activate clicked tab
      tabElement.classList.add('active');

      // Hide all room-category sections
      const sections = document.querySelectorAll('.main-category-assignment-section'); // Updated class selector
      sections.forEach(section => section.style.display = 'none');
      
      // Show selected room's category section
      const sectionToShowId = `mainRoomCategories_${escapeHtml(roomName.replace(/\s+/g, '_'))}`; // Updated ID prefix
      const sectionToShow = document.getElementById(sectionToShowId);
      if (sectionToShow) {
        sectionToShow.style.display = 'block';
      } else {
        console.error(`switchCategoryRoomTab: Section with ID ${sectionToShowId} not found.`);
      }
    }


    /**
     * Handles the change event of a category selection checkbox.
     * @param {HTMLInputElement} checkbox - The checkbox element that changed.
     * @param {string} location - 'sidebar' or 'main'.
     */
    function handleCategorySelectionChange(checkbox, location = 'main') { // Default location to main
      const roomName = checkbox.dataset.room;
      const categoryName = checkbox.dataset.category;
      const isSelected = checkbox.checked;

      console.log(`Category selection changed in ${location}: Room '${roomName}', Category '${categoryName}', Selected: ${isSelected}`);
      showDashboardStatusMessage('Saving category changes for ' + roomName + '...', false, location); // Corrected line


      const dialog = document.querySelector('.app-container');
      const sheetId = dialog ? dialog.getAttribute('data-sheet-id') : null;

      if (!sheetId) {
        showDashboardStatusMessage('Error: Sheet ID not found. Cannot save category changes.', true, location);
        checkbox.checked = !isSelected; // Revert UI change
        return;
      }
      
      google.script.run
        .withSuccessHandler(function(result) {
          if (result && result.success) {
            showDashboardStatusMessage('Category \'' + categoryName + '\' ' + (isSelected ? 'assigned to' : 'unassigned from') + ' ' + roomName + '.', false, location); // Corrected line
            // Potentially update a global state if needed, or re-fetch if complex dependencies.
            // For now, optimistic update is fine.

            // Refresh home sidebar content after successful category change
            if (typeof updateHomeSidebarContent === 'function') {
              // Add a small delay to allow server-side changes to propagate
              setTimeout(function() {
                console.log('Refreshing home sidebar after category assignment change for room: ' + roomName);
                updateHomeSidebarContent(true); // Assuming true triggers a full refresh
              }, 300); // 300ms delay
            } else {
              console.warn('updateHomeSidebarContent function not found. Home sidebar will not be refreshed automatically.');
            }
          } else {
            showDashboardStatusMessage('Error updating category for ' + roomName + ': ' + (result.error || 'Unknown error'), true, location); // Corrected line
            checkbox.checked = !isSelected; // Revert UI on failure
          }
        })
        .withFailureHandler(function(err) {
          showDashboardStatusMessage('Error saving category change: ' + (err.message || err), true, location); // Corrected line
          checkbox.checked = !isSelected; // Revert UI on failure
        })
        .updateRoomCategoryAssignment(sheetId, roomName, categoryName, isSelected);
    }

    function loadItemSelection() {
        // This function is called by the "Next: Select Items" button.
        // It directly shows the item selection interface and ensures drafts are loaded.
        console.log("navigateToItemSelection called");
        if (typeof showItemSelectionInterface === 'function') {
            showItemSelectionInterface(handleLoadDraftItem); // Directly call with the draft loading callback
        } else {
            console.error('showItemSelectionInterface function not found. Cannot navigate to item selection.');
            // Consider providing user feedback here, e.g., via an alert or a message in the UI.
            alert('Error: Item selection functionality is currently unavailable.');
        }
    }

</script>