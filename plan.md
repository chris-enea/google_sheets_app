# Norton Project Sheet - Development Plan: Item Management & Saving

**Overview:**
This plan outlines the tasks required to ensure that when a user adds new items or modifies existing items (specifically quantity, low budget, or high budget) within the "Manage Items" UI, these changes are accurately saved back to the "Master Item List" sheet. This also includes assigning unique IDs to new items and ensuring the UI reflects the saved state.

---

## 1. Project Setup
*   **[Existing]** Repository and development environment are assumed to be set up.
*   **[Existing]** "Master Item List" sheet within the active Google Spreadsheet is the target for saving.
*   **[Existing]** Client-side UI (`modal_scripts.js.html`) and server-side Google Apps Script (`itemManager.js`, `Code.js`, etc.) are in place.
*   **[Task] Define/Verify Unique ID Strategy for Items:**
    *   Determine how unique IDs for items in the "Master Item List" sheet are managed.
        *   Are they row numbers?
        *   Are they UUIDs generated by the script?
        *   Is there a dedicated "ID" column in the sheet?
    *   This is crucial for updating the correct rows. For this plan, we'll assume an "ID" column can be added or used if not present. If using row numbers, the strategy will need adjustment.

## 2. Backend Foundation (Server-Side - Google Apps Script)

*   **[New Function] `saveItemsToMasterList(itemsToSave, sheetId)` in `itemManager.js` (or similar .gs file):**
    *   **Purpose:** This will be the primary function called from the client to save all changes (new items, updates to existing items) to the "Master Item List".
    *   **Input:**
        *   `itemsToSave`: An array of item objects from the client. Each item should include:
            *   `id`: (Optional for new items, e.g., a temporary "new_" ID; Required for existing items to identify the row to update).
            *   `room`: String
            *   `type`: String
            *   `item`: String (Item Name)
            *   `quantity`: Number
            *   `lowBudget`: Number or null
            *   `highBudget`: Number or null
            *   (Any other relevant fields like `lowBudgetTotal`, `highBudgetTotal` can be recalculated server-side or passed if already correct).
        *   `sheetId`: String (ID of the spreadsheet).
    *   **Logic:**
        1.  Open the Spreadsheet by `sheetId`.
        2.  Get the "Master Item List" sheet. If not found, return an error.
        3.  Get all data from the sheet, including headers.
        4.  Identify column indices for "ID", "ROOM", "TYPE", "ITEM", "QUANTITY", "LOW BUDGET", "HIGH BUDGET", "LOW BUDGET TOTAL", "HIGH BUDGET TOTAL".
            *   If an "ID" column doesn't exist, the script might need to add it (or this becomes a manual setup step).
        5.  Iterate through `itemsToSave` from the client:
            *   **For New Items:** (e.g., `item.id` starts with "new_" or is missing)
                *   Generate a new unique permanent ID (e.g., UUID, or a simple counter if sheet is small and IDs are managed by this script exclusively).
                *   Recalculate `lowBudgetTotal` and `highBudgetTotal`.
                *   Append a new row to the sheet with the new ID and all item details.
                *   Store the mapping of the temporary client-side ID to the new permanent ID.
            *   **For Existing Items:** (e.g., `item.id` is a permanent ID)
                *   Find the row in the sheet that matches `item.id`.
                *   If found, update the necessary columns (QUANTITY, LOW BUDGET, HIGH BUDGET).
                *   Recalculate and update "LOW BUDGET TOTAL" and "HIGH BUDGET TOTAL" formula or value for that row.
                *   If not found (ID mismatch), log an error/warning for this item.
        6.  Perform batch updates to the sheet (`setValues`) for efficiency rather than updating row by row.
    *   **Return Value:**
        *   `{ success: true, savedItems: [/* array of items as they are in the sheet, including permanent IDs for new items and updated fields for existing ones */], count: numberOfItemsProcessed }`
        *   Or `{ success: false, error: "Error message" }`
*   **[Modify Existing - IF NEEDED] `validateItemsDataCore(items)` in `itemManager.js`:**
    *   This function is currently called by `saveAllItemsFromDashboard`.
    *   **Option A (Keep Separate):** Keep `validateItemsDataCore` purely for validation. The client would first call this, and if successful, then call the new `saveItemsToMasterList`. (Slightly more chatty but cleaner separation of concerns).
    *   **Option B (Integrate):** Modify `validateItemsDataCore` to *also* perform the saving logic if validation passes. Its name might need to be changed to something like `validateAndSaveItemsToMasterList`. This reduces client-server calls.
    *   **Decision for this plan: Option B - Integrate.** Rename `validateItemsDataCore` to `saveItemsToMasterList` and incorporate validation at the beginning. This simplifies the client-side call. The `sheetId` parameter, currently ignored by `validateItemsDataCore`, will now be used.

## 3. Feature-specific Backend (Server-Side - Modifying `validateItemsDataCore` to become `saveItemsToMasterList`)

*   **[Refactor] `validateItemsDataCore` in `itemManager.js` to `saveItemsToMasterList(itemsToSave, sheetId)`:**
    1.  **Parameter Change:** Function signature becomes `function saveItemsToMasterList(itemsToSave, sheetId)`.
    2.  **Initial Validation (Keep Existing Logic):**
        *   The current validation logic within `validateItemsDataCore` (checking for empty items array, missing room/item names, data types) should be the first step. If validation fails, return early with an error.
        *   The `validatedItems` array from the current logic will be the items that proceed to saving.
    3.  **Spreadsheet Interaction (New Logic):**
        *   Open Spreadsheet using `sheetId` (or active if `sheetId` is null/undefined).
        *   Get "Master Item List" sheet. Handle error if not found.
        *   Read all existing data (`sheet.getDataRange().getValues()`). This includes headers.
        *   Determine column indices (ID, ROOM, TYPE, ITEM, QUANTITY, LOW BUDGET, HIGH BUDGET, LOW BUDGET TOTAL, HIGH BUDGET TOTAL).
            *   **Action Item:** Decide on ID strategy. If "ID" column is new, this script section will need to handle its potential absence or creation. For now, assume it exists or can be reliably identified/created.
    4.  **Data Processing & Sheet Update Logic (New Logic):**
        *   Create two arrays: `rowsToUpdate` (for existing items) and `newRowsToAdd` (for new items).
        *   Create a `processedClientItems` array to send back to the client with updated/new IDs.
        *   Iterate through `validatedItems`:
            *   `currentItem = validatedItems[i]`
            *   `clientTemporaryId = currentItem.id` (if it's a "new_" ID)
            *   If `currentItem.id` exists and doesn't look like a temporary ID (e.g., not starting with "new_"):
                *   This is an **update**. Find the row in `existingData` from the sheet where the ID column matches `currentItem.id`.
                *   If found:
                    *   Prepare an array representing the updated sheet row. Update relevant fields (QTY, Budgets). Recalculate total budget columns.
                    *   Add this row array and its target row number to `rowsToUpdate`.
                    *   Add `{...currentItem}` to `processedClientItems` (its ID is already permanent).
                *   If not found: Log an error/warning. Add `currentItem` to `processedClientItems` as is (ID issue).
            *   Else (item is new):
                *   This is an **add**.
                *   Generate a new permanent unique ID (e.g., `Utilities.getUuid()` or handle via sheet if "ID" is a formula like `ROW()-1`).
                *   Prepare an array for the new sheet row using `currentItem` data and the new permanent ID.
                *   Add this new row array to `newRowsToAdd`.
                *   Add `{...currentItem, id: newPermanentId, originalTemporaryId: clientTemporaryId}` to `processedClientItems`. (Include `originalTemporaryId` if client needs to map back).
    5.  **Batch Sheet Writes (New Logic):**
        *   If `rowsToUpdate` is not empty: Iterate and update rows. This is less efficient. Better: collect all data in a 2D array matching the sheet structure and use `sheet.getRange().setValues()`. This requires careful management of which rows in the existing data are being replaced. A simpler approach for updates might be to find row numbers and update cell by cell if batching updates for disparate rows is complex. *For simplicity now, let's assume we find the row index and update that specific range if possible, or cell by cell if easier for scattered updates.*
        *   If `newRowsToAdd` is not empty: Use `sheet.appendRow()` for each or (better) `sheet.getRange(lastRow + 1, 1, newRowsToAdd.length, numColumns).setValues(newRowsToAdd)`.
    6.  **Return Value (Adjusted):**
        *   Return `{ success: true, items: processedClientItems, count: validatedItems.length }`. The `items` array now contains items with their permanent IDs.
        *   Or `{ success: false, error: "Error message", invalidItems: invalidItemsFromValidation }`.

## 4. Frontend Foundation (Client-Side - `modal_scripts.js.html`) - No new functions, but modifications

*   **[Modify] `saveAllItemsFromDashboard()`:**
    *   Change the server call from `google.script.run.validateItemsDataCore(sanitizedItems, sheetId)` to `google.script.run.saveItemsToMasterList(sanitizedItems, sheetId)`.
    *   The `withSuccessHandler` will receive the `result` from `saveItemsToMasterList`.
    *   `result.items` will now be the `processedClientItems` array from the server, which includes permanent IDs for new items.
    *   The call to `updateItemIdsAfterSave(result.items)` should now work correctly, as `result.items` will be the flat array of items with permanent IDs and potentially `originalTemporaryId` if we added that for mapping.
*   **[Modify] `updateItemIdsAfterSave(savedItemsFromServer)`:**
    *   If `saveItemsToMasterList` returns `originalTemporaryId` for new items, use that for a more reliable match with client-side items instead of just room/item/type.
    *   The matching logic:
        ```javascript
        const matchedSavedItem = allSavedItemsWithRoom.find(savedItem => {
            if (itemInDashboard.isNew && savedItem.originalTemporaryId) { // If server sends back original temp ID
                return savedItem.originalTemporaryId === itemInDashboard.id;
            }
            // Fallback to current matching if originalTemporaryId is not available or item wasn't new
            return savedItem.room === itemInDashboard.room && 
                   savedItem.item === itemInDashboard.item && 
                   savedItem.type === itemInDashboard.type &&
                   (!itemInDashboard.isNew && savedItem.id === itemInDashboard.id); // For existing items, ensure IDs also match
        });
        ```
    *   Ensure that after updating `dashboardItemData.items[indexInDashboard].id` and `dashboardItemData.itemsByRoom[itemInDashboard.room][roomIndex].id`, the `isNew` flag is correctly deleted.

## 5. Feature-specific Frontend (Client-Side - `modal_scripts.js.html`)

*   **[No Change Expected] `renderItemUpdateInterface(data)`:** This function initializes `dashboardItemData`. Its normalization logic should remain.
*   **[No Change Expected] `createItemRow(item, index, roomName)`:** This function renders individual item rows. It correctly uses `data-index` and `data-room`.
*   **[No Change Expected] `addItemToRoom(roomName)`:**
    *   This function correctly adds a new item object to `dashboardItemData.itemsByRoom[roomName]` and `dashboardItemData.items`.
    *   It assigns a temporary ID like `'new_' + Date.now()`. This temporary ID will be used by `saveItemsToMasterList` to identify new items and map them to permanent IDs.
*   **[No Change Expected] `updateItemData(roomName, index, field, value)`:** This updates the client-side `dashboardItemData` when an input field changes. This data is what gets sent to the server.

## 6. Integration

*   Client-side `saveAllItemsFromDashboard` calls the new/refactored server-side `saveItemsToMasterList`.
*   Server-side returns processed items with permanent IDs.
*   Client-side `updateItemIdsAfterSave` updates the `dashboardItemData` with these permanent IDs.

## 7. Testing

*   **Adding New Item:**
    *   Add a new item in the UI.
    *   Fill in details (QTY, Budgets).
    *   Click "Save All Items".
    *   **Verify:**
        *   Item is added as a new row in the "Master Item List" sheet.
        *   The new row in the sheet has a permanent, unique ID.
        *   The client-side `dashboardItemData` for that item is updated with the permanent ID, and `isNew` is false.
        *   The UI reflects the saved state (no "new" indicators, item remains).
*   **Updating Existing Item:**
    *   Load items into the UI from the sheet.
    *   Change QTY, Low Budget, or High Budget for an existing item.
    *   Click "Save All Items".
    *   **Verify:**
        *   The corresponding row in the "Master Item List" sheet is updated with the new values.
        *   Total budget columns in the sheet are correctly recalculated for that row.
        *   Client-side `dashboardItemData` reflects the changes.
*   **Validation:**
    *   Try saving an item without an item name.
    *   **Verify:** Server returns a validation error; no changes made to the sheet. Client UI shows an error message.
*   **Concurrency (Manual Test if Possible):**
    *   If two users try to save simultaneously (hard to test precisely), check for data integrity. (This is a lower priority based on PRD but good to keep in mind).
*   **Empty Save:**
    *   If no changes are made or no valid items are present, ensure the system handles it gracefully (e.g., "No changes to save" message).

## 8. Documentation

*   Update JSDoc for the refactored `saveItemsToMasterList` server-side function.
*   Update comments in `modal_scripts.js.html` for `saveAllItemsFromDashboard` and `updateItemIdsAfterSave` if their logic significantly changes.

## 9. Deployment (N/A for this plan - relates to overall app)
## 10. Maintenance (N/A for this plan - relates to overall app) 