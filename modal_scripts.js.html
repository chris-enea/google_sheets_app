<!-- Client-side scripts for modals and UI functionality -->
<script>
      // Global variable to track which input has an open dropdown
      let activeAutocompleteInput = null;

      /**
       * Renders standardized UI states (loading, error, empty, success) within a given container.
       * @param {string|HTMLElement} containerElementOrId - The ID of the container element or the element itself.
       * @param {'loading'|'error'|'empty'|'success'} state - The UI state to render.
       * @param {string} [message=''] - An optional message to display (e.g., error details, empty state text).
       */
      function renderUIState(containerElementOrId, state, message = '') {
        const container = (typeof containerElementOrId === 'string') ? 
                          document.getElementById(containerElementOrId) :
                          containerElementOrId;

        if (!container) {
          console.error('renderUIState: Container not found:', containerElementOrId);
          return;
        }

        container.innerHTML = ''; // Clear previous content

        let iconName = '';
        let defaultMessage = '';
        let stateClass = '';

        switch (state) {
          case 'loading':
            defaultMessage = 'Loading...'; // Default message if none provided
            stateClass = 'loading-state';
            container.innerHTML = `
              <div class="${stateClass}">
                <div class="spinner"></div>
                <p>${message || defaultMessage}</p>
              </div>
            `;
            break;
          case 'error':
            iconName = 'error_outline';
            defaultMessage = 'An error occurred.';
            stateClass = 'error-box-standard';
            container.innerHTML = `
              <div class="${stateClass}">
                <i class="material-icons">${iconName}</i>
                <span>${message || defaultMessage}</span>
              </div>`;
            break;
          case 'empty':
            iconName = 'info_outline';
            defaultMessage = 'No items to display.';
            stateClass = 'empty-state-standard';
            container.innerHTML = `
              <div class="${stateClass}">
                <i class="material-icons">${iconName}</i>
                <span>${message || defaultMessage}</span>
              </div>`;
            break;
          case 'success':
            // Typically, for success, the calling function will populate the actual content.
            // This case can be used if a generic success message is needed.
            if (message) {
              iconName = 'check_circle_outline';
              stateClass = 'success-box-standard';
              container.innerHTML = `
                <div class="${stateClass}">
                  <i class="material-icons">${iconName}</i>
                  <span>${message}</span>
                </div>`;
            }
            // If no message, container remains empty, ready for content.
            break;
          default:
            console.warn('renderUIState: Unknown state:', state);
            container.innerHTML = `<div>Unknown state: ${state}</div>`; // Fallback
        }
      }

       // Sidebar toggle functionality
       /* document.addEventListener('DOMContentLoaded', function() {
        console.log('modal_scripts.js.html: DOMContentLoaded event fired.');

        const sidebarToggle = document.getElementById('sidebarToggle');
        const sidebar = document.querySelector('.sidebar');
        
        // Set up toggle button click event
        if (sidebarToggle && sidebar) {
          sidebarToggle.addEventListener('click', function() {
            sidebar.classList.toggle('collapsed');
            
            // Update the toggle button icon and class
            const toggleIcon = sidebarToggle.querySelector('.material-icons');
            if (sidebar.classList.contains('collapsed')) {
              toggleIcon.textContent = 'chevron_right';
              sidebarToggle.classList.add('collapsed');
            } else {
              toggleIcon.textContent = 'chevron_left';
              sidebarToggle.classList.remove('collapsed');
            }
          });
        }
        
        // Set up tab functionality
        const sidebarTabs = document.querySelectorAll('.sidebar-tab');
        
        sidebarTabs.forEach(tab => {
          tab.addEventListener('click', function() {
            // Remove active class from all tabs and contents
            document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.sidebar-content').forEach(c => c.classList.remove('active'));
            
            // Add active class to clicked tab
            this.classList.add('active');
            
            // Show the corresponding content
            const tabName = this.getAttribute('data-tab');
            const contentElement = document.getElementById(tabName + '-content');
            if (contentElement) {
              contentElement.classList.add('active');
              
              // Load specific content based on tab
              if (tabName === 'rooms') {
                showRoomManager('sidebar');
              } else if (tabName === 'folders') {
                loadFolders('sidebar');
              } else if (tabName === 'tasks') {
                loadAsanaTasks();
              }
            }
            
            // If sidebar is collapsed, expand it
            if (sidebar.classList.contains('collapsed')) {
              sidebar.classList.remove('collapsed');
              sidebarToggle.querySelector('.material-icons').textContent = 'chevron_left';
              sidebarToggle.classList.remove('collapsed');
            }
          });
        });
      }); */

      // Function to toggle folder list visibility
      function toggleList(id) {
        const list = document.getElementById(id);
        if (list) {
          const isVisible = list.style.display === 'block';
          list.style.display = isVisible ? 'none' : 'block';
          
          // Also update the folder icon
          const header = list.previousElementSibling;
          if (header) {
            const folderIcon = header.querySelector('.material-icons:first-child');
            const chevronIcon = header.querySelector('.material-icons.chevron');
            
            if (folderIcon) {
              folderIcon.textContent = isVisible ? 'folder' : 'folder_open';
            }
            
            if (chevronIcon) {
              chevronIcon.textContent = isVisible ? 'chevron_right' : 'expand_more';
            }
          }
        }
      }
      
      function openSettings() {
        google.script.run.showBasicSettings();
      }
      
      function openBudget() {
        google.script.run.showBudgetDialog();
      }
      
      function openItemManager() {
        google.script.run.showItemManager();
      }
      
      function loadAsanaTasks() {
        const taskDisplay = document.getElementById('taskDisplay');
        if (!taskDisplay) return;

        renderUIState(taskDisplay, 'loading', 'Loading Asana tasks...');
        
        google.script.run
          .withSuccessHandler(displayTasks) // Assuming displayTasks handles its own content or calls renderUIState for empty state
          .withFailureHandler(handleTaskError)
          .getAsanaTasks();
      }
      
      function refreshTasks() {
        loadAsanaTasks();
      }
      
      // Assuming handleTaskError function exists or will be created:
      function handleTaskError(error) {
        const taskDisplay = document.getElementById('taskDisplay');
        if (!taskDisplay) return;
        let errorMessage = 'Error loading tasks.';
        if (typeof error === 'string') {
          errorMessage = error;
        } else if (error && error.message) {
          errorMessage = error.message;
        } else if (error && error.details) {
          errorMessage = error.details;
        }
        renderUIState(taskDisplay, 'error', errorMessage);
        console.error('Asana Task Error:', error);
      }
      
      function handleBudgetError(error) {
        const budgetDisplay = document.getElementById('budgetSummaryDisplay');
        if (!budgetDisplay) return;
        let errorMessage = 'Error loading budget data.';
        if (typeof error === 'string') {
          errorMessage = error;
        } else if (error && error.message) {
          errorMessage = error.message;
        } else if (error && error.details) {
          errorMessage = error.details;
        }
        renderUIState(budgetDisplay, 'error', errorMessage);
        console.error('Budget Data Error:', error);
      }
      
      function createNewTask() {
        google.script.run.showAsanaTaskForm();
      }
      
      // Budget Integration Functions
      function loadBudgetData() {
        const budgetDisplay = document.getElementById('budgetSummaryDisplay');
        if (!budgetDisplay) return;
        
        renderUIState(budgetDisplay, 'loading', 'Loading budget data...');
        
        // Get the sheet ID from the project details modal
        const dialog = document.querySelector('.app-container');
        const sheetId = dialog ? dialog.getAttribute('data-sheet-id') : null;
        
        console.log('loadBudgetData: found sheetId:', sheetId);
        
        google.script.run
          .withSuccessHandler(displayBudgetSummary)
          .withFailureHandler(handleBudgetError)
          .getBudgetData(sheetId);
      }
      
      function refreshBudget() {
        loadBudgetData();
      }

      /**
       * Shows the welcome screen in the main content area.
       * Clears any existing content (like Item Manager or Gantt chart) and displays the standard welcome message.
       * Restores the original project name in the main header.
       */
      function showWelcomeScreen() {
        console.log('showWelcomeScreen called - resetting main content');
        const mainContentContainer = document.getElementById('fileContent');
        const projectNameHeader = document.getElementById('projectName');

        if (mainContentContainer) {
          // Set the main content to the welcome message HTML
          mainContentContainer.innerHTML = `
            <div class="welcome-message">
              <i class="material-icons">dashboard</i>
              <h3>Welcome to Norton Interiors</h3>
            </div>
            <!-- Note: The dashboardLoadingOverlay is structurally part of fileContent in Project_Details_.html -->
            <!-- but it is controlled by show/hideDashboardLoading functions globally. -->
            <!-- Re-adding it here might be redundant if those functions expect it to always exist. -->
            <!-- For now, omitting it from direct innerHTML reset, assuming global functions handle it. -->
          `;
          console.log('Main content reset to welcome message.');
        } else {
          console.error('Main content container (fileContent) not found!');
        }

        // Restore the original project name in the header
        if (projectNameHeader && typeof window.originalProjectName === 'string' && window.originalProjectName !== '') {
          projectNameHeader.textContent = window.originalProjectName;
          console.log('Project name restored to:', window.originalProjectName);
        } else if (!projectNameHeader) {
          console.error('Project name header element (projectName) not found!');
        } else {
          console.warn('Original project name (window.originalProjectName) not found, not a string, or is empty. Header not restored.');
          // As a fallback, if originalProjectName isn't available, we might want to set a default or leave it as is.
          // For example: projectNameHeader.textContent = 'Project Dashboard';
        }
        
        // Hide any global loading overlays if they were active
        if (typeof hideDashboardLoading === 'function') {
            hideDashboardLoading();
            console.log('Dashboard loading overlay hidden.');
        }
      }

      function exportBudgetReport() {
        google.script.run
          .withSuccessHandler(function() {
            alert('Budget report exported successfully');
          })
          .withFailureHandler(function(error) {
            alert('Error exporting budget report: ' + error);
          })
          .exportBudgetReport();
      }
      
      function sendVendorEmails() {
        google.script.run
          .withSuccessHandler(function() {
            alert('Emails sent successfully to all vendors');
          })
          .withFailureHandler(function(error) {
            alert('Error sending emails: ' + error);
          })
          .sendVendorEmails();
      }

      function createVendorEmailDraft(vendorName) {
        const emailInput = document.getElementById(`email-${vendorName}`);
        const messageInput = document.getElementById(`message-${vendorName}`);
        const email = emailInput.value.trim();
        const customMessage = messageInput.value.trim();
        
        if (!email) {
          alert('Please enter an email address');
          return;
        }
        
        if (!isValidEmail(email)) {
          alert('Please enter a valid email address');
          return;
        }
        
        google.script.run
          .withSuccessHandler(function() {
            alert('Draft email created successfully for ' + vendorName + '\nCheck your Gmail drafts folder.');
          })
          .withFailureHandler(function(error) {
            alert('Error creating draft email: ' + error);
          })
          .createVendorEmailDraft(vendorName, email, customMessage);
      }
      
      // Modified function to show room manager ONLY in the sidebar
      function showRoomManager() {
        // Store the original project name if not already stored
        const projectNameElement = document.getElementById('projectName');
        if (projectNameElement && !window.originalProjectName) {
          window.originalProjectName = projectNameElement.innerText;
        }
        
        // Update the page title (can still be useful for context)
        if (projectNameElement) {
          projectNameElement.innerText = 'Room Manager';
        }
        
        const containerId = 'sidebarRoomManagerContent';

        console.log('showRoomManager: rendering in sidebar container:', containerId);

        const targetContainer = document.getElementById(containerId);
        if (!targetContainer) {
            console.error('showRoomManager: Sidebar container not found:', containerId);
            // If the main sidebar container itself is missing, there's a larger issue.
            // We could try a body alert as a last resort if no other UI is available.
            alert('Critical Error: Sidebar Room Manager container (id: ' + containerId + ') is missing from the page.');
            return;
        }

        renderUIState(targetContainer, 'loading', 'Loading rooms...');
        
        // Get the sheet ID from the script properties
        const dialog = document.querySelector('.app-container');
        const sheetId = dialog ? dialog.getAttribute('data-sheet-id') : null;

        console.log('showRoomManager: found sheetId:', sheetId);
        
        // Always pass sheetId, as this function is now sidebar-specific
        // and sidebar context implies a sheetId should be available from the projectDetailsModal.
        // If sheetId is null here, getRoomsForDashboard might handle it or error gracefully.
        google.script.run
          .withSuccessHandler(function(result) {
            console.log('getRoomsForDashboard result with sheetId:', result);
            renderUIState(targetContainer, 'success'); 
            renderSidebarRoomManager(result); // This function is designed for sidebar
          })
          .withFailureHandler(function(error) {
            const errorMessage = error.error || error.message || error.toString() || 'Failed to load rooms.';
            renderUIState(targetContainer, 'error', errorMessage);
          })
          .getRoomsForDashboard(sheetId);
      }
      
      /**
       * Sets the loading state for a button.
       * @param {HTMLElement} buttonElement - The button element.
       * @param {boolean} isLoading - True to set loading state, false to restore original state.
       * @param {string} loadingHtml - HTML content for the button in loading state (e.g., spinner icon and text).
       * @param {string} originalHtml - Original HTML content of the button to restore.
       */
      function _setButtonLoadingState(buttonElement, isLoading, loadingHtml, originalHtml) {
        if (!buttonElement) return;

        if (isLoading) {
          buttonElement.innerHTML = loadingHtml;
          buttonElement.disabled = true;
        } else {
          buttonElement.innerHTML = originalHtml;
          buttonElement.disabled = false;
        }
      }
      
      // Function to add a new room from the dashboard or sidebar
      function addNewRoomFromDashboard(location = 'main') {
        const inputId = location === 'main' ? 'newRoomNameDashboard' : 'newRoomNameSidebar';
        const newRoomName = document.getElementById(inputId).value.trim();
        
        if (!newRoomName) {
          showDashboardStatusMessage('Please enter a room name', true, location);
          return;
        }
        
        // Show loading state
        if (location === 'main') {
          showDashboardLoading('Adding room...');
        } else {
          // Add loading state to the button in sidebar
          const addButton = document.querySelector('#sidebarRoomManagerContent .add-room-container button'); // More specific selector
          if (addButton) {
            // Storing original HTML, assuming it's consistent or can be made so.
            // For a more robust solution, original content could be stored on the element or passed if it varies.
            const originalButtonHtml = '<i class="material-icons" style="margin-right: 8px;">add</i> Add Room';
            const loadingButtonHtml = '<i class="material-icons rotating" style="margin-right: 8px;">sync</i> Adding...';
            _setButtonLoadingState(addButton, true, loadingButtonHtml, originalButtonHtml);
          }
        }
        
        // Call server to add room
        google.script.run
          .withSuccessHandler(function(result) {
            if (location === 'main') {
              hideDashboardLoading();
            } else {
              // Restore button state in sidebar
              const addButton = document.querySelector('#sidebarRoomManagerContent .add-room-container button'); // More specific selector
              if (addButton) {
                const originalButtonHtml = '<i class="material-icons" style="margin-right: 8px;">add</i> Add Room';
                // The loadingHTML isn't strictly needed for restore, but originalHTML is key.
                _setButtonLoadingState(addButton, false, '', originalButtonHtml); 
              }
            }
            
            if (result.success) {
              showDashboardStatusMessage(`Room "${result.roomName}" added successfully`, false, location);
              document.getElementById(inputId).value = '';
              // Refresh room manager to show the new room
              showRoomManager(location);
            } else {
              showDashboardStatusMessage(result.error || 'Error adding room', true, location);
            }
          })
          .withFailureHandler(function(error) {
            if (location === 'main') {
              hideDashboardLoading();
            } else {
              // Restore button state in sidebar
              const addButton = document.querySelector('#sidebarRoomManagerContent .add-room-container button'); // More specific selector
              if (addButton) {
                 const originalButtonHtml = '<i class="material-icons" style="margin-right: 8px;">add</i> Add Room';
                _setButtonLoadingState(addButton, false, '', originalButtonHtml);
              }
            }
            showDashboardStatusMessage(`Error: ${error}`, true, location);
          })
          .addRoom(newRoomName);
      }
      
      // Function to save selected rooms from dashboard or sidebar
      function saveRoomsFromDashboard(location = 'main') {
        // Determine which container to use based on location
        const listId = location === 'main' ? 'dashboardRoomList' : 'sidebarRoomList';
        
        // Collect all selected rooms
        const checkboxes = document.querySelectorAll(`#${listId} input[type="checkbox"]:checked`);
        const selectedRooms = Array.from(checkboxes).map(checkbox => checkbox.getAttribute('data-room'));
        
        if (selectedRooms.length === 0) {
          showDashboardStatusMessage('Please select at least one room to continue', true, location);
          return;
        }
        
        // Show loading state
        if (location === 'main') {
          showDashboardLoading('Saving selected rooms...');
        } else {
          // Show loading state for the button in sidebar
          const saveButton = document.querySelector('#sidebarRoomManagerContent .sidebar-action-buttons button[title="Save"]'); // Target specifically the Save button
          if (saveButton) {
            const originalButtonHtml = '<i class="material-icons">save</i> Save';
            const loadingButtonHtml = '<i class="material-icons rotating">sync</i> Saving...';
            _setButtonLoadingState(saveButton, true, loadingButtonHtml, originalButtonHtml);
          }
        }
        
        // Call server to save selected rooms and then show item update interface
        google.script.run
          .withSuccessHandler(function(result) {
            if (location === 'main') {
              hideDashboardLoading();
            } else {
              // Restore button state in sidebar
              const saveButton = document.querySelector('#sidebarRoomManagerContent .sidebar-action-buttons button[title="Save"]'); // Target specifically the Save button
              if (saveButton) {
                const originalButtonHtml = '<i class="material-icons">save</i> Save';
                _setButtonLoadingState(saveButton, false, '', originalButtonHtml);
              }
            }
            
            if (result.success) {
              // Directly load the item update interface in the dashboard
              showItemUpdateInDashboard();
              
              // If we're in the sidebar, collapse it to show the main content
              if (location === 'sidebar') {
                document.querySelector('.sidebar').classList.add('collapsed');
              }
            } else {
              showDashboardStatusMessage('Error: ' + (result.error || 'Failed to save selected rooms'), true, location);
            }
          })
          .withFailureHandler(function(error) {
            if (location === 'main') {
              hideDashboardLoading();
            } else {
              // Restore button state in sidebar
              const saveButton = document.querySelector('#sidebarRoomManagerContent .sidebar-action-buttons button[title="Save"]'); // Target specifically the Save button
              if (saveButton) {
                const originalButtonHtml = '<i class="material-icons">save</i> Save';
                _setButtonLoadingState(saveButton, false, '', originalButtonHtml);
              }
            }
            showDashboardStatusMessage('Error: ' + error, true, location);
          })
          .saveSelectedRoomsOnly(selectedRooms);
      }
      
      // New function to directly show the manage items interface
      function showManageItems() {
        // Update the page title
        document.getElementById('projectName').innerText = 'Manage Items';
        const mainContentContainer = document.getElementById('fileContent');
        
        // Collapse the sidebar when Manage Items is clicked
        document.querySelector('.sidebar').classList.add('collapsed');
        
        // Get the sheet ID from the project details modal
        const dialog = document.querySelector('.app-container');
        const sheetId = dialog ? dialog.getAttribute('data-sheet-id') : null;
        
        console.log('showManageItems: found sheetId:', sheetId);
        
        // Only proceed if we have a sheetId
        if (!sheetId) {
          if (mainContentContainer) {
            renderUIState(mainContentContainer, 'error', '<strong>Error:</strong> No sheet ID found. Unable to load items.');
          }
          return;
        }
        
        // Show global loading overlay and set loading for main container
        showDashboardLoading('Loading items management...');
        if (mainContentContainer) {
            // Use the specific loading state requested by the user
            mainContentContainer.innerHTML = `
              <div class="loading-state">
                <div class="spinner"></div>
                <p>Loading items...</p>
              </div>`;
        }
        
        // First get the currently selected rooms
        google.script.run
          .withSuccessHandler(function(selectedResult) {
            if (!selectedResult.success) {
              hideDashboardLoading();
              if (mainContentContainer) {
                renderUIState(mainContentContainer, 'error', '<strong>Error:</strong> ' + (selectedResult.error || 'Failed to get selected rooms'));
              } else {
                alert('Error: Failed to get selected rooms. Main content area missing.');
              }
              return;
            }
            
            // Keep track of the already selected rooms
            const currentlySelectedRooms = selectedResult.selectedRooms || [];
            
            // If there are no selected rooms yet, simply show the room manager
            if (currentlySelectedRooms.length === 0) {
              hideDashboardLoading(); // Hide global overlay since we are redirecting
              // showRoomManager will handle its own loading state for fileContent
              showRoomManager(); 
              return;
            }
            
            // Keep the same loading state we set earlier - don't change it

            google.script.run
              .withSuccessHandler(function(result) {
                hideDashboardLoading();
                if (mainContentContainer) {
                    if (result.success) {
                        // Don't use renderUIState - just proceed to item update which will replace the content
                        showItemUpdateInDashboard(true); // Pass true to prevent changing the loading message
                    } else {
                        renderUIState(mainContentContainer, 'error', '<strong>Error:</strong> ' + (result.error || 'Failed to load items data'));
                    }
                } else {
                     alert('Error loading items data. Main content area missing.');
                }
              })
              .withFailureHandler(function(error) {
                hideDashboardLoading();
                if (mainContentContainer) {
                    renderUIState(mainContentContainer, 'error', '<strong>Error:</strong> ' + (error.error || error.message || error.toString()));
                } else {
                     alert('Error loading items data. Main content area missing.');
                }
              })
              .getItemUpdateContentForDashboard(sheetId);
          })
          .withFailureHandler(function(error) {
            hideDashboardLoading();
            if (mainContentContainer) {
                renderUIState(mainContentContainer, 'error', '<strong>Error:</strong> ' + (error.error || error.message || error.toString()));
            } else {
                 alert('Error loading items management. Main content area missing.');
            }
          })
          .getSelectedRooms(sheetId);
      }

      // New function to show the item update interface in the dashboard
      function showItemUpdateInDashboard(keepLoadingState = false) {
        // Store the original project name if not already stored
        const projectNameElement = document.getElementById('projectName');
        if (projectNameElement && !window.originalProjectName) {
          window.originalProjectName = projectNameElement.innerText;
        }
        
        // Update the page title
        if (projectNameElement) {
          projectNameElement.innerText = 'Manage Items';
        }
        
        const mainContentContainer = document.getElementById('fileContent');
        
        // Get the sheet ID from the project details modal
        const dialog = document.querySelector('.app-container');
        const sheetId = dialog ? dialog.getAttribute('data-sheet-id') : null;
        
        console.log('showItemUpdateInDashboard: found sheetId:', sheetId);
        
        // Only proceed if we have a sheetId
        if (!sheetId) {
          if (mainContentContainer) {
            renderUIState(mainContentContainer, 'error', '<strong>Error:</strong> No sheet ID found. Unable to load items.');
          }
          return;
        }
        
        // Show global loading overlay (if desired) 
        showDashboardLoading('Loading items data...'); 
        
        // Set loading state for the specific container only if not already set
        if (mainContentContainer && !keepLoadingState) {
            // Use the same consistent loading message
            mainContentContainer.innerHTML = `
              <div class="loading-state">
                <div class="spinner"></div>
                <p>Loading items...</p>
              </div>`;
        }
        
        // Call server to get item data
        google.script.run
          .withSuccessHandler(function(data) {
            hideDashboardLoading(); // Hide global overlay
            if (mainContentContainer) {
                // Don't call renderUIState, just directly replace the content
                renderItemUpdateInterface(data); 
            } else {
                console.error('showItemUpdateInDashboard: fileContent container not found for success handler.');
            }
          })
          .withFailureHandler(function(error) {
            hideDashboardLoading(); // Hide global overlay
            if (mainContentContainer) {
                renderUIState(mainContentContainer, 'error', '<strong>Error:</strong> ' + (error.error || error.message || error.toString()));
            } else {
                console.error('showItemUpdateInDashboard: fileContent container not found for error handler.');
                // Optionally, show a generic alert if main container is missing
                alert('Error loading item data. Main content area missing.');
            }
          })
          .getItemUpdateContentForDashboard(sheetId);
      }
      
      /**
       * Sanitizes a single item object for saving.
       * Ensures quantity, budget values are correct, recalculates totals,
       * and removes temporary properties.
       * @param {object} item - The item object to sanitize.
       * @return {object} The sanitized item object.
       */
      function _sanitizeItemForSave(item) {
        // Create a deep copy to avoid modifying the original
        const sanitizedItem = JSON.parse(JSON.stringify(item));
        
        // Ensure quantity is at least 1
        sanitizedItem.quantity = Math.max(1, parseInt(sanitizedItem.quantity) || 1);
        
        // Convert budget values to numbers or null
        sanitizedItem.lowBudget = sanitizedItem.lowBudget !== null && sanitizedItem.lowBudget !== '' && !isNaN(sanitizedItem.lowBudget) 
          ? parseFloat(sanitizedItem.lowBudget) 
          : null;
          
        sanitizedItem.highBudget = sanitizedItem.highBudget !== null && sanitizedItem.highBudget !== '' && !isNaN(sanitizedItem.highBudget) 
          ? parseFloat(sanitizedItem.highBudget) 
          : null;
        
        // Recalculate totals
        sanitizedItem.lowBudgetTotal = sanitizedItem.lowBudget !== null 
          ? sanitizedItem.lowBudget * sanitizedItem.quantity 
          : null;
          
        sanitizedItem.highBudgetTotal = sanitizedItem.highBudget !== null 
          ? sanitizedItem.highBudget * sanitizedItem.quantity 
          : null;
          
        // Remove temporary properties that shouldn't be saved
        if ('isNew' in sanitizedItem) delete sanitizedItem.isNew;
        if ('id' in sanitizedItem && sanitizedItem.id.toString().startsWith('new_')) delete sanitizedItem.id;
        
        return sanitizedItem;
      }

      /**
       * Prepares the list of all items from dashboardItemData.
       * Rebuilds the main items array from itemsByRoom if necessary,
       * and ensures each item has a 'room' property.
       * @param {object} dashboardItemData - The global dashboard data object.
       * @return {object[]} The prepared array of all item objects.
       */
      function _getAndPrepareDashboardItems(dashboardItemData) {
        let allItems = [];
        let hasItemsWithoutRoom = false; // To track if any fixes were made

        // Check if we need to rebuild the main items array
        if (dashboardItemData.items && dashboardItemData.items.length === 0 && 
            dashboardItemData.itemsByRoom && Object.keys(dashboardItemData.itemsByRoom).length > 0) {
          console.log('Main items array is empty but room items exist - rebuilding');
          Object.keys(dashboardItemData.itemsByRoom).forEach(room => {
            const roomItems = dashboardItemData.itemsByRoom[room];
            if (Array.isArray(roomItems)) {
              roomItems.forEach(item => {
                // Ensure room property is set during rebuild
                if (!item.room) {
                  item.room = room;
                  hasItemsWithoutRoom = true; // Mark that a fix occurred
                }
                allItems.push(item);
              });
            }
          });
          
          if (hasItemsWithoutRoom) {
            console.log('Fixed items missing room property during rebuild');
          }
          // Update the main items array in dashboardItemData as well for consistency
          dashboardItemData.items = allItems;
          console.log('Rebuilt main items array with', allItems.length, 'items');
        } else {
          // If not rebuilding, use the existing items array, but still ensure deep copy for modification safety
          allItems = dashboardItemData.items ? JSON.parse(JSON.stringify(dashboardItemData.items)) : [];
        }

        // Pre-process: ensure all items (whether rebuilt or original) have a valid room property
        // This also catches cases where items might have been added without a room directly to dashboardItemData.items
        let fixedMissingRoomProperty = false;
        allItems.forEach(item => {
          if (!item.room && item._roomName) {
            item.room = item._roomName; // Use backup field if available
            fixedMissingRoomProperty = true;
          }
        });
        if (fixedMissingRoomProperty) {
            console.log('Fixed items with missing room property using _roomName backup.');
        }
        return allItems;
      }

      /**
       * Filters an array of items to include only those valid for saving.
       * A valid item must have a room and a non-empty item name.
       * @param {object[]} items - The array of item objects to filter.
       * @return {object[]} A new array containing only valid items.
       */
      function _filterValidItemsToSave(items) {
        if (!Array.isArray(items)) return [];
        return items.filter(item => {
          const isValid = item && item.room && item.item && item.item.trim() !== '';
          if (!isValid) {
            console.log('Filtering out invalid item during save process:', item);
          }
          return isValid;
        });
      }

      // Save all items data to the server
      function saveAllItemsFromDashboard() {
        console.log('Starting save process for all items');
        console.log('Total items in dashboardItemData:', dashboardItemData.items.length);
        console.log('Room counts:', Object.keys(dashboardItemData.itemsByRoom).map(room => 
          `${room}: ${dashboardItemData.itemsByRoom[room].length}`
        ));
        
        // Get sheetId from the modal if available
        const dialog = document.querySelector('.app-container');
        const sheetId = dialog ? dialog.getAttribute('data-sheet-id') : null;
        console.log('saveAllItemsFromDashboard: found sheetId:', sheetId);
        
        showDashboardLoading('Saving items...');
        
        // Verify data integrity first and prepare items
        const allItems = _getAndPrepareDashboardItems(dashboardItemData);
        
        // Filter out items that don't have valid data
        const itemsToSave = _filterValidItemsToSave(allItems);
        
        console.log('Valid items to save:', itemsToSave.length);
        
        if (itemsToSave.length === 0) {
          hideDashboardLoading();
          showDashboardStatusMessage('No valid items to save. Please add items with names before saving.', true);
          return;
        }
        
        // Make sure all budget values are properly formatted
        const sanitizedItems = itemsToSave.map(item => _sanitizeItemForSave(item));
        
        console.log('Sanitized items ready for saving:', sanitizedItems.length);
        console.log('Sample sanitized item:', sanitizedItems.length > 0 ? sanitizedItems[0] : 'No items');
        
        // Call the server-side function with the sanitized items
        google.script.run
          .withSuccessHandler(function(result) {
            console.log('Server response for save operation:', result);
            hideDashboardLoading();
            
            if (result.success) {
              showDashboardStatusMessage(`Successfully saved ${result.itemCount} items`, false);
              
              // Update any temporary IDs with permanent ones if provided by server
              if (result.items) {
                updateItemIdsAfterSave(result.items);
              }
              
              // Mark all items as no longer new
              dashboardItemData.items.forEach(item => {
                if (item.isNew) item.isNew = false;
              });
            } else {
              console.error('Server reported error:', result.error || 'Unknown error');
              showDashboardStatusMessage('Error: ' + (result.error || 'Failed to save items'), true);
            }
          })
          .withFailureHandler(function(error) {
            console.error('Error during save operation:', error);
            hideDashboardLoading();
            showDashboardStatusMessage('Error: ' + (error.message || error), true);
          })
          .saveItemsFromDashboard(sanitizedItems, sheetId);
      }

      // Load dashboard when page opens
      document.addEventListener('DOMContentLoaded', function() {     
        initializeProjectDetailsSidebarInteractions();
      });

      // Functions for Project_Details_.html
      function loadProjectDetails() {
        // Show loading state
        showLoading(true);
        
        // Get projectId from the existing projectIdHolder element
        const projectIdElement = document.getElementById('projectIdHolder');
        const projectId = projectIdElement ? projectIdElement.getAttribute('data-project-id') : null;
        
        if (!projectId) {
          // If no projectId is available, get all projects and display the first one
          google.script.run
            .withSuccessHandler(function(result) {
              showLoading(false);
              
              if (!result.success) {
                showError(result.error || "Failed to load projects");
                return;
              }
              
              // If no projects found
              if (!result.projects || result.projects.length === 0) {
                showError('No projects found.');
                return;
              }
              
              // Store project data globally for sidebar access
              window.currentProject = result.projects[0];
              
              // Display the first project
              displayProjectDetails(result.projects[0]);
            })
            .withFailureHandler(function(error) {
              showLoading(false);
              showError('Error loading projects: ' + error);
            })
            .getProjects();
        } else {
          // If we have a projectId, get that specific project
          google.script.run
            .withSuccessHandler(function(result) {
              showLoading(false);
              
              if (!result.success) {
                showError(result.error || "Failed to load project");
                return;
              }
              
              // Store project data globally for sidebar access
              window.currentProject = result.project;
              
              // Display the project details
              displayProjectDetails(result.project);
            })
            .withFailureHandler(function(error) {
              showLoading(false);
              showError('Error loading project: ' + error);
            })
            .getProjectById(projectId);
        }
      }

      // Function to preview file content in the main area
      function showFilePreview(file) {
        // Store the original project name if not already stored
        const projectNameElement = document.getElementById('projectName');
        if (projectNameElement && !window.originalProjectName) {
          window.originalProjectName = projectNameElement.innerText;
        }
        
        // Update the page title
        if (projectNameElement) {
          projectNameElement.innerText = file.name;
        }
        
        // Show loading indicator in main content area
        const fileContent = document.getElementById('fileContent');
        renderUIState(fileContent, 'loading', 'Loading preview...');
        
        // Determine the content type
        if (file.embedUrl) {
          // Display the file using an iframe if it has an embed URL
          const iframe = document.createElement('iframe');
          iframe.style.width = '100%';
          iframe.style.height = '100%';
          iframe.style.border = 'none';
          
          iframe.onload = function() {
            renderUIState(fileContent, 'success'); // Clear loading/error
            fileContent.appendChild(iframe); // Add the loaded iframe
          };
          iframe.onerror = function() {
            const errorMessage = 'Unable to load file preview. <a href="' + file.url + '" target="_blank">Open in Google Drive</a> instead.';
            renderUIState(fileContent, 'error', errorMessage);
          };
          
          // Set iframe src after adding onload and error handlers to prevent race conditions
          iframe.src = file.embedUrl;

        } else if (file.thumbnailUrl) {
          // Show thumbnail for images
          renderUIState(fileContent, 'success'); // Clear loading state
          
          const imageContainer = document.createElement('div');
          imageContainer.style.padding = '20px';
          imageContainer.style.textAlign = 'center';
          
          const image = document.createElement('img');
          image.src = file.thumbnailUrl;
          image.style.maxWidth = '100%';
          image.style.maxHeight = '80vh';
          image.style.boxShadow = '0 2px 10px rgba(0,0,0,0.1)';
          
          const caption = document.createElement('p');
          caption.textContent = file.name;
          caption.style.marginTop = '10px';
          
          const openLink = document.createElement('a');
          openLink.href = file.url;
          openLink.target = '_blank';
          openLink.textContent = 'Open in Google Drive';
          openLink.className = 'btn';
          openLink.style.marginTop = '15px';
          openLink.style.display = 'inline-block';
          
          imageContainer.appendChild(image);
          imageContainer.appendChild(caption);
          imageContainer.appendChild(openLink);
          
          fileContent.innerHTML = '';
          fileContent.appendChild(imageContainer);
        } else {
          // Show a message that preview is not available
          renderUIState(fileContent, 'success'); // Clear loading state
          
          const noPreviewDiv = document.createElement('div');
          noPreviewDiv.className = 'empty-state';
          noPreviewDiv.style.padding = '20px';
          
          const noPreviewIcon = document.createElement('i');
          noPreviewIcon.className = 'material-icons';
          noPreviewIcon.textContent = 'visibility_off';
          noPreviewIcon.style.fontSize = '48px';
          noPreviewIcon.style.marginBottom = '15px';
          
          const noPreviewText = document.createElement('p');
          noPreviewText.textContent = 'Preview not available for this file type.';
          
          const openBtn = document.createElement('a');
          openBtn.href = file.url;
          openBtn.target = '_blank';
          openBtn.className = 'btn';
          openBtn.textContent = 'Open in Google Drive';
          openBtn.style.marginTop = '15px';
          openBtn.style.display = 'inline-block';
          
          noPreviewDiv.appendChild(noPreviewIcon);
          noPreviewDiv.appendChild(noPreviewText);
          noPreviewDiv.appendChild(openBtn);
          
          fileContent.appendChild(noPreviewDiv);
        }
      }

      // Function to show dashboard loading overlay
      function showDashboardLoading(message) {
        const loadingOverlay = document.getElementById('dashboardLoadingOverlay');
        const loadingMessage = document.getElementById('dashboardLoadingMessage');
        
        if (loadingMessage) {
          loadingMessage.textContent = message || 'Loading...';
        }
        
        if (loadingOverlay) {
          loadingOverlay.style.display = 'flex';
        }
      }
      
      // Function to hide dashboard loading overlay
      function hideDashboardLoading() {
        const loadingOverlay = document.getElementById('dashboardLoadingOverlay');
        
        if (loadingOverlay) {
          loadingOverlay.style.display = 'none';
        }
      }

      /**
       * Shows a status message in the dashboard.
       * @param {string} message - The message to display
       * @param {boolean} isError - Whether this is an error message
       * @param {string} location - Optional location ('main' or 'sidebar')
       */
      function showDashboardStatusMessage(message, isError = false, location = 'main') {
        // For Google Apps Script dialog context, log message and exit early
        if (typeof google !== 'undefined' && google.script && google.script.host) {
          // We're in a dialog context, just log the message
          console.log(`${isError ? 'ERROR' : 'SUCCESS'}: ${message}`);
          return;
        }
        
        // Hide any existing message after a delay
        if (window.statusMessageTimeout) {
          clearTimeout(window.statusMessageTimeout);
          window.statusMessageTimeout = null;
        }
        
        // Find the appropriate status container based on location
        const statusContainer = (location === 'sidebar') 
          ? document.getElementById('sidebarStatusMessage')
          : document.getElementById('dashboardStatusMessage');
          
        if (!statusContainer) {
          console.error('Status message container not found for location:', location);
          // Fallback to console.log if container is not found
          console.log(`${isError ? 'ERROR' : 'SUCCESS'}: ${message}`);
          return;
        }
        
        // Update message content and style
        statusContainer.textContent = message;
        statusContainer.className = 'status-message ' + (isError ? 'error' : 'success');
        statusContainer.style.display = 'block';
        
        // Auto-hide success messages after 5 seconds
        if (!isError) {
          window.statusMessageTimeout = setTimeout(() => {
            statusContainer.style.display = 'none';
          }, 5000);
        }
      }

      // Additional functions from scripts.js should be added here
      // ...
      
      // Initialize Project Details Page
      function initProjectDetailsPage(projectId) {
        // Get the modal element and check for sheetId
        const dialog = document.querySelector('.app-container');
        const sheetId = dialog ? dialog.getAttribute('data-sheet-id') : null;
        
        if (!sheetId) {
          console.error('Sheet ID not available for project', projectId);
          // Attempt to display error in a general page area if specific containers aren't available
          const errorDisplayArea = document.getElementById('fileContent') || document.body;
          renderUIState(errorDisplayArea, 'error', 'Project spreadsheet ID not available. Unable to load project details.');
          return;
        }
        
        // Setup containers for UI state rendering
        const summaryContainer = document.getElementById('projectSummaryActualContent');
        const roomsContainerParent = document.getElementById('rooms-content'); // Parent of the list
        let roomsListElement = roomsContainerParent ? roomsContainerParent.querySelector('.rooms-list') : null;

        // If roomsListElement doesn't exist, we might need to create it or have a fallback
        // For now, we proceed assuming it can be found or renderRoomsList will handle its absence.

        if (summaryContainer) {
          renderUIState(summaryContainer, 'loading', 'Loading project summary...');
        }
        
        // Load project summary passing the sheet ID
        google.script.run
          .withSuccessHandler(function(result) {
            if (!summaryContainer) return; // Should not happen if initial check passed
            
            if (!result.success) {
              renderUIState(summaryContainer, 'error', 'Error loading project summary: ' + (result.error || 'Unknown error'));
              return;
            }
            
            renderUIState(summaryContainer, 'success'); // Clear loading/error, ready for content
            
            // Update room count, item count, budget totals
            if (result.roomCount !== undefined) {
              const roomCountEl = document.getElementById('roomCount');
              if (roomCountEl) roomCountEl.textContent = result.roomCount;
            }
            
            if (result.itemCount !== undefined) {
              const itemCountEl = document.getElementById('itemCount');
              if (itemCountEl) itemCountEl.textContent = result.itemCount;
            }
            
            if (result.totalLowBudget !== undefined) {
              const lowBudgetEl = document.getElementById('lowBudgetTotal');
              if (lowBudgetEl) lowBudgetEl.textContent = formatCurrency(result.totalLowBudget);
            }
            
            if (result.totalHighBudget !== undefined) {
              const highBudgetEl = document.getElementById('highBudgetTotal');
              if (highBudgetEl) highBudgetEl.textContent = formatCurrency(result.totalHighBudget);
            }
            
            console.log('Project summary loaded successfully', result);
          })
          .withFailureHandler(function(error) {
            if (summaryContainer) {
              renderUIState(summaryContainer, 'error', 'Error loading project summary: ' + error.message || error.toString());
            }
          })
          .getProjectSummary(sheetId);

        // AT THE END of initProjectDetailsPage, call the new sidebar setup function:
        initializeProjectDetailsSidebarInteractions();
      }
      
      // Helper function to format currency
      function formatCurrency(value) {
        if (value === undefined || value === null) return '$0';
        return '$' + parseFloat(value).toLocaleString('en-US', {
          minimumFractionDigits: 0,
          maximumFractionDigits: 0
        });
      }
      
      // Function to render rooms list with checkboxes
      function renderRoomsList(rooms, selectedRooms, container) {
        if (!container) return;
        
        // Clear container (renderUIState will do this for 'empty' or 'success' before content is added)
        // container.innerHTML = ''; // No longer needed if renderUIState is used for empty state
        
        if (!rooms || rooms.length === 0) {
          renderUIState(container, 'empty', 'No rooms available');
          return;
        }

        // If we have rooms, clear any previous state (like 'empty') before adding new content.
        // The 'success' state with no message effectively clears the container.
        renderUIState(container, 'success');
        
        // Create room items
        rooms.forEach(room => {
          const isSelected = selectedRooms.includes(room);
          
          const roomItem = document.createElement('div');
          roomItem.className = 'room-item';
          
          // Create checkbox for room selection
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.id = 'room-' + room.replace(/\s+/g, '-').toLowerCase();
          checkbox.className = 'room-checkbox';
          checkbox.checked = isSelected;
          checkbox.setAttribute('data-room', room);
          
          // Create label for the checkbox
          const label = document.createElement('label');
          label.htmlFor = checkbox.id;
          label.textContent = room;
          
          // Append to room item
          roomItem.appendChild(checkbox);
          roomItem.appendChild(label);
          
          // Append to container
          container.appendChild(roomItem);
        });
        
        // Add save button
        // const saveButton = document.createElement('button');
        // saveButton.className = 'btn room-save-btn';
        // saveButton.innerHTML = '<i class="material-icons">save</i> Save Selection';
        // saveButton.onclick = function() {
        //   saveRoomsSelection(container);
        // };
        
        //container.appendChild(saveButton);
      }
      
      // Function to save selected rooms
      function saveRoomsSelection(container) {
        const containerName = container || document.getElementById('sidebarRoomList');
        const checkboxes = containerName.querySelectorAll('input[type="checkbox"]:checked');
        const selectedRooms = Array.from(checkboxes).map(cb => cb.getAttribute('data-room'));
        
        if (selectedRooms.length === 0) {
          alert('Please select at least one room');
          return;
        }
        
        // Show loading state
        const saveBtn = containerName.querySelector('.room-save-btn');
        if (saveBtn) {
          // Store original HTML, assuming it's <i class="material-icons">save</i> Save Selection
          // This could be made more robust by storing on the element or if it varies.
          const originalButtonHtml = '<i class="material-icons">save</i> Save Selection';
          const loadingButtonHtml = '<i class="material-icons rotating">sync</i> Saving...';
          _setButtonLoadingState(saveBtn, true, loadingButtonHtml, originalButtonHtml);
        }
        
        // Save selected rooms
        google.script.run
          .withSuccessHandler(function(result) {
            if (saveBtn) {
              const originalButtonHtml = '<i class="material-icons">save</i> Save Selection';
              _setButtonLoadingState(saveBtn, false, '', originalButtonHtml);
            }
            
            if (!result.success) {
              alert('Error saving rooms: ' + (result.error || 'Unknown error'));
              return;
            }
            
            alert('Rooms saved successfully');
          })
          .withFailureHandler(function(error) {
            if (saveBtn) {
              const originalButtonHtml = '<i class="material-icons">save</i> Save Selection';
              _setButtonLoadingState(saveBtn, false, '', originalButtonHtml);
            }
            
            alert('Error saving rooms: ' + error);
          })
          .saveSelectedRoomsOnly(selectedRooms);
      }

      // Assuming handleBudgetError function exists or will be created:
      function handleBudgetError(error) {
        const budgetDisplay = document.getElementById('budgetSummaryDisplay');
        if (!budgetDisplay) return;
        let errorMessage = 'Error loading budget data.';
        if (typeof error === 'string') {
          errorMessage = error;
        } else if (error && error.message) {
          errorMessage = error.message;
        } else if (error && error.details) {
          errorMessage = error.details;
        }
        renderUIState(budgetDisplay, 'error', errorMessage);
        console.error('Budget Data Error:', error);
      }

      /**
       * Initializes sidebar interactions (toggle and tabs) specifically for the Project Details modal.
       * This should be called after the Project Details modal content is loaded.
       */
      function initializeProjectDetailsSidebarInteractions() {
        console.log('Initializing Project Details sidebar interactions...');
        const dialog = document.querySelector('.app-container');
        if (!dialog) {
          console.error('Project Details Modal not found. Cannot initialize sidebar interactions.');
          return;
        }

        const sidebar = dialog.querySelector('.sidebar'); // Scope to within the modal
        const sidebarToggle = dialog.querySelector('#sidebarToggle'); // Scope to within the modal

        // Main Sidebar Toggle Logic (scoped to this modal's sidebar)
        if (sidebarToggle && sidebar) {
          // Set initial state of the toggle button based on sidebar collapsed state
          const toggleIcon = sidebarToggle.querySelector('.material-icons');
          if (toggleIcon) {
            // Set correct initial icon based on sidebar state
            if (sidebar.classList.contains('collapsed')) {
              toggleIcon.textContent = 'chevron_right';
              sidebarToggle.classList.add('collapsed');
            } else {
              toggleIcon.textContent = 'chevron_left';
              sidebarToggle.classList.remove('collapsed');
            }
          }
          
          // Set up toggle button click event
          sidebarToggle.addEventListener('click', function() {
            sidebar.classList.toggle('collapsed');
            const toggleIcon = sidebarToggle.querySelector('.material-icons');
            
            if (toggleIcon) {
              if (sidebar.classList.contains('collapsed')) {
                toggleIcon.textContent = 'chevron_right';
                sidebarToggle.classList.add('collapsed');
              } else {
                toggleIcon.textContent = 'chevron_left';
                sidebarToggle.classList.remove('collapsed');
              }
            }
          });
        } else {
          console.warn('Sidebar toggle or sidebar container not found within #projectDetailsModal.');
        }

        // Sidebar Tab Logic using Event Delegation (scoped to this modal's sidebar)
        if (sidebar) {
          const sidebarTabsContainer = sidebar.querySelector('.sidebar-tabs'); // Assuming tabs are within .sidebar-tabs
          if (sidebarTabsContainer) {
            sidebarTabsContainer.addEventListener('click', function(event) {
              const clickedTab = event.target.closest('.sidebar-tab');
              if (!clickedTab) return; // Click was not on a tab or its child

              // Remove active class from all tabs and contents within this modal
              dialog.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
              dialog.querySelectorAll('.sidebar-content').forEach(c => c.classList.remove('active'));
              
              // Add active class to clicked tab
              clickedTab.classList.add('active');
              
              // Show the corresponding content
              const tabName = clickedTab.getAttribute('data-tab');
              const contentElement = dialog.querySelector(`#${tabName}-content`);
              if (contentElement) {
                contentElement.classList.add('active');
                
                // Load specific content based on tab
                if (tabName === 'home') {
                  // Display project details in the home tab sidebar
                  updateHomeSidebarContent();
                  if (typeof showWelcomeScreen === 'function') showWelcomeScreen(); else console.error('showWelcomeScreen function not found');
                } else if (tabName === 'rooms') {
                  if (typeof showRoomManager === 'function') showRoomManager('sidebar'); else console.error('showRoomManager function not found');
                } else if (tabName === 'folders') {
                  if (typeof loadFolders === 'function') loadFolders('sidebar'); else console.error('loadFolders function not found');
                } else if (tabName === 'tasks') {
                  if (typeof loadAsanaTasks === 'function') loadAsanaTasks(); else console.error('loadAsanaTasks function not found');
                } else if (tabName === 'budget') {
                  // Show loading state for budget before fetching
                  const budgetDisplay = document.getElementById('budgetSummaryDisplay');
                  // Small delay to ensure loading state is visible, then loadBudgetData will set its own loading state.
                  setTimeout(() => {
                    if (typeof loadBudgetData === 'function') loadBudgetData();
                    else console.error('loadBudgetData function not found');
                  }, 10);
                } // Add other tab-specific loading functions here if needed
              }
              
              // If sidebar is collapsed, expand it, UNLESS it's the items tab
              if (sidebar.classList.contains('collapsed') && tabName !== 'items') {
                sidebar.classList.remove('collapsed');
                if (sidebarToggle) {
                  const toggleIcon = sidebarToggle.querySelector('.material-icons');
                  if (toggleIcon) toggleIcon.textContent = 'chevron_left';
                  sidebarToggle.classList.remove('collapsed');
                }
              }
            });

            // Initially select the home tab and update its content
            if (sidebar.querySelector('.sidebar-tab[data-tab="home"].active')) {
              updateHomeSidebarContent();
            }
          } else {
            console.warn('.sidebar-tabs container not found within #projectDetailsModal .sidebar');
          }
        } else {
            console.warn('.sidebar container not found within #projectDetailsModal for tab delegation.');
        }
        
        // We'll handle adding the Select Items button when the rooms tab is activated
      }

      /**
       * Updates the home tab sidebar content with project details
       */
      function updateHomeSidebarContent() {
        const dialog = document.querySelector('.app-container');
        if (!dialog) return;

        // Get project data from the modal's data attribute
        const projectId = dialog.getAttribute('data-project-id');
        const sheetId = dialog.getAttribute('data-sheet-id');
        const projectData = window.currentProject;
        
        if (!projectData) {
          console.error('No project data found for home sidebar content');
          
          // Display loading state while we fetch the project data
          const homeSidebarContent = dialog.querySelector('#home-content .sidebar-body');
          if (homeSidebarContent) {
            homeSidebarContent.innerHTML = `
              <div class="loading-state">
                <div class="spinner"></div>
                <p>Loading project information...</p>
              </div>
            `;
          }
          
          if (projectId) {
            // Fetch project data using the project ID
            google.script.run
              .withSuccessHandler(function(response) {
                if (response.success) {
                  window.currentProject = response.project;
                  updateHomeSidebarContent(); // Call again after data is loaded
                } else {
                  if (homeSidebarContent) {
                    homeSidebarContent.innerHTML = `
                      <div class="error-box">
                        <strong>Error:</strong> ${response.error || 'Failed to load project information'}
                      </div>
                    `;
                  }
                }
              })
              .withFailureHandler(function(error) {
                if (homeSidebarContent) {
                  homeSidebarContent.innerHTML = `
                    <div class="error-box">
                      <strong>Error:</strong> ${error.message || error.toString() || 'Failed to load project information'}
                    </div>
                  `;
                }
              })
              .getProjectById(projectId);
          }
          return;
        }

        // Get the sidebar content element for the home tab
        const homeSidebarContent = dialog.querySelector('#home-content .sidebar-body');
        if (!homeSidebarContent) {
          console.error('Home sidebar content element not found');
          return;
        }

        // Clear any existing content to prevent duplicates
        homeSidebarContent.innerHTML = '';

        // Create HTML for the project info section
        const projectInfoHTML = `
          <div id="projectDetailsSummary" class="project-info-section">
            <div class="project-info-item">
              <label>Project Name:</label>
              <div class="info-value">${projectData.name || 'N/A'}</div>
            </div>
            <div class="project-info-item project-address-item">
              <label>Project Address:</label>
              <div class="info-value">${projectData.address || 'N/A'}</div>
            </div>
            <div class="project-info-item">
              <label>Client Name:</label>
              <div class="info-value">${projectData.client || 'N/A'}</div>
            </div>
            <div class="project-info-item">
              <label>Client Email:</label>
              <div class="info-value">
                ${projectData.clientEmail ? `<span class="copyable-email" onclick="copyEmailToClipboard('${projectData.clientEmail}', this)" title="Copy to clipboard">${projectData.clientEmail}</span>` : 'N/A'}
              </div>
            </div>
            <div class="project-info-item">
              <label>Architect Name:</label>
              <div class="info-value">${projectData.architect || 'N/A'}</div>
            </div>
            <div class="project-info-item">
              <label>Architect Email:</label>
              <div class="info-value">
                ${projectData.architectEmail ? `<span class="copyable-email" onclick="copyEmailToClipboard('${projectData.architectEmail}', this)" title="Copy to clipboard">${projectData.architectEmail}</span>` : 'N/A'}
              </div>
            </div>
            <div class="project-info-item">
              <label>Contractor Name:</label>
              <div class="info-value">${projectData.contractor || 'N/A'}</div>
            </div>
            <div class="project-info-item">
              <label>Contractor Email:</label>
              <div class="info-value">
                ${projectData.contractorEmail ? `<span class="copyable-email" onclick="copyEmailToClipboard('${projectData.contractorEmail}', this)" title="Copy to clipboard">${projectData.contractorEmail}</span>` : 'N/A'}
              </div>
            </div>
          </div>
          <div id="projectSummaryContent" style="margin-top: 20px;">
            <!-- Original content will be preserved here -->
            ${homeSidebarContent.querySelector("#projectSummaryContent")?.innerHTML || ''}
          </div>
        `;

        // Update the home sidebar content
        homeSidebarContent.innerHTML = projectInfoHTML;
      }

      /**
       * Copies the given text to the clipboard and provides visual feedback.
       * @param {string} textToCopy - The text to copy.
       * @param {HTMLElement} element - The clicked HTML element for visual feedback.
       */
      function copyEmailToClipboard(textToCopy, element) {
        navigator.clipboard.writeText(textToCopy).then(function() {
          // Success feedback
          const originalText = element.textContent;
          element.textContent = 'Copied!';
          element.classList.add('copied');
          setTimeout(function() {
            element.textContent = originalText;
            element.classList.remove('copied');
          }, 1500); // Revert after 1.5 seconds
        }).catch(function(err) {
          // Error feedback
          console.error('Failed to copy email: ', err);
          const originalText = element.textContent;
          element.textContent = 'Copy Failed'; 
          element.classList.add('copy-failed');
          setTimeout(function() {
            element.textContent = originalText;
            element.classList.remove('copy-failed');
          }, 1500);
        });
      }

      // Function to load room data into the sidebar
      function loadSidebarRoomManager() {
        // // Show a loading indicator in the sidebar room content
        // document.getElementById('sidebarRoomManagerContent').innerHTML = `
        //   <div class="loading">
        //     <i class="material-icons">sync</i> Loading rooms...
        //   </div>
        // `;
        
        // Fallback to no sheetId if not available
        google.script.run
          .withSuccessHandler(function(result) {
            renderSidebarRoomManager(result);
          })
          .withFailureHandler(function(error) {
            document.getElementById('sidebarRoomManagerContent').innerHTML = `
              <div class="error-box" style="margin: 10px;">
                <strong>Error:</strong> ${error.error || error}
              </div>`;
          })
          .getRoomsForDashboard();
      }
      
      // Render the room manager UI in the sidebar
      function renderSidebarRoomManager(result) {
        if (!result || !result.success) {
          const errorMsg = result && result.error ? result.error : 'Failed to load rooms';
          document.getElementById('sidebarRoomManagerContent').innerHTML = `
            <div class="error-box" style="margin: 10px;">
              <strong>Error:</strong> ${errorMsg}
            </div>`;
          return;
        }

        console.log('renderSidebarRoomManager: result:', result);
        
        const rooms = result.rooms || [];
        const selectedRooms = result.selectedRooms || [];
        
        // Reset the content first
        document.getElementById('sidebarRoomManagerContent').innerHTML = `
          <div id="sidebarRoomList" class="room-checklist">
          </div>
          <div id="sidebarStatusMessage" class="status-message" style="display: none;"></div>`;

          // <div class="add-room-container">
          //   <div class="add-room-heading" style="font-weight: 500; margin-bottom: 12px; color: #26717D;">Add New Room</div>
          //   <div style="display: flex; flex-direction: column; gap: 8px;">
          //     <input type="text" id="newRoomNameSidebar" placeholder="Enter room name" style="width: 100%;">
          //     <button onclick="addNewRoomFromSidebar()" class="btn" style="align-self: flex-start;">
          //       <i class="material-icons" style="margin-right: 8px;">add</i> Add Room
          //     </button>
          //   </div>
          // </div>
          // <div id="sidebarStatusMessage" class="status-message" style="display: none;"></div>
          
          // <div id="roomsSavingOverlay" class="saving-overlay" style="display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(255,255,255,0.7); z-index: 100; justify-content: center; align-items: center; flex-direction: column;">
          //   <i class="material-icons rotating" style="font-size: 32px; margin-bottom: 16px; color: #26717D;">sync</i>
          //   <div style="font-weight: 500;">Saving rooms...</div>
          // </div>
        
        // Get the room list container
        const roomListContainer = document.getElementById('sidebarRoomList');
        
        // Check if rooms array is empty
        if (rooms.length === 0) {
          roomListContainer.innerHTML = `
            <div class="empty-state">
              <i class="material-icons">meeting_room</i>
              <p>No rooms found. Add a room below.</p>
            </div>
          `;
        } else {
          // Create room checkboxes
          let roomListHtml = '<div class="room-category-header">Rooms</div>';
          rooms.forEach((room, index) => {
            // Check if this room was previously selected
            const isChecked = selectedRooms.includes(room) ? 'checked' : '';
            
            roomListHtml += `
              <div class="room-checklist-item">
                <input type="checkbox" id="sidebar-room-${index}" data-room="${room}" ${isChecked} class="room-checkbox">
                <label for="sidebar-room-${index}" class="room-checklist-item-label">${room}</label>
              </div>
            `;
          });
          
          roomListContainer.innerHTML = roomListHtml;
          
          // Move Save button outside #sidebarRoomList
          // const saveButton = document.createElement('button');
          // saveButton.className = 'btn room-save-btn';
          // saveButton.innerHTML = '<i class="material-icons">save</i> Save Selection';
          // saveButton.onclick = function() {
          //   saveRoomsSelection(roomListContainer);
          // };
          // // Append the save button as a sibling after #sidebarRoomList
          // if (roomListContainer.parentNode) {
          //   roomListContainer.parentNode.insertBefore(saveButton, roomListContainer.nextSibling);
          // }
        }
      }
      
      // Debounce function to prevent multiple rapid saves
      const debounce = (func, delay) => {
        let debounceTimer;
        return function() {
          const context = this;
          const args = arguments;
          clearTimeout(debounceTimer);
          debounceTimer = setTimeout(() => func.apply(context, args), delay);
        };
      };
      
      // Function to show the saving overlay
      function showRoomsSavingOverlay(show = true) {
        const overlay = document.getElementById('roomsSavingOverlay');
        if (!overlay) return;
        
        overlay.style.display = show ? 'flex' : 'none';
        
        // Disable all checkboxes during save
        const checkboxes = document.querySelectorAll('#sidebarRoomList .room-checkbox');
        checkboxes.forEach(checkbox => {
          checkbox.disabled = show;
        });
      }
      
      // Auto-save function that triggers when checkboxes change
      function autoSaveRooms() {
        // Collect all selected rooms
        const checkboxes = document.querySelectorAll('#sidebarRoomList .room-checkbox');
        const selectedRooms = Array.from(checkboxes)
          .filter(checkbox => checkbox.checked)
          .map(checkbox => checkbox.getAttribute('data-room'));
        
        // Show saving overlay and disable checkboxes
        showRoomsSavingOverlay(true);
        
        // Call server to save selected rooms
        google.script.run
          .withSuccessHandler(function(result) {
            // Hide saving overlay and re-enable checkboxes
            showRoomsSavingOverlay(false);
            
            if (result.success) {
              showSidebarStatusMessage('Rooms saved');
            } else {
              showSidebarStatusMessage('Error: ' + (result.error || 'Failed to save rooms'), true);
                }
              })
              .withFailureHandler(function(error) {
            // Hide saving overlay and re-enable checkboxes
            showRoomsSavingOverlay(false);
            showSidebarStatusMessage('Error: ' + error, true);
          })
          .saveSelectedRoomsOnly(selectedRooms);
      }
      
      // Create a debounced version of autoSaveRooms to prevent saving on every checkbox change
      const debouncedAutoSaveRooms = debounce(autoSaveRooms, 500);

      // Function to add a new room from the sidebar
      function addNewRoomFromSidebar() {
        const newRoomName = document.getElementById('newRoomNameSidebar').value.trim();
        
        if (!newRoomName) {
          showSidebarStatusMessage('Please enter a room name', true);
          return;
        }
        
        // Add loading state to the button
        const addButton = document.querySelector('.add-room-container button');
        const originalButtonHtml = addButton.innerHTML;
        addButton.innerHTML = '<i class="material-icons" style="margin-right: 8px;">sync</i> Adding...';
        addButton.disabled = true;
        
        // Call server to add room
        google.script.run
          .withSuccessHandler(function(result) {
            // Restore button state
            addButton.innerHTML = originalButtonHtml;
            addButton.disabled = false;
            
            if (result.success) {
              showSidebarStatusMessage(`Room "${result.roomName}" added successfully`);
              document.getElementById('newRoomNameSidebar').value = '';
              // Refresh room manager to show the new room
              loadSidebarRoomManager();
            } else {
              showSidebarStatusMessage(result.error || 'Error adding room', true);
            }
          })
          .withFailureHandler(function(error) {
            // Restore button state
            addButton.innerHTML = originalButtonHtml;
            addButton.disabled = false;
            showSidebarStatusMessage(`Error: ${error}`, true);
          })
          .addRoom(newRoomName);
      }

      // Render the item update interface in the dashboard
      function renderItemUpdateInterface(data) {
        if (!data.success) {
          document.getElementById('fileContent').innerHTML = `
            <div class="error-box" style="margin: 20px;">
              <strong>Error:</strong> ${data.error || 'Failed to load item data'}
            </div>`;
          return;
        }
        
        console.log('Data received in renderItemUpdateInterface:', data);
        
        // Store the data for later use
        dashboardItemData = data;
        
        // Check if we have combinedItems property
        if (!dashboardItemData.combinedItems || !Array.isArray(dashboardItemData.combinedItems)) {
          console.warn('combinedItems is missing or not an array, initializing from availableItems');
          
          // Initialize combinedItems from availableItems if needed
          if (dashboardItemData.availableItems && Array.isArray(dashboardItemData.availableItems)) {
            dashboardItemData.combinedItems = dashboardItemData.availableItems.map(item => {
              if (typeof item === 'string') return item;
              return item.type && item.item ? `${item.type} : ${item.item}` : (item.item || '');
            });
            console.log('Created combinedItems with', dashboardItemData.combinedItems.length, 'items');
          } else {
            console.warn('availableItems is also missing or not an array, initializing empty array');
            dashboardItemData.combinedItems = [];
          }
        }
        
        // Create container for all room sections
        const container = document.createElement('div');
        container.className = 'item-update-content';
        container.style.padding = '20px';
        
        // Add help icon with tooltip instead of static instructions
        const helpContainer = document.createElement('div');
        helpContainer.className = 'tooltip';
        helpContainer.style.position = 'absolute';
        helpContainer.style.top = '16px';
        helpContainer.style.right = '16px';
        
        const helpIcon = document.createElement('div');
        helpIcon.className = 'help-icon';
        helpIcon.innerHTML = '?';
        
        const tooltipText = document.createElement('div');
        tooltipText.className = 'tooltip-text';
        tooltipText.innerHTML = '<p>Review and update your items below. Make any necessary changes to the item details, then click Save All Items to update the spreadsheet.</p>';
        
        helpContainer.appendChild(helpIcon);
        helpContainer.appendChild(tooltipText);
        container.appendChild(helpContainer);
        
        // Group items by room first
        const itemsByRoom = {};
        data.selectedRooms.forEach(room => {
          itemsByRoom[room] = data.itemsByRoom[room] || [];
        });
        
        // Create the sticky filter and save button container
        const stickyContainer = document.createElement('div');
        stickyContainer.id = 'sticky-filter-save-container';
        stickyContainer.style.position = 'sticky';
        stickyContainer.style.top = '0';
        stickyContainer.style.backgroundColor = 'white';
        stickyContainer.style.zIndex = '100';
        stickyContainer.style.paddingBottom = '10px';
        stickyContainer.style.display = 'flex';
        stickyContainer.style.justifyContent = 'space-between';
        stickyContainer.style.alignItems = 'center';
        stickyContainer.style.borderBottom = '1px solid rgba(0,0,0,0.1)';
        
        // Add room filter
        const filterContainer = document.createElement('div');
        filterContainer.id = 'filter-container';
        filterContainer.style.display = 'flex';
        filterContainer.style.alignItems = 'center';
        
        const filterLabel = document.createElement('label');
        filterLabel.className = 'filter-label';
        filterLabel.htmlFor = 'room-filter';
        filterLabel.textContent = 'Filter by Room:';
        filterLabel.style.marginRight = '10px';
        
        const roomFilter = document.createElement('select');
        roomFilter.id = 'room-filter';
        roomFilter.style.marginRight = '20px';
        roomFilter.addEventListener('change', filterRoomsInDashboard);
        
        const allRoomsOption = document.createElement('option');
        allRoomsOption.value = 'all';
        allRoomsOption.textContent = 'All Rooms';
        roomFilter.appendChild(allRoomsOption);
        
        filterContainer.appendChild(filterLabel);
        filterContainer.appendChild(roomFilter);
        
        // Create save button for the sticky container
        const saveButton = document.createElement('button');
        saveButton.className = 'btn';
        saveButton.addEventListener('click', saveAllItemsFromDashboard);
        
        const saveIcon = document.createElement('i');
        saveIcon.className = 'material-icons';
        saveIcon.textContent = 'save';
        saveIcon.style.marginRight = '5px';
        
        saveButton.appendChild(saveIcon);
        saveButton.appendChild(document.createTextNode('Save All Items'));
        
        // Then show the room manager in the main content
        showRoomManager();
        
       
        // Create actions container in the sticky header
        const actionsContainer = document.createElement('div');
        actionsContainer.style.display = 'flex';
        actionsContainer.style.gap = '10px';
        actionsContainer.appendChild(saveButton);
        
        // Add filter and actions to sticky container
        stickyContainer.appendChild(filterContainer);
        stickyContainer.appendChild(actionsContainer);
        
        // Add sticky container to main container
        container.appendChild(stickyContainer);
        
        // Populate filter dropdown with rooms
        Object.keys(itemsByRoom).sort().forEach(room => {
          const option = document.createElement('option');
          option.value = room;
          option.textContent = room;
          roomFilter.appendChild(option);
        });
        
        // Create a DocumentFragment to hold all room containers before appending to the main container
        const roomsFragment = document.createDocumentFragment();
        
        // Create room sections
        Object.keys(itemsByRoom).sort().forEach(room => {
          const currentRoomItems = itemsByRoom[room];
          
          // Create room container
          const roomContainer = document.createElement('div');
          roomContainer.className = 'room-container';
          roomContainer.id = `room-container-${room.replace(/\s+/g, '-')}`;
          roomContainer.dataset.room = room;
          
          // Add room title
          const roomTitle = document.createElement('div');
          roomTitle.className = 'room-title';
          roomTitle.textContent = room;
          roomContainer.appendChild(roomTitle);
          
          // Add column headers
          const headers = document.createElement('div');
          headers.className = 'column-headers';
          
          const itemHeader = document.createElement('div');
          itemHeader.className = 'column-header item-header';
          itemHeader.textContent = 'Item';
          
          const typeHeader = document.createElement('div');
          typeHeader.className = 'column-header type-header';
          typeHeader.textContent = 'Type';
          
          const quantityHeader = document.createElement('div');
          quantityHeader.className = 'column-header quantity-header';
          quantityHeader.textContent = 'QTY';
          
          const lowBudgetHeader = document.createElement('div');
          lowBudgetHeader.className = 'column-header budget-header';
          lowBudgetHeader.textContent = 'Low Budget';
          
          const highBudgetHeader = document.createElement('div');
          highBudgetHeader.className = 'column-header budget-header';
          highBudgetHeader.textContent = 'High Budget';
          
          const actionsHeader = document.createElement('div');
          actionsHeader.className = 'column-header actions-header';
          actionsHeader.textContent = 'Remove Item';
          
          headers.appendChild(itemHeader);
          headers.appendChild(typeHeader);
          headers.appendChild(quantityHeader);
          headers.appendChild(lowBudgetHeader);
          headers.appendChild(highBudgetHeader);
          headers.appendChild(actionsHeader);
          
          roomContainer.appendChild(headers);
          
          // Add items container
          const itemsContainer = document.createElement('div');
          itemsContainer.className = 'items-container';
          itemsContainer.id = `items-${room.replace(/\s+/g, '-')}`;
          
          // Use a DocumentFragment for batching item row appends
          const itemsFragment = document.createDocumentFragment();
          // Add each item
          currentRoomItems.forEach((item, index) => {
            const itemRow = createItemRow(item, index, room);
            itemsFragment.appendChild(itemRow);
          });
          itemsContainer.appendChild(itemsFragment); // Append all item rows at once
          
          // Add delegated event listeners to itemsContainer
          itemsContainer.addEventListener('change', function(event) {
            const target = event.target;
            if (target.classList.contains('item-input') ||
                target.classList.contains('type-input') ||
                target.classList.contains('quantity-input') ||
                target.classList.contains('budget-input')) {
              if (target.dataset.room && target.dataset.index !== undefined && target.dataset.field) {
                updateItemData(target.dataset.room, target.dataset.index, target.dataset.field, target.value);
              }
            }
          });

          itemsContainer.addEventListener('input', function(event) {
            const target = event.target;
            if (target.classList.contains('item-input') ||
                target.classList.contains('type-input') ||
                target.classList.contains('quantity-input') ||
                target.classList.contains('budget-input')) {
              if (target.dataset.room && target.dataset.index !== undefined && target.dataset.field) {
                updateItemData(target.dataset.room, target.dataset.index, target.dataset.field, target.value);
              }
            }
          });

          itemsContainer.addEventListener('click', function(event) {
            const target = event.target;
            if (target.classList.contains('delete-button')) {
              if (target.dataset.room && target.dataset.index !== undefined) {
                deleteItemRow(target.dataset.room, target.dataset.index);
              }
            }
          });

          roomContainer.appendChild(itemsContainer);
          
          // // Create the button row for "Add Item" and quick-add buttons
          // const addMoreRow = document.createElement('div');
          // addMoreRow.className = 'add-more-row';
          
          // // Create standard "Add Item" button
          // const addItemButton = document.createElement('button');
          // addItemButton.className = 'add-item-btn';
          // addItemButton.addEventListener('click', function() {
          //   addItemToRoom(room);
          // });
          
          // const buttonIcon = document.createElement('i');
          // buttonIcon.className = 'material-icons';
          // buttonIcon.textContent = 'add';
          
          // addItemButton.appendChild(buttonIcon);
          // addItemButton.appendChild(document.createTextNode(' Add Item'));
          // addMoreRow.appendChild(addItemButton);
          
          // // Add Quick-Add buttons for suggested items
          // const suggestedItems = getSuggestedItemsForRoom(room);
          
          // // Create a container for the quick-add buttons
          // const quickAddContainer = document.createElement('div');
          // quickAddContainer.className = 'quick-add-container';
          
          // // Initialize tracking for visible suggested items if needed
          // if (!dashboardItemData.visibleSuggestedItems) {
          //   dashboardItemData.visibleSuggestedItems = {};
          // }
          
          // // Filter out items that already exist in the room
          // const availableSuggestions = suggestedItems.filter(item => 
          //   !itemExistsInRoom(dashboardItemData.itemsByRoom[room] || [], item)
          // );
          
          // // Initialize with up to 5 available suggestions
          // dashboardItemData.visibleSuggestedItems[room] = availableSuggestions.slice(0, 5);
          
          // // Create buttons for the visible items (max 5)
          // dashboardItemData.visibleSuggestedItems[room].forEach(itemObj => { // itemObj is now an object {name, type?}
          //   const quickAddButton = document.createElement('button');
          //   quickAddButton.className = 'quick-add-btn';
          //   quickAddButton.textContent = `Add ${itemObj.name}`;
            
          //   // Add click handler to add this specific item
          //   quickAddButton.addEventListener('click', function() {
          //     addSpecificItemToRoom(room, itemObj.name, itemObj.type); // Pass name and type
          //   });
            
          //   quickAddContainer.appendChild(quickAddButton);
          // });
          
          // // Only add the container if it has buttons
          // if (quickAddContainer.children.length > 0) {
          //   addMoreRow.appendChild(quickAddContainer);
          // }
          
          // roomContainer.appendChild(addMoreRow);
          
          // Only call updateRoomBudgetDisplay once, after both items container and add button are added
          // updateRoomBudgetDisplay(room); // [DISABLED: Hide room budget summary in UI, keep for future use]
          
          roomsFragment.appendChild(roomContainer); // Append room container to the fragment
        });
        
        container.appendChild(roomsFragment); // Append all room containers at once
        
        // Re-run updateRoomBudgetDisplay for all rooms to ensure proper placement
        // Object.keys(itemsByRoom).sort().forEach(room => {
        //   updateRoomBudgetDisplay(room);
        // }); // [DISABLED: Hide room budget summary in UI, keep for future use]
        
        // Update the content area
        document.getElementById('fileContent').innerHTML = '';
        document.getElementById('fileContent').appendChild(container);
        
        // Add a small delay to ensure all DOM elements are fully rendered before calculating budget summaries
        // setTimeout(() => {
        //   console.log('Applying budget summary updates after DOM render');
        //   Object.keys(itemsByRoom).sort().forEach(room => {
        //     updateRoomBudgetDisplay(room);
        //   });
        // }, 50); // [DISABLED: Hide room budget summary in UI, keep for future use]
      }

      // Function to filter rooms in the dashboard
      function filterRoomsInDashboard() {
        const selectedRoom = document.getElementById('room-filter').value;
        const roomContainers = document.querySelectorAll('.room-container');
        
        roomContainers.forEach(container => {
          if (selectedRoom === 'all' || container.dataset.room === selectedRoom) {
            container.style.display = 'block';
          } else {
            container.style.display = 'none';
          }
        });
      }
      
      // Create an item row
      function createItemRow(item, index, roomName) {
        // Create the main row container
        const row = document.createElement('div');
        row.className = 'item-row';
        row.dataset.index = index;
        row.dataset.room = roomName;
        
        // Item input container with autocomplete
        const itemInputContainer = document.createElement('div');
        itemInputContainer.className = 'item-input-container';
        
        const itemInput = document.createElement('input');
        itemInput.type = 'text';
        itemInput.className = 'item-input';
        itemInput.value = item.item || '';
        itemInput.dataset.field = 'item';
        itemInput.dataset.room = roomName;
        itemInput.dataset.index = index;
        
        // Add focus event to show autocomplete
        itemInput.addEventListener('focus', function() {
          showAutocomplete(this);
        });
        
        // Add keydown event for filtering as user types
        itemInput.addEventListener('input', function() {
          filterAutocompleteItems(this);
        });
        
        // Add keydown event for keyboard navigation
        itemInput.addEventListener('keydown', function(e) {
          handleAutocompleteKeydown(e, this);
        });
        
        // Add blur event to close the autocomplete dropdown when clicking outside
        itemInput.addEventListener('blur', function() {
          // Use a small delay to allow click events on autocomplete items to complete
          setTimeout(() => {
            if (activeAutocompleteInput === this) {
              const autocompleteList = this.parentElement.querySelector('.autocomplete-list');
              if (autocompleteList) {
                autocompleteList.style.display = 'none';
              }
              activeAutocompleteInput = null;
            }
          }, 200);
        });
        
        const autocompleteList = document.createElement('div');
        autocompleteList.className = 'autocomplete-list';
        
        itemInputContainer.appendChild(itemInput);
        itemInputContainer.appendChild(autocompleteList);
        
        // Type input container
        const typeInputContainer = document.createElement('div');
        typeInputContainer.className = 'item-input-container';
        
        // Type input
        const typeInput = document.createElement('input');
        typeInput.type = 'text';
        typeInput.className = 'type-input';
        typeInput.value = item.type || '';
        typeInput.dataset.field = 'type';
        typeInput.dataset.room = roomName;
        typeInput.dataset.index = index;
        
        typeInputContainer.appendChild(typeInput);
        
        // Quantity input
        const quantityInput = document.createElement('input');
        quantityInput.type = 'number';
        quantityInput.className = 'quantity-input';
        quantityInput.value = item.quantity || 1;
        quantityInput.min = '1';
        quantityInput.dataset.field = 'quantity';
        quantityInput.dataset.room = roomName;
        quantityInput.dataset.index = index;
        
        // Low budget input container
        const lowBudgetContainer = document.createElement('div');
        lowBudgetContainer.className = 'budget-input-container';
        
        const lowCurrencySymbol = document.createElement('span');
        lowCurrencySymbol.className = 'currency-symbol';
        lowCurrencySymbol.textContent = '$';
        
        const lowBudgetInput = document.createElement('input');
        lowBudgetInput.type = 'number';
        lowBudgetInput.className = 'budget-input';
        lowBudgetInput.value = item.lowBudget !== null ? item.lowBudget : '';
        lowBudgetInput.min = '0';
        lowBudgetInput.step = '0.01';
        lowBudgetInput.dataset.field = 'lowBudget';
        lowBudgetInput.dataset.room = roomName;
        lowBudgetInput.dataset.index = index;
        lowBudgetInput.placeholder = '0';
        
        lowBudgetContainer.appendChild(lowCurrencySymbol);
        lowBudgetContainer.appendChild(lowBudgetInput);
        
        // High budget input container
        const highBudgetContainer = document.createElement('div');
        highBudgetContainer.className = 'budget-input-container';
        
        const highCurrencySymbol = document.createElement('span');
        highCurrencySymbol.className = 'currency-symbol';
        highCurrencySymbol.textContent = '$';
        
        const highBudgetInput = document.createElement('input');
        highBudgetInput.type = 'number';
        highBudgetInput.className = 'budget-input';
        highBudgetInput.value = item.highBudget !== null ? item.highBudget : '';
        highBudgetInput.min = '0';
        highBudgetInput.step = '0.01';
        highBudgetInput.dataset.field = 'highBudget';
        highBudgetInput.dataset.room = roomName;
        highBudgetInput.dataset.index = index;
        highBudgetInput.placeholder = '0';
        
        highBudgetContainer.appendChild(highCurrencySymbol);
        highBudgetContainer.appendChild(highBudgetInput);
        
        // Delete button container
        const deleteButtonContainer = document.createElement('div');
        deleteButtonContainer.className = 'delete-button-container';
        
        const deleteButton = document.createElement('button');
        deleteButton.className = 'delete-button';
        deleteButton.textContent = '';
        deleteButton.dataset.room = roomName;
        deleteButton.dataset.index = String(index); // For delegated event handler
        // deleteButton.addEventListener('click', function() { // REMOVED
        //   deleteItemRow(roomName, index);
        // });
        
        deleteButtonContainer.appendChild(deleteButton);
        
        // Add all elements to the row
        row.appendChild(itemInputContainer);
        row.appendChild(typeInputContainer);
        row.appendChild(quantityInput);
        row.appendChild(lowBudgetContainer);
        row.appendChild(highBudgetContainer);
        row.appendChild(deleteButtonContainer);
        
        // REMOVED direct event listeners for data updates
        // const inputs = [itemInput, typeInput, quantityInput, lowBudgetInput, highBudgetInput];
        // inputs.forEach(input => {
        //   input.addEventListener('change', function() {
        //     console.log('change event triggered');
        //     updateItemData(this.dataset.room, this.dataset.index, this.dataset.field, this.value);
        //     console.log(this.dataset.room, this.dataset.index, this.dataset.field, this.value);
        //   });
        //   
        //   // Also add input event to capture changes as they type
        //   input.addEventListener('input', function() {
        //     console.log('input event triggered');
        //     updateItemData(this.dataset.room, this.dataset.index, this.dataset.field, this.value);
        //   });
        // });
        
        return row;
      }
      
      // Add a new item to a room
      function addItemToRoom(roomName) {
        // console.log('Adding new item to room:', roomName); // Removed
        const roomItems = dashboardItemData.itemsByRoom[roomName] || [];
        
        // Create new item object with temporary ID
        const newItem = {
          id: 'new_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9), // Temporary unique ID
          room: roomName,
          type: '',
          item: '',
          quantity: 1,
          lowBudget: null,
          highBudget: null,
          lowBudgetTotal: null,
          highBudgetTotal: null,
          isNew: true // Flag to indicate this is a newly added item
        };
        
        // console.log('Creating new item:', newItem); // Removed
        
        // Make sure the room container exists in the data structure
        if (!dashboardItemData.itemsByRoom[roomName]) {
          // console.log('Creating new room array for:', roomName); // Removed
          dashboardItemData.itemsByRoom[roomName] = [];
        }
        
        // Add the new item to the room's items array
        dashboardItemData.itemsByRoom[roomName].push(newItem);
        
        // Make sure it's also added to the main items array
        dashboardItemData.items.push(newItem);
        
        // console.log('Items array after adding new item:', dashboardItemData.items.length); // Removed
        // console.log('Room items after adding:', dashboardItemData.itemsByRoom[roomName].length); // Removed
        
        // Get the container and add the new row
        const container = document.getElementById(`items-${roomName.replace(/\s+/g, '-')}`);
        const newIndex = dashboardItemData.itemsByRoom[roomName].length - 1;
        const newRow = createItemRow(newItem, newIndex, roomName);
        
        // Add new row to the DOM
        container.appendChild(newRow);
        
        // Focus on the new input
        setTimeout(() => {
          const itemInput = newRow.querySelector('.item-input');
          if (itemInput) {
            itemInput.focus();
          }
        }, 100);
        
        // After adding, make sure the room is visible if it was filtered out
        const currentFilter = document.getElementById('room-filter').value;
        if (currentFilter !== 'all' && currentFilter !== roomName) {
          // Switch the filter to the room where we just added an item
          document.getElementById('room-filter').value = roomName;
          filterRoomsInDashboard();
        }
        
        // Update the budget summary row for this room
        updateRoomBudgetDisplay(roomName);
      }
      
      // Delete an item row
      function deleteItemRow(roomName, index) {
        if (confirm('Are you sure you want to delete this item?')) {
          // Remove from data structure
          const roomItems = dashboardItemData.itemsByRoom[roomName] || [];
          if (roomItems[index]) {
            // Find the item in the overall items array
            const itemToRemove = roomItems[index];
            const overallIndex = dashboardItemData.items.findIndex(item => 
              item === itemToRemove || 
              (item.room === roomName && item.item === itemToRemove.item)
            );
            
            if (overallIndex !== -1) {
              dashboardItemData.items.splice(overallIndex, 1);
            }
            
            // Remove from room items
            roomItems.splice(index, 1);
            
            // Refresh the entire room section to update indices
            refreshRoomItemsDisplay(roomName);
            
            // If this was the last item in the room and we're filtering by this room,
            // switch back to "All Rooms" view
            if (roomItems.length === 0) {
              const currentFilter = document.getElementById('room-filter').value;
              if (currentFilter === roomName) {
                document.getElementById('room-filter').value = 'all';
                filterRoomsInDashboard();
              }
            }
            
            // Update the budget summary row for this room
            updateRoomBudgetDisplay(roomName);
            
            // Show status message
            showDashboardStatusMessage('Item deleted successfully');
            
            // Refresh quick-add buttons to show the button for the deleted item if it was in the suggested items
            refreshQuickAddButtons(roomName);
          }
        }
      }
      
      // Refresh the display of all items for a room
      function refreshRoomItemsDisplay(roomName) {
        const roomItems = dashboardItemData.itemsByRoom[roomName] || [];
        const container = document.getElementById(`items-${roomName.replace(/\s+/g, '-')}`);
        
        // Clear the container
        container.innerHTML = '';
        
        // Use a DocumentFragment for batching item row appends
        const itemsFragment = document.createDocumentFragment();
        // Regenerate all item rows
        roomItems.forEach((item, index) => {
          const newRow = createItemRow(item, index, roomName);
          itemsFragment.appendChild(newRow);
        });
        container.appendChild(itemsFragment); // Append all item rows at once
        
        // Update the budget summary for this room
        updateRoomBudgetDisplay(roomName);
      }
      
      // Update item data when inputs change
      function updateItemData(roomName, index, field, value) {
        const idx = parseInt(index);
        const roomItems = dashboardItemData.itemsByRoom[roomName] || [];
        
        if (idx < 0 || idx >= roomItems.length) {
          console.error(`Invalid index: ${idx}. Room ${roomName} items length: ${roomItems.length}`);
          return;
        }
        
        const item = roomItems[idx];
        console.log(`Updating ${field} for item in ${roomName} at index ${idx} to value: ${value}`);
        console.log('Item before update:', JSON.stringify(item));
        
        if (field === 'quantity') {
          item[field] = parseInt(value) || 1;
          
          // Recalculate totals
          if (item.lowBudget !== null && !isNaN(item.lowBudget)) {
            item.lowBudgetTotal = item.lowBudget * item.quantity;
          } else {
            item.lowBudgetTotal = null;
          }
          
          if (item.highBudget !== null && !isNaN(item.highBudget)) {
            item.highBudgetTotal = item.highBudget * item.quantity;
          } else {
            item.highBudgetTotal = null;
          }
        } else if (field === 'lowBudget' || field === 'highBudget') {
          // Handle empty string input (make it null), otherwise parse as float
          item[field] = value === '' ? null : (parseFloat(value) || (parseFloat(value) === 0 ? 0 : null));
          
          // Recalculate totals
          const qty = item.quantity || 1;
          if (field === 'lowBudget') {
            if (item.lowBudget !== null && !isNaN(item.lowBudget)) {
              item.lowBudgetTotal = item.lowBudget * qty;
            } else {
              item.lowBudgetTotal = null;
            }
          } else {
            if (item.highBudget !== null && !isNaN(item.highBudget)) {
              item.highBudgetTotal = item.highBudget * qty;
            } else {
              item.highBudgetTotal = null;
            }
          }
        } else {
          // For 'item' and 'type' fields, convert to uppercase
          if (field === 'item' || field === 'type') {
            item[field] = value.toUpperCase();
          } else {
            // For any other fields (though not expected here for string values other than item/type)
            item[field] = value;
          }
        }
        
        console.log('Item after update:', JSON.stringify(item));
        
        // Find the same item in the main items array and update it too
        const mainIndex = dashboardItemData.items.findIndex(i => 
          i === item || 
          (i.id && item.id && i.id === item.id) ||
          (i.room === roomName && i.item === item.item && i.type === item.type)
        );
        
        if (mainIndex >= 0) {
          console.log(`Updating main items array at index ${mainIndex}`);
          // Update the corresponding fields, not just the one field
          dashboardItemData.items[mainIndex] = { ...item };
        } else {
          console.warn(`Couldn't find item in main items array. Room: ${roomName}, Index: ${idx}, Field: ${field}`);
        }
        
        // Update the budget summary row for this room
        updateRoomBudgetDisplay(roomName);
      }
      
      // Save all items data to the server
      function saveAllItemsFromDashboard() {
        console.log('Starting save process for all items');
        console.log('Total items in dashboardItemData:', dashboardItemData.items.length);
        console.log('Room counts:', Object.keys(dashboardItemData.itemsByRoom).map(room => 
          `${room}: ${dashboardItemData.itemsByRoom[room].length}`
        ));
        
        // Get sheetId from the dialog if available
        const dialog = document.querySelector('.app-container');
        const sheetId = dialog ? dialog.getAttribute('data-sheet-id') : null;
        console.log('saveAllItemsFromDashboard: found sheetId:', sheetId);
        
        showDashboardLoading('Saving items...');
        
        // Verify data integrity first and prepare items
        const allItems = _getAndPrepareDashboardItems(dashboardItemData);
        
        // Filter out items that don't have valid data
        const itemsToSave = _filterValidItemsToSave(allItems);
        
        console.log('Valid items to save:', itemsToSave.length);
        
        if (itemsToSave.length === 0) {
          hideDashboardLoading();
          showDashboardStatusMessage('No valid items to save. Please add items with names before saving.', true);
          return;
        }
        
        // Make sure all budget values are properly formatted
        const sanitizedItems = itemsToSave.map(item => _sanitizeItemForSave(item));
        
        console.log('Sanitized items ready for saving:', sanitizedItems.length);
        console.log('Sample sanitized item:', sanitizedItems.length > 0 ? sanitizedItems[0] : 'No items');
        
        // Call the server-side function with the sanitized items
        google.script.run
          .withSuccessHandler(function(result) {
            console.log('Server response for save operation:', result);
            hideDashboardLoading();
            
            if (result.success) {
              showDashboardStatusMessage(`Successfully saved ${result.itemCount} items`, false);
              
              // Update any temporary IDs with permanent ones if provided by server
              if (result.items) {
                updateItemIdsAfterSave(result.items);
              }
              
              // Mark all items as no longer new
              dashboardItemData.items.forEach(item => {
                if (item.isNew) item.isNew = false;
              });
            } else {
              console.error('Server reported error:', result.error || 'Unknown error');
              showDashboardStatusMessage('Error: ' + (result.error || 'Failed to save items'), true);
            }
          })
          .withFailureHandler(function(error) {
            console.error('Error during save operation:', error);
            hideDashboardLoading();
            showDashboardStatusMessage('Error: ' + (error.message || error), true);
          })
          .saveItemsFromDashboard(sanitizedItems, sheetId);
      }
      
      // Helper function to update item IDs after saving
      function updateItemIdsAfterSave(savedItems) {
        console.log('Updating item IDs after save');
        
        // Flatten the saved items from all rooms
        const allSavedItems = [];
        Object.keys(savedItems).forEach(room => {
          savedItems[room].forEach(item => {
            // Add the room to each item for matching
            allSavedItems.push({...item, room: room});
          });
        });
        
        // Update dashboard items with IDs from saved items
        dashboardItemData.items.forEach((item, index) => {
          if (item.isNew || (item.id && item.id.toString().startsWith('new_'))) {
            // Find the matching saved item
            const savedItem = allSavedItems.find(saved => 
              saved.room === item.room && 
              saved.item === item.item && 
              saved.type === item.type
            );
            
            if (savedItem && savedItem.id) {
              console.log(`Updating item ID: ${item.id || 'none'}  ${savedItem.id}`);
              dashboardItemData.items[index].id = savedItem.id;
              delete dashboardItemData.items[index].isNew;
              
              // Also update in itemsByRoom
              const roomItems = dashboardItemData.itemsByRoom[item.room];
              if (roomItems) {
                const roomIndex = roomItems.findIndex(ri => 
                  (ri.id === item.id) || 
                  (ri.item === item.item && ri.type === item.type)
                );
                if (roomIndex >= 0) {
                  dashboardItemData.itemsByRoom[item.room][roomIndex].id = savedItem.id;
                  delete dashboardItemData.itemsByRoom[item.room][roomIndex].isNew;
                }
              }
            }
          }
        });
      }
      
      // Autocomplete functionality
      let currentFocus = -1;
      let lastActiveInput = null;
      
      // Show autocomplete list
      function showAutocomplete(input) {
        // Close previous autocomplete lists - but not all of them
        if (activeAutocompleteInput && activeAutocompleteInput !== input) {
          // Close only the previous dropdown, not all dropdowns
          const prevList = activeAutocompleteInput.parentElement.querySelector('.autocomplete-list');
          if (prevList) {
            prevList.style.display = 'none';
          }
        }
        
        const autocompleteList = input.parentElement.querySelector('.autocomplete-list');
        lastActiveInput = input;
        
        // Track this as the active autocomplete input
        activeAutocompleteInput = input;
        
        // Reset focus
        currentFocus = -1;
        
        // Show all available items initially
        let listHtml = '';
        console.log('Combined items:', dashboardItemData.combinedItems);
        dashboardItemData.combinedItems.forEach((item, index) => {
          listHtml += `<div class="autocomplete-item" data-index="${index}" data-value="${escapeHtml(item)}">${item}</div>`;
        });
        
        autocompleteList.innerHTML = listHtml;
        autocompleteList.style.display = 'block';
        
        // Add click listeners
        addClickListenersToItems(autocompleteList);
      }
      
      // Filter autocomplete items based on input
      function filterAutocompleteItems(input) {
        const value = input.value.toLowerCase();
        const autocompleteList = input.parentElement.querySelector('.autocomplete-list');
        
        // Reset focus
        currentFocus = -1;
        
        // Show all items if input is empty
        if (value === '') {
          let listHtml = '';
          dashboardItemData.combinedItems.forEach((item, index) => {
            listHtml += `<div class="autocomplete-item" data-index="${index}" data-value="${escapeHtml(item)}">${item}</div>`;
          });
          
          autocompleteList.innerHTML = listHtml;
          autocompleteList.style.display = 'block';
        } else {
          // Filter available items that match the input
          const filteredItems = dashboardItemData.combinedItems.filter(item => 
            item.toLowerCase().includes(value)
          );
          
          // Generate HTML for autocomplete list
          let listHtml = '';
          filteredItems.forEach((item, index) => {
            listHtml += `<div class="autocomplete-item" data-index="${index}" data-value="${escapeHtml(item)}">${item}</div>`;
          });
          
          autocompleteList.innerHTML = listHtml;
          autocompleteList.style.display = filteredItems.length > 0 ? 'block' : 'none';
        }
        
        // Add click listeners to all items
        addClickListenersToItems(autocompleteList);
      }
      
      // Handle keyboard navigation in autocomplete
      function handleAutocompleteKeydown(e, input) {
        const autocompleteList = input.parentElement.querySelector('.autocomplete-list');
        const items = autocompleteList.getElementsByClassName('autocomplete-item');
        
        if (items.length === 0) return;
        
        // Down arrow
        if (e.key === 'ArrowDown') {
          currentFocus++;
          // Wrap around if at the end
          if (currentFocus >= items.length) currentFocus = 0;
          setActiveItem(items);
          e.preventDefault();
        }
        // Up arrow
        else if (e.key === 'ArrowUp') {
          currentFocus--;
          // Wrap around if at the beginning
          if (currentFocus < 0) currentFocus = items.length - 1;
          setActiveItem(items);
          e.preventDefault();
        }
        // Enter key
        else if (e.key === 'Enter') {
          e.preventDefault();
          if (currentFocus > -1) {
            // Click the active item
            items[currentFocus].click();
          }
        }
        // Escape key
        else if (e.key === 'Escape') {
          closeAllAutocompletes();
        }
      }
      
      // Set the active item in the list
      function setActiveItem(items) {
        // Remove active class from all items
        Array.from(items).forEach(item => {
          item.classList.remove('autocomplete-active');
        });
        
        // Add active class to the current focus item
        if (currentFocus >= 0 && currentFocus < items.length) {
          items[currentFocus].classList.add('autocomplete-active');
          
          // Ensure the active item is visible (scroll to it if needed)
          items[currentFocus].scrollIntoView({ block: 'nearest' });
        }
      }
      
      // Add click listeners to autocomplete items
      function addClickListenersToItems(autocompleteList) {
        const items = autocompleteList.getElementsByClassName('autocomplete-item');
        Array.from(items).forEach(item => {
          // Use mousedown to prevent blur from firing first
          item.addEventListener('mousedown', function(e) {
            // Prevent default to avoid input blur
            e.preventDefault();
          });
          
          item.addEventListener('click', function(e) {
            // Select the item
            selectAutocompleteItem(this);
            
            // Focus back on the input after selection
            if (lastActiveInput) {
              lastActiveInput.focus();
            }
          });
        });
      }
      
      // Handle item selection from autocomplete
      function selectAutocompleteItem(selectedItem) {
        if (!lastActiveInput) return;
        
        const value = selectedItem.getAttribute('data-value');
        
        // Extract room and index from input attributes
        const roomName = lastActiveInput.getAttribute('data-room');
        const index = lastActiveInput.getAttribute('data-index');
        
        // Extract item parts (type and name) from combined format
        const parts = value.split(' : ');
        
        // Update the input field with just the item name
        lastActiveInput.value = parts.length > 1 ? parts[1] : value;
        
        // If we have a type, set it in the type field
        if (parts.length > 1) {
          const typeInput = document.querySelector(`.type-input[data-room="${roomName}"][data-index="${index}"]`);
          if (typeInput) {
            typeInput.value = parts[0];
          }
          
          // Update data
          updateItemData(roomName, index, 'item', parts[1]);
          updateItemData(roomName, index, 'type', parts[0]);
        } else {
          // Update just the item
          updateItemData(roomName, index, 'item', value);
        }
        
        // Close all autocomplete lists
        closeAllAutocompletes();
      }
      
      // Close all autocomplete lists
      function closeAllAutocompletes() {
        // Hide all autocomplete lists
        const lists = document.getElementsByClassName('autocomplete-list');
        Array.from(lists).forEach(list => {
          list.style.display = 'none';
        });
      }

      function displayBudgetSummary(data) {
        // Defensive: ensure the element exists before setting innerHTML
        var budgetSummaryContainer = document.getElementById('budgetSummaryDisplay');
        if (!budgetSummaryContainer) {
          console.warn('budgetSummaryDisplay not found in displayBudgetSummary');
          return;
        }
        
        // Check if we have valid data
        if (!data) {
          handleBudgetError('No budget data received');
          return;
        }
        
        console.log('Budget data received:', data);
        
        // Check if there was an error in the response
        if (data.error) {
          handleBudgetError(data.error);
          return;
        }
        
        // Check for required properties
        if (!data.summary || !data.rooms) {
          handleBudgetError('Incomplete budget data: missing summary or rooms information');
          return;
        }
        
        // Budget Summary Box
        const summaryHtml = `
          <div class="budget-summary-box">
            <div class="budget-summary-row">
              <div class="budget-label">Low Budget Total:</div>
              <div class="budget-value">$${formatCurrency(data.summary.totalLowBudget)}</div>
            </div>
            <div class="budget-summary-row">
              <div class="budget-label">High Budget Total:</div>
              <div class="budget-value">$${formatCurrency(data.summary.totalHighBudget)}</div>
            </div>
                    </div>
                  `;
        
        // Room Cards for Sidebar with section header
        let roomCardsHtml = `
          <div class="budget-section-header">
            <h3>Budget by Room</h3>
          </div>
        `;
        
        // Check if we have rooms to display
        if (data.rooms.length === 0) {
          roomCardsHtml += `
            <div class="empty-state">
              <i class="material-icons">info_outline</i>
              <p>No room budget data available</p>
            </div>
          `;
        } else {
          data.rooms.forEach(room => {
            roomCardsHtml += `
              <div class="budget-card">
                <div class="budget-header">
                  <div class="room-name">
                    ${room.name}
                  </div>
                </div>
                <div class="budget-metrics">
                  <div>Low: $${formatCurrency(room.lowBudget)}</div>
                  <div>High: $${formatCurrency(room.highBudget)}</div>
                </div>
              </div>
            `;
          });
        }
        
        // Calculate budget by item type
        const typeData = {};
        let typeCardsHtml = `
          <div class="budget-section-header">
            <h3>Budget by Item Type</h3>
          </div>
        `;
        
        // Process all items across all rooms to group by type
        if (data.rooms && data.rooms.length > 0) {
          data.rooms.forEach(room => {
            if (room.items && Array.isArray(room.items)) {
              room.items.forEach(item => {
                const itemType = item.type ? item.type.trim() : 'Uncategorized';
                
                if (!typeData[itemType]) {
                  typeData[itemType] = {
                    name: itemType,
                    lowBudget: 0,
                    highBudget: 0
                  };
                }
                
                typeData[itemType].lowBudget += item.lowTotal || 0;
                typeData[itemType].highBudget += item.highTotal || 0;
              });
            }
          });
          
          // Convert to array and sort by high budget (highest first)
          const typeArray = Object.values(typeData).sort((a, b) => b.highBudget - a.highBudget);
          
          if (typeArray.length === 0) {
            typeCardsHtml += `
              <div class="empty-state">
                <i class="material-icons">info_outline</i>
                <p>No item type data available</p>
              </div>
            `;
          } else {
            typeArray.forEach(type => {
              typeCardsHtml += `
                <div class="budget-card">
                  <div class="budget-header">
                    <div class="type-name">
                      ${type.name}
                    </div>
                  </div>
                  <div class="budget-metrics">
                    <div>Low: $${formatCurrency(type.lowBudget)}</div>
                    <div>High: $${formatCurrency(type.highBudget)}</div>
                  </div>
                </div>
              `;
            });
          }
        } else {
          typeCardsHtml += `
            <div class="empty-state">
              <i class="material-icons">info_outline</i>
              <p>No item type data available</p>
            </div>
          `;
        }
        
        // Combine all sections
        budgetSummaryContainer.innerHTML = `
          <style>
            .budget-section-header {
              margin-top: 20px;
              margin-bottom: 10px;
              border-bottom: 1px solid rgba(0,0,0,0.1);
              padding-bottom: 5px;
            }
            .budget-section-header h3 {
              font-size: 16px;
              font-weight: 500;
              color: #333;
              margin: 0;
            }
            .budget-card {
              margin-bottom: 8px;
            }
          </style>
          ${summaryHtml}
          ${roomCardsHtml}
          ${typeCardsHtml}
        `;
      }
      
      // Helper function to escape HTML content
      function escapeHtml(str) {
        if (!str) return '';
        return str
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
      }

      // Function to show status message in the sidebar
      function showSidebarStatusMessage(message, isError = false) {
        const statusDiv = document.getElementById('sidebarStatusMessage');
        if (!statusDiv) {
          console.error('Sidebar status message container not found');
          return;
        }

        // Clear any existing classes first
        statusDiv.className = 'status-message';
        
        // Add appropriate styling based on message type
        if (isError) {
          statusDiv.classList.add('error');
        } else {
          statusDiv.classList.add('success');
        }
        
        // Set message content
        statusDiv.textContent = message;
        statusDiv.style.display = 'block';
        
        // Auto-hide the message after 5 seconds
        setTimeout(() => {
          statusDiv.style.display = 'none';
        }, 5000);
      }
      
      /**
       * Calculates the total low and high budget for a room's items.
       * @param {Array} roomItems - The array of items in the room.
       * @return {Object} Object with lowTotal and highTotal properties.
       */
      function calculateRoomBudgetTotals(roomItems) {
        let lowTotal = 0;
        let highTotal = 0;
        
        if (!roomItems || !Array.isArray(roomItems)) {
          return { lowTotal, highTotal };
        }
        
        roomItems.forEach(item => {
          if (item.lowBudgetTotal !== null && !isNaN(item.lowBudgetTotal)) {
            lowTotal += parseFloat(item.lowBudgetTotal);
          }
          
          if (item.highBudgetTotal !== null && !isNaN(item.highBudgetTotal)) {
            highTotal += parseFloat(item.highBudgetTotal);
          }
        });
        
        return { lowTotal, highTotal };
      }
      
      // Helper function for consistent currency formatting
      function formatCurrency(value) {
        if (value === undefined || value === null) return '0';
        return parseFloat(value).toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
      }

      /**
       * Updates the budget summary row for a specific room
       * @param {string} roomName - The name of the room to update the budget summary for
       */
      function updateRoomBudgetDisplay(roomName) {
        // Get the room container
        const roomContainer = document.getElementById(`room-container-${roomName.replace(/\s+/g, '-')}`);
        if (!roomContainer) {
          console.warn(`Room container not found for ${roomName}`);
          return;
        }
        
        // Get the current room items
        const roomItems = dashboardItemData.itemsByRoom[roomName] || [];
        
        // Calculate updated budget totals
        const roomTotals = calculateRoomBudgetTotals(roomItems);
        
        // Find the add-more-row element to ensure proper placement
        const addMoreRow = roomContainer.querySelector('.add-more-row');
        if (!addMoreRow) {
          console.warn(`Add-more-row not found for ${roomName}, cannot place budget summary`);
          return;
        }
        
        // Remove any existing budget summary rows to avoid duplicates
        const existingBudgetRows = roomContainer.querySelectorAll('.room-budget-summary');
        existingBudgetRows.forEach(row => row.remove());
        
        // Create a new budget summary row
        const budgetSummaryRow = document.createElement('div');
        budgetSummaryRow.className = 'room-budget-summary';
        budgetSummaryRow.style.display = 'flex';
        budgetSummaryRow.style.justifyContent = 'flex-end';
        budgetSummaryRow.style.padding = '10px 12px';
        budgetSummaryRow.style.borderTop = '1px solid rgba(38, 113, 125, 0.2)';
        budgetSummaryRow.style.marginTop = '10px';
        budgetSummaryRow.style.fontWeight = '500';
        
        // Insert after the add-more-row
        if (addMoreRow.nextSibling) {
          roomContainer.insertBefore(budgetSummaryRow, addMoreRow.nextSibling);
        } else {
          roomContainer.appendChild(budgetSummaryRow);
        }
        
        // Update the budget summary content
        budgetSummaryRow.innerHTML = `
          <div style="margin-right: 50px;">Room Totals:</div>
          <div style="width: 130px; text-align: right;">$${formatCurrency(roomTotals.lowTotal)}</div>
          <div style="width: 130px; text-align: right;">$${formatCurrency(roomTotals.highTotal)}</div>
          <div style="width: 100px;"></div>
        `;
      }

      function displayProjectDetails(project) {
        // Add code here to display project details in the main content area
        const projectNameElement = document.getElementById('projectName');
        if (projectNameElement) {
          projectNameElement.textContent = project.name || 'Project Details';
        }
        
        // Set project data attributes on the dialog for use in other functions
        const dialog = document.querySelector('.app-container');
        if (dialog) {
          dialog.setAttribute('data-project-id', project.id);
          dialog.setAttribute('data-sheet-id', project.sheetId || '');
          
          // Update home sidebar with project details
          updateHomeSidebarContent();
        }
        
        // Your existing code to display project details...
      }

      // Add after the global variables at the top of the file
      // Define room-specific suggested items
      function getSuggestedItemsForRoom(roomName) {
        const roomLower = roomName.toLowerCase();
        const suggestedItems = {
          'living room': [
            { name: 'Sofa' }, { name: 'Coffee Table' }, { name: 'Side Table' }, { name: 'Rug' }, 
            { name: 'TV Console' }, { name: 'Armchair' }, { name: 'Floor Lamp', type: 'Lighting' }
          ],
          'dining room': [
            { name: 'Dining Table', type: 'Tables' }, { name: 'Dining Chairs', type: 'FURNITURE - SOFT GOODS' }, { name: 'Buffet', type: 'Furniture - Soft Goods' },
            { name: 'Chandelier', type: 'Lighting' }, { name: 'Rug', type: 'Decor - Soft Goods' }, { name: 'Framed Art', type: 'Other Decor' }
          ],
          'kitchen': [
            { name: 'Bar Stools' }, { name: 'Pendant Lights', type: 'Lighting' }, { name: 'Kitchen Island' }, 
            { name: 'Rack' }, { name: 'Storage Container' }
          ],
          'bedroom': [
            { name: 'Bed' }, { name: 'Nightstand' }, { name: 'Dresser' }, { name: 'Armoire' }, 
            { name: 'Bench' }, { name: 'Table Lamp', type: 'Lighting' }, { name: 'Rug' }
          ],
          'bathroom': [
            { name: 'Mirror' }, { name: 'Vanity' }, { name: 'Shower Curtain' }, { name: 'Bath Mat' }, 
            { name: 'Storage Cabinet' }
          ],
          'office': [
            { name: 'Desk' }, { name: 'Office Chair' }, { name: 'Bookshelf' }, 
            { name: 'Desk Lamp', type: 'Lighting' }, { name: 'Filing Cabinet' }
          ],
          'entryway': [
            { name: 'Console Table' }, { name: 'Mirror' }, { name: 'Bench' }, { name: 'Coat Rack' }, { name: 'Rug' }
          ],
          'hallway': [
            { name: 'Runner Rug' }, { name: 'Console Table' }, { name: 'Wall Sconce', type: 'Lighting' }
          ],
          'guest room': [
            { name: 'Bed' }, { name: 'Nightstand' }, { name: 'Dresser' }, { name: 'Mirror' }, { name: 'Luggage Rack' }
          ],
          'nursery': [
            { name: 'Crib' }, { name: 'Changing Table' }, { name: 'Rocking Chair' }, { name: 'Dresser' }, { name: 'Rug' }
          ],
          'playroom': [
            { name: 'Storage Unit' }, { name: 'Play Table' }, { name: 'Rug' }, { name: 'Bookshelf' }, { name: 'Seating' }
          ],
          'mudroom': [
            { name: 'Bench' }, { name: 'Coat Hooks' }, { name: 'Storage Baskets' }, { name: 'Shoe Rack' }
          ]
        };
        
        // Check for exact room matches first
        if (suggestedItems[roomLower]) {
          return suggestedItems[roomLower];
        }
        
        // If no exact match, check if the room name contains any of the keys
        for (const key in suggestedItems) {
          if (roomLower.includes(key)) {
            return suggestedItems[key];
          }
        }
        
        // Return empty array if no match found (no default suggestions)
        return [];
      }

      /**
       * Checks if an item already exists in the room items list
       * @param {Array} roomItems - The items in the room
       * @param {string} itemName - The name of the item to check
       * @returns {boolean} - True if the item already exists
       */
      function itemExistsInRoom(roomItems, suggestedItemObject) {
        if (!roomItems || !Array.isArray(roomItems)) return false;
        
        return roomItems.some(roomItem => {
          // Case-insensitive comparison
          return roomItem.item && roomItem.item.toLowerCase() === suggestedItemObject.name.toLowerCase();
        });
      }

      /**
       * Adds a specific named item to a room
       * @param {string} roomName - The name of the room to add the item to
       * @param {string} itemName - The name of the item to add
       */
      function addSpecificItemToRoom(roomName, itemName, itemType = '') {
        // Get current room items
        const roomItems = dashboardItemData.itemsByRoom[roomName] || [];
        
        // Create new item object with temporary ID and the specified item name
        const newItem = {
          id: 'new_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9), // Temporary unique ID
          room: roomName,
          type: itemType ? itemType.toUpperCase() : '', // Convert to uppercase, ensure empty string if no type
          item: itemName.toUpperCase(),             // Convert item name to uppercase
          quantity: 1,
          lowBudget: null,
          highBudget: null,
          lowBudgetTotal: null,
          highBudgetTotal: null,
          isNew: true // Flag to indicate this is a newly added item
        };
        
        // Make sure the room container exists in the data structure
        if (!dashboardItemData.itemsByRoom[roomName]) {
          dashboardItemData.itemsByRoom[roomName] = [];
        }
        
        // Add the new item to the room's items array
        dashboardItemData.itemsByRoom[roomName].push(newItem);
        
        // Make sure it's also added to the main items array
        dashboardItemData.items.push(newItem);
        
        // Get the container and add the new row
        const container = document.getElementById(`items-${roomName.replace(/\s+/g, '-')}`);
        const newIndex = dashboardItemData.itemsByRoom[roomName].length - 1;
        const newRow = createItemRow(newItem, newIndex, roomName);
        
        // Add new row to the DOM
        container.appendChild(newRow);
        
        // Focus on the type input since the item name is already set
        setTimeout(() => {
          const typeInput = newRow.querySelector('.type-input');
          if (typeInput) {
            typeInput.focus();
          }
        }, 100);
        
        // After adding, make sure the room is visible if it was filtered out
        const currentFilter = document.getElementById('room-filter').value;
        if (currentFilter !== 'all' && currentFilter !== roomName) {
          // Switch the filter to the room where we just added an item
          document.getElementById('room-filter').value = roomName;
          filterRoomsInDashboard();
        }
        
        // Update the budget summary row for this room
        updateRoomBudgetDisplay(roomName);
        
        // Refresh the quick-add buttons to remove the one we just added
        refreshQuickAddButtons(roomName);
      }

      /**
       * Refreshes the quick-add buttons for a room to remove buttons for items that now exist
       * @param {string} roomName - The name of the room to refresh buttons for
       */
      function refreshQuickAddButtons(roomName) {
        const roomContainer = document.getElementById(`room-container-${roomName.replace(/\s+/g, '-')}`);
        if (!roomContainer) return;
        
        const addMoreRow = roomContainer.querySelector('.add-more-row');
        if (!addMoreRow) return;
        
        // Remove existing quick-add container
        const existingContainer = addMoreRow.querySelector('.quick-add-container');
        if (existingContainer) {
          existingContainer.remove();
        }
        
        // Get all suggested items for this room
        const allSuggestedItems = getSuggestedItemsForRoom(roomName);
        const roomItems = dashboardItemData.itemsByRoom[roomName] || [];
        
        // Filter out items that already exist in the room
        const availableSuggestions = allSuggestedItems.filter(item => 
          !itemExistsInRoom(roomItems, item)
        );
        
        // Initialize visible items tracking if needed
        if (!dashboardItemData.visibleSuggestedItems) {
          dashboardItemData.visibleSuggestedItems = {};
        }
        
        // If we don't have a list for this room or the list is empty, initialize it
        if (!dashboardItemData.visibleSuggestedItems[roomName] || 
            dashboardItemData.visibleSuggestedItems[roomName].length === 0) {
          // Start with up to 5 items
          dashboardItemData.visibleSuggestedItems[roomName] = availableSuggestions.slice(0, 5);
        } else {
          // Filter out any items that are no longer available
          dashboardItemData.visibleSuggestedItems[roomName] = 
            dashboardItemData.visibleSuggestedItems[roomName].filter(item => 
              availableSuggestions.includes(item)
            );
          
          // If we have less than 5 items, add more from available suggestions
          if (dashboardItemData.visibleSuggestedItems[roomName].length < 5) {
            // Find items that are available but not currently visible
            const additionalSuggestions = availableSuggestions.filter(item => 
              !dashboardItemData.visibleSuggestedItems[roomName].includes(item)
            );
            
            // Add as many as needed to get to 5 (or as many as are available)
            const neededCount = 5 - dashboardItemData.visibleSuggestedItems[roomName].length;
            const itemsToAdd = additionalSuggestions.slice(0, neededCount);
            
            // Add them to the visible items
            dashboardItemData.visibleSuggestedItems[roomName] = 
              dashboardItemData.visibleSuggestedItems[roomName].concat(itemsToAdd);
          }
        }
        
        // Create a new container
        const quickAddContainer = document.createElement('div');
        quickAddContainer.className = 'quick-add-container';
        
        // Create buttons for all visible items (max 5)
        dashboardItemData.visibleSuggestedItems[roomName].forEach(itemObj => { // itemObj is now an object {name, type?}
          const quickAddButton = document.createElement('button');
          quickAddButton.className = 'quick-add-btn';
          quickAddButton.textContent = `Add ${itemObj.name}`;
          
          // Add click handler
          quickAddButton.addEventListener('click', function() {
            addSpecificItemToRoom(roomName, itemObj.name, itemObj.type); // Pass name and type
          });
          
          quickAddContainer.appendChild(quickAddButton);
        });
        
        // Only add the container if it has buttons
        if (quickAddContainer.children.length > 0) {
          addMoreRow.appendChild(quickAddContainer);
        }
      }

      /**
       * Renders the item selection interface in the dashboard without budget fields
       * and adds checkboxes for selecting items to add to the sheet.
       * @param {Object} data - The data to populate the interface with.
       */
      function renderItemSelectionInterface(data) {
        
        if (!data.success) {
          document.getElementById('fileContent').innerHTML = `
            <div class="error-box" style="margin: 20px;">
              <strong>Error:</strong> ${data.error || 'Failed to load item data'}
            </div>`;
          return;
        }
        console.log('renderItemSelectionInterface called with:', data);
        console.log('itemsByRoom:', data.itemsByRoom);
        console.log('Data received in renderItemSelectionInterface:', data);
        
        // Store the data for later use
        dashboardItemSelectionData = data;
        
        // Check if we have combinedItems property
        if (!dashboardItemSelectionData.combinedItems || !Array.isArray(dashboardItemSelectionData.combinedItems)) {
          console.warn('combinedItems is missing or not an array, initializing from availableItems');
          
          // Initialize combinedItems from availableItems if needed
          if (dashboardItemSelectionData.availableItems && Array.isArray(dashboardItemSelectionData.availableItems)) {
            dashboardItemSelectionData.combinedItems = dashboardItemSelectionData.availableItems.map(item => {
              if (typeof item === 'string') return item;
              return item.type && item.item ? `${item.type} : ${item.item}` : (item.item || '');
            });
            console.log('Created combinedItems with', dashboardItemSelectionData.combinedItems.length, 'items');
          } else {
            console.warn('availableItems is also missing or not an array, initializing empty array');
            dashboardItemSelectionData.combinedItems = [];
          }
        }
        
        // Create container for all room sections
        const container = document.createElement('div');
        container.className = 'item-selection-content';
        container.style.padding = '0 20px';
        
        // Add help icon with tooltip instead of static instructions
        const helpContainer = document.createElement('div');
        helpContainer.className = 'tooltip';
        helpContainer.style.position = 'absolute';
        helpContainer.style.top = '16px';
        helpContainer.style.right = '16px';
        
        const helpIcon = document.createElement('div');
        helpIcon.className = 'help-icon';
        helpIcon.innerHTML = '?';
        
        const tooltipText = document.createElement('div');
        tooltipText.className = 'tooltip-text';
        tooltipText.innerHTML = '<p>Select items to add to your project. Check the boxes for items you want to include, then click Save Selected Items to add them to the spreadsheet.</p>';
        
        helpContainer.appendChild(helpIcon);
        helpContainer.appendChild(tooltipText);
        container.appendChild(helpContainer);
        
        // Group items by room first
        const itemsByRoom = {};
        data.selectedRooms.forEach(room => {
          itemsByRoom[room] = data.itemsByRoom[room] || [];
        });
        
        // Create the sticky filter and save button container
        const stickyContainer = document.createElement('div');
        stickyContainer.id = 'sticky-filter-save-container';
        stickyContainer.style.position = 'sticky';
        stickyContainer.style.top = '0';
        stickyContainer.style.backgroundColor = 'white';
        stickyContainer.style.zIndex = '100';
        stickyContainer.style.padding = '10px 0';
        stickyContainer.style.display = 'flex';
        stickyContainer.style.justifyContent = 'space-between';
        stickyContainer.style.alignItems = 'center';
        stickyContainer.style.borderBottom = '1px solid rgba(0,0,0,0.1)';
        
        // Add room filter
        const filterContainer = document.createElement('div');
        filterContainer.id = 'filter-container';
        filterContainer.style.display = 'flex';
        filterContainer.style.alignItems = 'center';
        
        const filterLabel = document.createElement('label');
        filterLabel.className = 'filter-label';
        filterLabel.htmlFor = 'room-filter';
        filterLabel.textContent = 'Filter by Room:';
        filterLabel.style.marginRight = '10px';
        
        const roomFilter = document.createElement('select');
        roomFilter.id = 'room-filter';
        roomFilter.style.marginRight = '20px';
        roomFilter.addEventListener('change', filterRoomsInSelectionInterface);
        
        const allRoomsOption = document.createElement('option');
        allRoomsOption.value = 'all';
        allRoomsOption.textContent = 'All Rooms';
        roomFilter.appendChild(allRoomsOption);
        
        filterContainer.appendChild(filterLabel);
        filterContainer.appendChild(roomFilter);
        
        // Create save button for the sticky container
        const saveButton = document.createElement('button');
        saveButton.className = 'btn';
        saveButton.addEventListener('click', saveSelectedItemsFromDashboard);
        
        const saveIcon = document.createElement('i');
        saveIcon.className = 'material-icons';
        saveIcon.textContent = 'save';
        saveIcon.style.marginRight = '5px';
        
        saveButton.appendChild(saveIcon);
        saveButton.appendChild(document.createTextNode('Save Selected Items'));
        
        // Actions container in the sticky header
        const actionsContainer = document.createElement('div');
        actionsContainer.style.display = 'flex';
        actionsContainer.style.gap = '10px';
        actionsContainer.appendChild(saveButton);
        
        // Add filter and actions to sticky container
        stickyContainer.appendChild(filterContainer);
        stickyContainer.appendChild(actionsContainer);
        
        // Add sticky container to main container
        container.appendChild(stickyContainer);
        
        // Populate filter dropdown with rooms
        Object.keys(itemsByRoom).sort().forEach(room => {
          const option = document.createElement('option');
          option.value = room;
          option.textContent = room;
          roomFilter.appendChild(option);
        });
        
        // Create a DocumentFragment to hold all room containers before appending to the main container
        const roomsFragment = document.createDocumentFragment();
        
        // Create room sections
        Object.keys(itemsByRoom).sort().forEach(room => {
          const currentRoomItems = itemsByRoom[room];
          
          // Create room container
          const roomContainer = document.createElement('div');
          roomContainer.className = 'room-container';
          roomContainer.id = `room-container-${room.replace(/\s+/g, '-')}`;
          roomContainer.dataset.room = room;
          
          // Add room title
          const roomTitle = document.createElement('div');
          roomTitle.className = 'room-title';
          roomTitle.textContent = room;
          roomContainer.appendChild(roomTitle);
          
          // Add column headers
          const headers = document.createElement('div');
          headers.className = 'column-headers';
          
          // Add a checkbox header
          const checkboxHeader = document.createElement('div');
          checkboxHeader.className = 'column-header checkbox-header';
          checkboxHeader.textContent = 'Add';
          
          const roomHeader = document.createElement('div');
          roomHeader.className = 'column-header room-header';
          roomHeader.textContent = 'Room';

          const typeHeader = document.createElement('div');
          typeHeader.className = 'column-header type-header';
          typeHeader.textContent = 'Type';
          
          const itemHeader = document.createElement('div');
          itemHeader.className = 'column-header item-header';
          itemHeader.textContent = 'Item';
          
          const quantityHeader = document.createElement('div');
          quantityHeader.className = 'column-header quantity-header';
          quantityHeader.textContent = 'QTY';
          
          // const actionsHeader = document.createElement('div');
          // actionsHeader.className = 'column-header actions-header';
          // actionsHeader.textContent = 'Remove Item';
          
          headers.appendChild(checkboxHeader);
          headers.appendChild(roomHeader); // Added new room header
          headers.appendChild(typeHeader);
          headers.appendChild(itemHeader);
          headers.appendChild(quantityHeader);
          // headers.appendChild(actionsHeader);
          
          roomContainer.appendChild(headers);
          
          // Add items container
          const itemsContainer = document.createElement('div');
          itemsContainer.className = 'items-container';
          itemsContainer.id = `items-${room.replace(/\s+/g, '-')}`;
          
          // Use a DocumentFragment for batching item row appends
          const itemsFragment = document.createDocumentFragment();
          // Add each item
          currentRoomItems.forEach((item, index) => {
            const itemRow = createItemSelectionRow(item, index, room);
            itemsFragment.appendChild(itemRow);
          });
          itemsContainer.appendChild(itemsFragment); // Append all item rows at once
          
          // Add delegated event listeners to itemsContainer
          itemsContainer.addEventListener('change', function(event) {
            const target = event.target;
            if (target.classList.contains('room-input') ||
                target.classList.contains('item-input') ||
                target.classList.contains('type-input') ||
                target.classList.contains('quantity-input') ||
                target.classList.contains('item-checkbox')) {
              if (target.dataset.room && target.dataset.index !== undefined && target.dataset.field) {
                updateItemSelectionData(target.dataset.room, target.dataset.index, target.dataset.field, 
                                       target.type === 'checkbox' ? target.checked : target.value);
              }
            }
          });

          itemsContainer.addEventListener('input', function(event) {
            const target = event.target;
            if (
              target.classList.contains('room-input') ||
              target.classList.contains('item-input') ||
              target.classList.contains('type-input') ||
              target.classList.contains('quantity-input')
            ) {
              if (target.dataset.room && target.dataset.index !== undefined && target.dataset.field) {
                updateItemSelectionData(target.dataset.room, target.dataset.index, target.dataset.field, target.value);
              }
            }
          });

          // itemsContainer.addEventListener('click', function(event) {
          //   const target = event.target;
          //   if (target.classList.contains('delete-button')) {
          //     if (target.dataset.room && target.dataset.index !== undefined) {
          //       deleteItemSelectionRow(target.dataset.room, target.dataset.index);
          //     }
          //   }
          // });

          roomContainer.appendChild(itemsContainer);
          
          roomsFragment.appendChild(roomContainer); // Append room container to the fragment
        });
        
        container.appendChild(roomsFragment); // Append all room containers at once
        
        // Update the content area
        document.getElementById('fileContent').innerHTML = '';
        document.getElementById('fileContent').appendChild(container);
      }
      
      /**
       * Creates a row for the item selection interface with a checkbox.
       * @param {Object} item - The item data.
       * @param {number} index - The index of the item.
       * @param {string} roomName - The name of the room.
       * @return {HTMLElement} The created row element.
       */
      function createItemSelectionRow(item, index, roomName) {
        // Create the main row container
        const row = document.createElement('div');
        row.className = 'item-row';
        row.dataset.index = index;
        row.dataset.room = roomName;
        
        // Add checkbox container
        const checkboxContainer = document.createElement('div');
        checkboxContainer.className = 'checkbox-container';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'item-checkbox';
        checkbox.checked = item.isSelected || false;
        checkbox.dataset.field = 'isSelected';
        checkbox.dataset.room = roomName;
        checkbox.dataset.index = index;
        
        checkboxContainer.appendChild(checkbox);
        
        // Room input container (New)
        const roomInputContainer = document.createElement('div');
        roomInputContainer.className = 'item-input-container'; // Use same class for styling consistency

        const roomInput = document.createElement('input');
        roomInput.type = 'text';
        roomInput.className = 'room-input'; // New class for specific styling if needed
        roomInput.value = item.room.toUpperCase() || roomName.toUpperCase() || ''; // Populate with item's room or passed roomName
        roomInput.disabled = true; // Make it disabled
        roomInput.dataset.field = 'room'; // Add data-field for consistency
        roomInput.dataset.room = roomName;
        roomInput.dataset.index = index;

        roomInputContainer.appendChild(roomInput);
        
        // Type input container
        const typeInputContainer = document.createElement('div');
        typeInputContainer.className = 'item-input-container';
        
        // Type input
        const typeInput = document.createElement('input');
        typeInput.type = 'text';
        typeInput.className = 'type-input';
        typeInput.value = item.type || '';
        typeInput.dataset.field = 'type';
        typeInput.dataset.room = roomName;
        typeInput.dataset.index = index;
        
        typeInputContainer.appendChild(typeInput);
        
        // Item input container with autocomplete
        const itemInputContainer = document.createElement('div');
        itemInputContainer.className = 'item-input-container';
        
        const itemInput = document.createElement('input');
        itemInput.type = 'text';
        itemInput.className = 'item-input';
        itemInput.value = item.item || '';
        itemInput.dataset.field = 'item';
        itemInput.dataset.room = roomName;
        itemInput.dataset.index = index;
        
        // Add focus event to show autocomplete
        itemInput.addEventListener('focus', function() {
          showAutocomplete(this);
        });
        
        // Add keydown event for filtering as user types
        itemInput.addEventListener('input', function() {
          filterAutocompleteItems(this);
        });
        
        // Add keydown event for keyboard navigation
        itemInput.addEventListener('keydown', function(e) {
          handleAutocompleteKeydown(e, this);
        });
        
        // Add blur event to close the autocomplete dropdown when clicking outside
        itemInput.addEventListener('blur', function() {
          // Use a small delay to allow click events on autocomplete items to complete
          setTimeout(() => {
            if (activeAutocompleteInput === this) {
              const autocompleteList = this.parentElement.querySelector('.autocomplete-list');
              if (autocompleteList) {
                autocompleteList.style.display = 'none';
              }
              activeAutocompleteInput = null;
            }
          }, 200);
        });
        
        const autocompleteList = document.createElement('div');
        autocompleteList.className = 'autocomplete-list';
        
        itemInputContainer.appendChild(itemInput);
        itemInputContainer.appendChild(autocompleteList);
        
        // Quantity input
        const quantityInput = document.createElement('input');
        quantityInput.type = 'number';
        quantityInput.className = 'quantity-input';
        quantityInput.value = item.quantity || 1;
        quantityInput.min = '1';
        quantityInput.dataset.field = 'quantity';
        quantityInput.dataset.room = roomName;
        quantityInput.dataset.index = index;
        
        // Delete button container
        // const deleteButtonContainer = document.createElement('div');
        // deleteButtonContainer.className = 'delete-button-container';
        
        // const deleteButton = document.createElement('button');
        // deleteButton.className = 'delete-button';
        // deleteButton.textContent = '';
        // deleteButton.dataset.room = roomName;
        // deleteButton.dataset.index = String(index); // For delegated event handler
        
        // deleteButtonContainer.appendChild(deleteButton);
        
        // Add all elements to the row in new order: checkbox, room, type, item, quantity
        row.appendChild(checkboxContainer);
        row.appendChild(roomInputContainer); // Added new room input container
        row.appendChild(typeInputContainer);
        row.appendChild(itemInputContainer);
        row.appendChild(quantityInput);
        // row.appendChild(deleteButtonContainer);
        
        return row;
      }
      
      /**
       * Updates item selection data when inputs change.
       * @param {string} roomName - The name of the room.
       * @param {number|string} index - The index of the item.
       * @param {string} field - The field to update.
       * @param {*} value - The new value.
       */
      function updateItemSelectionData(roomName, index, field, value) {
        const idx = parseInt(index);
        const roomItems = dashboardItemSelectionData.itemsByRoom[roomName] || [];
        
        if (idx < 0 || idx >= roomItems.length) {
          console.error(`Invalid index: ${idx}. Room ${roomName} items length: ${roomItems.length}`);
          return;
        }
        
        const item = roomItems[idx];
        console.log(`Updating ${field} for item in ${roomName} at index ${idx} to value:`, value);
        
        // Explicitly handle the 'room' field case, though it's disabled
        if (field === 'room') {
          // Even though disabled, ensure the underlying data model is not unintentionally changed if an event fires.
          // The item.room should reflect the correct, original room name.
          // We also compare against roomName (the original room context for this row) to be safe.
          if (item.room !== value && roomName !== value) { 
             console.warn(`Attempted to update disabled 'room' field for item '${item.item}'. Original: '${item.room}', Attempted: '${value}'. Change ignored.`);
          }
          // No actual update to item.room should happen here as it's a disabled, display-only field.
        } else if (field === 'quantity') {
          item[field] = parseInt(value) || 1;
        } else if (field === 'isSelected') {
          item[field] = value; // Boolean for checkbox
        } else {
          // For 'item' and 'type' fields, convert to uppercase
          if (field === 'item' || field === 'type') {
            item[field] = value.toUpperCase();
          } else {
            // For any other fields
            item[field] = value;
          }
        }
        
        // Find the same item in the main items array and update it too
        const mainIndex = dashboardItemSelectionData.items.findIndex(i => 
          i === item || 
          (i.id && item.id && i.id === item.id) ||
          (i.room === roomName && i.item === item.item && i.type === item.type)
        );
        
        if (mainIndex >= 0) {
          console.log(`Updating main items array at index ${mainIndex}`);
          // Update the corresponding fields, not just the one field
          dashboardItemSelectionData.items[mainIndex] = { ...item };
        } else {
          console.warn(`Couldn't find item in main items array. Room: ${roomName}, Index: ${idx}, Field: ${field}`);
        }
      }
      
      /**
       * Filters rooms in the selection interface.
       */
      function filterRoomsInSelectionInterface() {
        const selectedRoom = document.getElementById('room-filter').value;
        const roomContainers = document.querySelectorAll('.room-container');
        
        roomContainers.forEach(container => {
          if (selectedRoom === 'all' || container.dataset.room === selectedRoom) {
            container.style.display = 'block';
          } else {
            container.style.display = 'none';
          }
        });
      }
      
      /**
       * Deletes an item row from the selection interface.
       * @param {string} roomName - The name of the room.
       * @param {number|string} index - The index of the item to delete.
       */
      function deleteItemSelectionRow(roomName, index) {
        if (confirm('Are you sure you want to delete this item?')) {
          // Remove from data structure
          const roomItems = dashboardItemSelectionData.itemsByRoom[roomName] || [];
          if (roomItems[index]) {
            // Find the item in the overall items array
            const itemToRemove = roomItems[index];
            const overallIndex = dashboardItemSelectionData.items.findIndex(item => 
              item === itemToRemove || 
              (item.room === roomName && item.item === itemToRemove.item && item.type === itemToRemove.type) // More specific match
            );
            
            if (overallIndex !== -1) {
              dashboardItemSelectionData.items.splice(overallIndex, 1);
            }
            
            // Remove from room items
            roomItems.splice(index, 1);
            
            // Refresh the entire room section to update indices
            refreshItemSelectionDisplay(roomName);
            
            // If this was the last item in the room and we're filtering by this room,
            // switch back to "All Rooms" view
            if (roomItems.length === 0) {
              const currentFilter = document.getElementById('room-filter').value;
              if (currentFilter === roomName) {
                document.getElementById('room-filter').value = 'all';
                filterRoomsInSelectionInterface();
              }
            }
            
            // Show status message
            showDashboardStatusMessage('Item deleted successfully');
          }
        }
      }
      
      /**
       * Refreshes the display of all items for a room in the selection interface.
       * @param {string} roomName - The name of the room to refresh.
       */
      function refreshItemSelectionDisplay(roomName) {
        const roomItems = dashboardItemSelectionData.itemsByRoom[roomName] || [];
        const container = document.getElementById(`items-${roomName.replace(/\s+/g, '-')}`);
        
        // Clear the container
        container.innerHTML = '';
        
        // Use a DocumentFragment for batching item row appends
        const itemsFragment = document.createDocumentFragment();
        // Regenerate all item rows
        roomItems.forEach((item, index) => {
          const newRow = createItemSelectionRow(item, index, roomName);
          itemsFragment.appendChild(newRow);
        });
        container.appendChild(itemsFragment); // Append all item rows at once
      }
      
      /**
       * Saves selected items from the dashboard to the sheet.
       */
      function saveSelectedItemsFromDashboard() {
        console.log('Starting save process for selected items');
        
        // Get sheetId from the dialog if available
        const dialog = document.querySelector('.app-container');
        const sheetId = dialog ? dialog.getAttribute('data-sheet-id') : null;
        console.log('saveSelectedItemsFromDashboard: found sheetId:', sheetId);
        
        showDashboardLoading('Saving selected items...');
        
        // Get all items that are selected
        const allItems = dashboardItemSelectionData.items || [];
        const selectedItems = allItems.filter(item => item.isSelected === true && item.room && item.item && item.item.trim() !== ''); // Ensure room and item are present
        
        console.log('Selected items to save:', selectedItems.length);
        
        if (selectedItems.length === 0) {
          hideDashboardLoading();
          showDashboardStatusMessage('No items selected. Please select items before saving.', true);
          return;
        }
        
        // Make sure all selected items have valid data
        const itemsToSave = selectedItems.filter(item => item.item && item.item.trim() !== '');
        
        if (itemsToSave.length === 0) {
          hideDashboardLoading();
          showDashboardStatusMessage('No valid items to save. Please ensure selected items have names.', true);
          return;
        }
        
        // Sanitize items - remove any budget fields
        const sanitizedItems = itemsToSave.map(item => {
          // Create a deep copy to avoid modifying the original
          const sanitizedItem = JSON.parse(JSON.stringify(item));
          
          // Ensure quantity is at least 1
          sanitizedItem.quantity = Math.max(1, parseInt(sanitizedItem.quantity) || 1);
          
          // Remove budget properties that we don't need for this interface
          if ('lowBudget' in sanitizedItem) delete sanitizedItem.lowBudget;
          if ('highBudget' in sanitizedItem) delete sanitizedItem.highBudget;
          if ('lowBudgetTotal' in sanitizedItem) delete sanitizedItem.lowBudgetTotal;
          if ('highBudgetTotal' in sanitizedItem) delete sanitizedItem.highBudgetTotal;
          
          // Remove temporary properties that shouldn't be saved
          if ('isNew' in sanitizedItem) delete sanitizedItem.isNew;
          if ('id' in sanitizedItem && sanitizedItem.id.toString().startsWith('new_')) delete sanitizedItem.id;
          
          return sanitizedItem;
        });
        
        console.log('Sanitized items ready for saving:', sanitizedItems.length);
        console.log('Sample sanitized item:', sanitizedItems.length > 0 ? sanitizedItems[0] : 'No items');
        
        // Call the server-side function with the sanitized items
        google.script.run
          .withSuccessHandler(function(result) {
            console.log('Server response for save operation:', result);
            hideDashboardLoading();
            
            if (result.success) {
              // Show a success message
              showDashboardStatusMessage(`${result.message || `Successfully created Master Item List with ${result.itemCount} items`}`, false);
              
              // Close the dialog - the sheet should already be active since the server function activated it
              google.script.host.close();
              
              // Mark saved items as no longer selected
              dashboardItemSelectionData.items.forEach(item => {
                if (item.isSelected) item.isSelected = false;
              });
              
              // Refresh the display to show updated selection state
              Object.keys(dashboardItemSelectionData.itemsByRoom).forEach(room => {
                refreshItemSelectionDisplay(room);
              });
            } else {
              console.error('Server reported error:', result.error || 'Unknown error');
              showDashboardStatusMessage('Error: ' + (result.error || 'Failed to save items'), true);
            }
          })
          .withFailureHandler(function(error) {
            console.error('Error during save operation:', error);
            hideDashboardLoading();
            showDashboardStatusMessage('Error: ' + (error.message || error), true);
          })
          .saveSelectedItemsWithTemplateCopy(sanitizedItems);
      }

      /**
       * Shows the item selection interface in the dashboard.
       * This interface allows users to select items from category lists to add to the project.
       */
      function showItemSelectionInterface() {
        // Store the original project name if not already stored
        const projectNameElement = document.getElementById('projectName');
        if (projectNameElement && !window.originalProjectName) {
          window.originalProjectName = projectNameElement.innerText;
        }
        
        // Update the page title
        if (projectNameElement) {
          projectNameElement.innerText = 'Select Items';
        }
        
        const mainContentContainer = document.getElementById('fileContent');
        
        // Get the sheet ID from the project details modal
        const dialog = document.querySelector('.app-container');
        const sheetId = dialog ? dialog.getAttribute('data-sheet-id') : null;
        
        console.log('showItemSelectionInterface: found sheetId:', sheetId);
        
        // Only proceed if we have a sheetId
        if (!sheetId) {
          if (mainContentContainer) {
            renderUIState(mainContentContainer, 'error', '<strong>Error:</strong> No sheet ID found. Unable to load items.');
          }
          return;
        }
        
        // Show global loading overlay and set loading for main container
        showDashboardLoading('Loading item selection...');
        if (mainContentContainer) {
            mainContentContainer.innerHTML = `
              <div class="loading-state">
                <div class="spinner"></div>
                <p>Loading items...</p>
              </div>`;
        }
        
        // First get the currently selected rooms
        google.script.run
          .withSuccessHandler(function(selectedResult) {
            if (!selectedResult.success) {
              hideDashboardLoading();
              if (mainContentContainer) {
                renderUIState(mainContentContainer, 'error', '<strong>Error:</strong> ' + (selectedResult.error || 'Failed to get selected rooms'));
              } else {
                alert('Error: Failed to get selected rooms. Main content area missing.');
              }
              return;
            }
            
            // Keep track of the already selected rooms
            const currentlySelectedRooms = selectedResult.selectedRooms || [];
            
            // If there are no selected rooms yet, simply show the room manager
            if (currentlySelectedRooms.length === 0) {
              hideDashboardLoading();
              // Navigate to Room Categories tab instead of Room Manager
              if (typeof switchSidebarTab === 'function') {
                switchSidebarTab('roomCategories');
              } else {
                console.warn('switchSidebarTab function not found, cannot navigate to Room Categories.');
                // Fallback to original behavior if switchSidebarTab is not available
                showRoomManager(); 
              }
              return;
            }
            
            // Keep the same loading state we set earlier - don't change it
            google.script.run
              .withSuccessHandler(function(result) {
                hideDashboardLoading();
                if (mainContentContainer) {
                    if (result.success) {
                        // Initialize the interface with room data
                        renderItemSelectionInterface(result);
                    } else {
                        renderUIState(mainContentContainer, 'error', '<strong>Error:</strong> ' + (result.error || 'Failed to load items data'));
                    }
                } else {
                     alert('Error loading items data. Main content area missing.');
                }
              })
              .withFailureHandler(function(error) {
                hideDashboardLoading();
                if (mainContentContainer) {
                    renderUIState(mainContentContainer, 'error', '<strong>Error:</strong> ' + (error.error || error.message || error.toString()));
                } else {
                     alert('Error loading items data. Main content area missing.');
                }
              })
              .getItemSelectionData(sheetId, currentlySelectedRooms);
          })
          .withFailureHandler(function(error) {
            hideDashboardLoading();
            if (mainContentContainer) {
                renderUIState(mainContentContainer, 'error', '<strong>Error:</strong> ' + (error.error || error.message || error.toString()));
            } else {
                 alert('Error loading item selection. Main content area missing.');
            }
          })
          .getSelectedRooms(sheetId);
      }
</script> 