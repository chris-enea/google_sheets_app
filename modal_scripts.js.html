<script>
      // Global variable to track which input has an open dropdown
      let activeAutocompleteInput = null;

      /**
       * Helper function to capitalize the first letter of a string.
       * @param {string} string - The string to capitalize.
       * @return {string} The string with the first letter capitalized.
       */
      function capitalizeFirstLetter(string) {
        if (!string) return '';
        return string.charAt(0).toUpperCase() + string.slice(1);
      }

      /**
       * Renders standardized UI states (loading, error, empty, success) within a given container.
       * @param {string|HTMLElement} containerElementOrId - The ID of the container element or the element itself.
       * @param {'loading'|'error'|'empty'|'success'} state - The UI state to render.
       * @param {string} [message=''] - An optional message to display (e.g., error details, empty state text).
       */
      function renderUIState(containerElementOrId, state, message = '') {
        const container = (typeof containerElementOrId === 'string') ? 
                          document.getElementById(containerElementOrId) :
                          containerElementOrId;

        if (!container) {
          console.error('renderUIState: Container not found:', containerElementOrId);
          return;
        }

        container.innerHTML = ''; // Clear previous content

        let iconName = '';
        let defaultMessage = '';
        let stateClass = '';

        switch (state) {
          case 'loading':
            defaultMessage = 'Loading...'; // Default message if none provided
            stateClass = 'loading-state';
            container.innerHTML = `
              <div class="${stateClass}">
                <div class="spinner"></div>
                <p>${message || defaultMessage}</p>
              </div>
            `;
            break;
          case 'error':
            iconName = 'error_outline';
            defaultMessage = 'An error occurred.';
            stateClass = 'error-box-standard';
            container.innerHTML = `
              <div class="${stateClass}">
                <i class="material-icons">${iconName}</i>
                <span>${message || defaultMessage}</span>
              </div>`;
            break;
          case 'empty':
            iconName = 'info_outline';
            defaultMessage = 'No items to display.';
            stateClass = 'empty-state-standard';
            container.innerHTML = `
              <div class="${stateClass}">
                <i class="material-icons">${iconName}</i>
                <span>${message || defaultMessage}</span>
              </div>`;
            break;
          case 'success':
            // Typically, for success, the calling function will populate the actual content.
            // This case can be used if a generic success message is needed.
            if (message) {
              iconName = 'check_circle_outline';
              stateClass = 'success-box-standard';
              container.innerHTML = `
                <div class="${stateClass}">
                  <i class="material-icons">${iconName}</i>
                  <span>${message}</span>
                </div>`;
            }
            // If no message, container remains empty, ready for content.
            break;
          default:
            console.warn('renderUIState: Unknown state:', state);
            container.innerHTML = `<div>Unknown state: ${state}</div>`; // Fallback
        }
      }

       // Sidebar toggle functionality
       /* document.addEventListener('DOMContentLoaded', function() {
        console.log('modal_scripts.js.html: DOMContentLoaded event fired.');

        const sidebarToggle = document.getElementById('sidebarToggle');
        const sidebar = document.querySelector('.sidebar');
        
        // Set up toggle button click event
        if (sidebarToggle && sidebar) {
          sidebarToggle.addEventListener('click', function() {
            sidebar.classList.toggle('collapsed');
            
            // Update the toggle button icon and class
            const toggleIcon = sidebarToggle.querySelector('.material-icons');
            if (sidebar.classList.contains('collapsed')) {
              toggleIcon.textContent = 'chevron_right';
              sidebarToggle.classList.add('collapsed');
            } else {
              toggleIcon.textContent = 'chevron_left';
              sidebarToggle.classList.remove('collapsed');
            }
          });
        }
        
        // Set up tab functionality
        const sidebarTabs = document.querySelectorAll('.sidebar-tab');
        
        sidebarTabs.forEach(tab => {
          tab.addEventListener('click', function() {
            // Remove active class from all tabs and contents
            // document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
            // document.querySelectorAll('.sidebar-content').forEach(c => c.classList.remove('active'));
            
            // Add active class to clicked tab
            // this.classList.add('active');
            
            // Show the corresponding content
            const tabName = this.getAttribute('data-tab');
            const contentElement = document.getElementById(tabName + '-content');
            if (contentElement) {
              // contentElement.classList.add('active');
              
              // Load specific content based on tab
              if (tabName === 'rooms') {
                showRoomManager('sidebar');
              } else if (tabName === 'folders') {
                loadFolders('sidebar');
              } else if (tabName === 'tasks') {
                loadAsanaTasks();
              }
            }
            
            // If sidebar is collapsed, expand it
            if (sidebar.classList.contains('collapsed')) {
              sidebar.classList.remove('collapsed');
              sidebarToggle.querySelector('.material-icons').textContent = 'chevron_left';
              sidebarToggle.classList.remove('collapsed');
            }
          });
        });
      }); */

      // Function to toggle folder list visibility
      function toggleList(id) {
        const list = document.getElementById(id);
        if (list) {
          const isVisible = list.style.display === 'block';
          list.style.display = isVisible ? 'none' : 'block';
          
          // Also update the folder icon
          const header = list.previousElementSibling;
          if (header) {
            const folderIcon = header.querySelector('.material-icons:first-child');
            const chevronIcon = header.querySelector('.material-icons.chevron');
            
            if (folderIcon) {
              folderIcon.textContent = isVisible ? 'folder' : 'folder_open';
            }
            
            if (chevronIcon) {
              chevronIcon.textContent = isVisible ? 'chevron_right' : 'expand_more';
            }
          }
        }
      }
      
      function openSettings() {
        google.script.run.showBasicSettings();
      }
      
      function openBudget() {
        google.script.run.showBudgetDialog();
      }
      
      function openItemManager() {
        google.script.run.showItemManager();
      }
      
      function loadAsanaTasks() {
        const taskDisplay = document.getElementById('taskDisplay');
        if (!taskDisplay) return;

        renderUIState(taskDisplay, 'loading', 'Loading Asana tasks...');
        
        google.script.run
          .withSuccessHandler(displayTasks) // Assuming displayTasks handles its own content or calls renderUIState for empty state
          .withFailureHandler(handleTaskError)
          .getAsanaTasks();
      }
      
      function refreshTasks() {
        loadAsanaTasks();
      }
      
      // Assuming handleTaskError function exists or will be created:
      function handleTaskError(error) {
        const taskDisplay = document.getElementById('taskDisplay');
        if (!taskDisplay) return;
        let errorMessage = 'Error loading tasks.';
        if (typeof error === 'string') {
          errorMessage = error;
        } else if (error && error.message) {
          errorMessage = error.message;
        } else if (error && error.details) {
          errorMessage = error.details;
        }
        renderUIState(taskDisplay, 'error', errorMessage);
        console.error('Asana Task Error:', error);
      }
      
      function handleBudgetError(error) {
        const budgetDisplay = document.getElementById('budgetSummaryDisplay');
        if (!budgetDisplay) return;
        let errorMessage = 'Error loading budget data.';
        if (typeof error === 'string') {
          errorMessage = error;
        } else if (error && error.message) {
          errorMessage = error.message;
        } else if (error && error.details) {
          errorMessage = error.details;
        }
        renderUIState(budgetDisplay, 'error', errorMessage);
        console.error('Budget Data Error:', error);
      }
      
      function createNewTask() {
        google.script.run.showAsanaTaskForm();
      }
      
      // Budget Integration Functions
      function loadBudgetData() {
        const budgetDisplay = document.getElementById('budgetSummaryDisplay');
        if (!budgetDisplay) return;
        
        renderUIState(budgetDisplay, 'loading', 'Loading budget data...');
        
        // Get the sheet ID from the project details modal
        const dialog = document.querySelector('.app-container');
        const sheetId = dialog ? dialog.getAttribute('data-sheet-id') : null;
        
        console.log('loadBudgetData: found sheetId:', sheetId);
        
        google.script.run
          .withSuccessHandler(displayBudgetSummary)
          .withFailureHandler(handleBudgetError)
          .getBudgetData(sheetId);
      }
      
      function refreshBudget() {
        loadBudgetData();
      }

      /**
       * Shows the welcome screen in the main content area.
       * Clears any existing content (like Item Manager or Gantt chart) and displays the standard welcome message.
       * Restores the original project name in the main header.
       */
      function showWelcomeScreen() {
        console.log('showWelcomeScreen called - resetting main content');
        const mainContentContainer = document.getElementById('mainContent');
        const projectNameHeader = document.getElementById('projectName');

        if (mainContentContainer) {
          // Set the main content to the welcome message HTML
          mainContentContainer.innerHTML = `
            <div class="welcome-message">
              <i class="material-icons">dashboard</i>
              <h3>Welcome to Norton Interiors</h3>
            </div>
            <!-- Note: The dashboardLoadingOverlay is structurally part of fileContent in Project_Details_.html -->
            <!-- but it is controlled by show/hideDashboardLoading functions globally. -->
            <!-- Re-adding it here might be redundant if those functions expect it to always exist. -->
            <!-- For now, omitting it from direct innerHTML reset, assuming global functions handle it. -->
          `;
          console.log('Main content reset to welcome message.');
        } else {
          console.error('Main content container (fileContent) not found!');
        }

        // Restore the project name in the header, prioritizing window.originalProjectName
        if (projectNameHeader) {
            projectNameHeader.textContent = window.originalProjectName || 'Project Dashboard';
            console.log('showWelcomeScreen restored main header to:', projectNameHeader.textContent);
        } else {
          console.error('Project name header element (projectName) not found!');
        }
        
        // Hide any global loading overlays if they were active
        if (typeof hideDashboardLoading === 'function') {
            hideDashboardLoading();
            console.log('Dashboard loading overlay hidden.');
        }
        clearActiveMainContentButton(); // Use the new clearer function

        // Ensure the Create Master Item List button visibility is updated
        toggleCreateMasterListButtonVisibility();
      }

      function exportBudgetReport() {
        google.script.run
          .withSuccessHandler(function() {
            alert('Budget report exported successfully');
          })
          .withFailureHandler(function(error) {
            alert('Error exporting budget report: ' + error);
          })
          .exportBudgetReport();
      }
      
      function sendVendorEmails() {
        google.script.run
          .withSuccessHandler(function() {
            alert('Emails sent successfully to all vendors');
          })
          .withFailureHandler(function(error) {
            alert('Error sending emails: ' + error);
          })
          .sendVendorEmails();
      }

      function createVendorEmailDraft(vendorName) {
        const emailInput = document.getElementById(`email-${vendorName}`);
        const messageInput = document.getElementById(`message-${vendorName}`);
        const email = emailInput.value.trim();
        const customMessage = messageInput.value.trim();
        
        if (!email) {
          alert('Please enter an email address');
          return;
        }
        
        if (!isValidEmail(email)) {
          alert('Please enter a valid email address');
          return;
        }
        
        google.script.run
          .withSuccessHandler(function() {
            alert('Draft email created successfully for ' + vendorName + '\nCheck your Gmail drafts folder.');
          })
          .withFailureHandler(function(error) {
            alert('Error creating draft email: ' + error);
          })
          .createVendorEmailDraft(vendorName, email, customMessage);
      }
      
      /**
       * Shows the Room Manager interface in the specified location (sidebar or main content).
       * @param {string} [location='main'] - 'sidebar' or 'main'. Defaults to 'main'.
       */
      function showRoomManager(location = 'main') {
        const projectNameElement = document.getElementById('projectName');
        // Store the original project name only when switching to main content Room Manager
        if (projectNameElement && !window.originalProjectName && location === 'main') {
          window.originalProjectName = projectNameElement.innerText;
        }

        // Update the page title only for main content view
        if (projectNameElement && location === 'main') {
          projectNameElement.innerText = 'Room Manager';
        }
        setActiveMainContentButton('selectRoomsBtn'); // Added this line
        
        const containerId = location === 'sidebar' ? 'sidebarRoomManagerContent' : 'mainContent';
        const targetContainer = document.getElementById(containerId);

        console.log(`showRoomManager: rendering in ${location} container: '${containerId}'`);

        if (!targetContainer) {
            console.error(`showRoomManager: ${capitalizeFirstLetter(location)} container '${containerId}' not found.`);
            alert(`Critical Error: Room Manager UI container (id: ${containerId}) is missing from the page.`);
            return;
        }

        renderUIState(targetContainer, 'loading', 'Loading rooms...');
        
        const dialog = document.querySelector('.app-container');
        const sheetId = dialog ? dialog.getAttribute('data-sheet-id') : null;

        console.log('showRoomManager: found sheetId:', sheetId);
        
        google.script.run
          .withSuccessHandler(function(result) {
            // **** ADD DETAILED LOGGING HERE ****
            console.log(`showRoomManager SUCCESS for ${location}. Raw result:`, JSON.stringify(result, null, 2));
            if (targetContainer) {
              console.log(`Target container for ${location} is:`, targetContainer.id, `Visible: ${targetContainer.checkVisibility ? targetContainer.checkVisibility() : 'N/A'}`);
            } else {
              console.error(`Target container is NULL before calling renderRoomManager for ${location}`);
            }
            
            if (result && result.success) {
              console.log(`Proceeding to renderRoomManager for ${location} with rooms:`, result.rooms);
              renderRoomManager(result, targetContainer, location);
            } else {
              console.error(`showRoomManager for ${location}: Server call did not return success or valid result. Result:`, result);
              const errorMessage = (result && result.error) ? result.error : 'Failed to load rooms or invalid data from server.';
              renderUIState(targetContainer, 'error', errorMessage);
            }
          })
          .withFailureHandler(function(error) {
            // **** ADD DETAILED LOGGING FOR FAILURE ****
            console.error(`showRoomManager FAILURE for ${location}. Error:`, JSON.stringify(error, null, 2));
            const errorMessage = error.error || error.message || error.toString() || 'Failed to load rooms.';
            renderUIState(targetContainer, 'error', errorMessage);
          })
          .getRoomsForDashboard(sheetId); // sheetId can be null, server should handle
      }
      
      /**
       * Sets the loading state for a button.
       * @param {HTMLElement} buttonElement - The button element.
       * @param {boolean} isLoading - True to set loading state, false to restore original state.
       * @param {string} loadingHtml - HTML content for the button in loading state (e.g., spinner icon and text).
       * @param {string} originalHtml - Original HTML content of the button to restore.
       */
      function _setButtonLoadingState(buttonElement, isLoading, loadingHtml, originalHtml) {
        if (!buttonElement) return;

        if (isLoading) {
          buttonElement.innerHTML = loadingHtml;
          buttonElement.disabled = true;
        } else {
          buttonElement.innerHTML = originalHtml;
          buttonElement.disabled = false;
        }
      }
      
      /**
       * Adds a new room from the dashboard or sidebar.
       * @param {string} [location='main'] - 'sidebar' or 'main'.
       */
      function addNewRoom(location = 'main') { // Ensure default location
        const capLocation = capitalizeFirstLetter(location);
        const inputId = `newRoomName${capLocation}`; // e.g., newRoomNameMain or newRoomNameSidebar
        const roomNameInput = document.getElementById(inputId);

        if (!roomNameInput) {
          console.error(`addNewRoom: Room name input field with ID '${inputId}' not found for location '${location}'.`);
          showDashboardStatusMessage(`Error: UI component for adding room not found.`, true, location);
          return;
        }
        const newRoomName = roomNameInput.value.trim();
        
        if (!newRoomName) {
          showDashboardStatusMessage('Please enter a room name', true, location);
          return;
        }
        
        const addButtonId = `addRoomButton${capLocation}`; // e.g., addRoomButtonMain or addRoomButtonSidebar
        const addButton = document.getElementById(addButtonId); 
        let originalButtonHtml = '';
        let loadingButtonHtml = '';

        if (addButton) {
            originalButtonHtml = addButton.innerHTML; 
            loadingButtonHtml = `<i class="material-icons rotating" style="margin-right: 5px; vertical-align: middle;">sync</i> Adding...`;
           _setButtonLoadingState(addButton, true, loadingButtonHtml, originalButtonHtml);
        } else if (location === 'main') {
            // Fallback for main content if a specific button isn't part of the room manager itself
            showDashboardLoading('Adding room...'); 
        } else {
            // If not main and button not found, log a warning. Sidebar should ideally have its button.
            console.warn(`addNewRoom: Add button with ID '${addButtonId}' not found for location '${location}'. Cannot show button loading state.`);
        }
        
        google.script.run
          .withSuccessHandler(function(result) {
            if (addButton) {
                _setButtonLoadingState(addButton, false, '', originalButtonHtml);
            } else if (location === 'main') {
                hideDashboardLoading(); 
            }
            
            if (result.success) {
              showDashboardStatusMessage(`Room "${result.roomName}" added successfully`, false, location);
              roomNameInput.value = ''; 
              showRoomManager(location); // Refresh room manager in the correct location
            } else {
              showDashboardStatusMessage(result.error || 'Error adding room', true, location);
            }
          })
          .withFailureHandler(function(error) {
            if (addButton) {
                _setButtonLoadingState(addButton, false, '', originalButtonHtml);
            } else if (location === 'main') {
                hideDashboardLoading(); 
            }
            showDashboardStatusMessage(`Error: ${error.message || error}`, true, location);
          })
          .addRoom(newRoomName);
      }
      
      /**
       * Saves selected rooms from the dashboard or sidebar.
       * @param {string} [location='main'] - 'sidebar' or 'main'.
       */
      function saveRoomsFromDashboard(location = 'main', isAutoSave = false) { // Added isAutoSave parameter
        const capLocation = capitalizeFirstLetter(location);
        const listId = `${location}RoomList`; // e.g., mainRoomList or sidebarRoomList
        
        const roomListElement = document.getElementById(listId);
        if (!roomListElement) {
            console.error(`saveRoomsFromDashboard: Room list element with ID '${listId}' not found for location '${location}'.`);
            showDashboardStatusMessage('Error: UI component for saving rooms not found.', true, location);
            return;
        }

        const checkboxes = roomListElement.querySelectorAll('input[type="checkbox"]:checked');
        const selectedRooms = Array.from(checkboxes).map(checkbox => checkbox.getAttribute('data-room'));
        
        // Allow auto-save with empty selection to clear all if needed, but prevent explicit save of no rooms.
        if (selectedRooms.length === 0 && !isAutoSave && location === 'main') { 
          showDashboardStatusMessage('Please select at least one room to continue', true, location);
          return;
        }
        
        const saveButtonId = `saveRoomsButton${capLocation}`; // e.g., saveRoomsButtonMain or saveRoomsButtonSidebar
        const saveButton = document.getElementById(saveButtonId);
        let originalButtonHtml = '';
        let loadingButtonHtml = '';

        if (saveButton) {
            originalButtonHtml = saveButton.innerHTML;
            loadingButtonHtml = `<i class="material-icons rotating" style="margin-right: 5px; vertical-align: middle;">sync</i> Saving...`;
            _setButtonLoadingState(saveButton, true, loadingButtonHtml, originalButtonHtml);
        } else if (location === 'main' && !isAutoSave) { // Only show global loading if not auto-save
            // Fallback for main if specific button not found and it's expected to be part of a global loading
            showDashboardLoading('Saving selected rooms...'); 
        } else {
            console.warn(`saveRoomsFromDashboard: Save button with ID '${saveButtonId}' not found for location '${location}'. Cannot show button loading state.`);
        }
        
        google.script.run
          .withSuccessHandler(function(result) {
            if (saveButton) {
                _setButtonLoadingState(saveButton, false, '', originalButtonHtml);
            } else if (location === 'main' && !isAutoSave) { // Only hide global loading if not auto-save
                hideDashboardLoading(); 
            }
            
            if (result.success) {
              if (isAutoSave) {
                showDashboardStatusMessage('Room selection updated.', false, location);
                console.log(`[saveRoomsFromDashboard - ${location} (AutoSave)] Successfully updated rooms. Server confirmation:`, result); // Added log
              } else {
                showDashboardStatusMessage('Rooms saved. Loading item management...', false, location);
                console.log(`[saveRoomsFromDashboard - ${location}] Successfully saved rooms and loading items. Server confirmation:`, result); // Added log
                // Always show item update in main content, regardless of where rooms were saved from.
                showItemUpdateInDashboard(); 
              
                if (location === 'sidebar') {
                  // If rooms were selected/saved from sidebar, collapse it to show main content.
                  const sidebarElement = document.querySelector('.app-container .sidebar');
                  if (sidebarElement) sidebarElement.classList.add('collapsed');
                   const sidebarToggle = document.getElementById('sidebarToggle');
                   if(sidebarToggle) {
                      const toggleIcon = sidebarToggle.querySelector('.material-icons');
                      if (toggleIcon) toggleIcon.textContent = 'chevron_right';
                      sidebarToggle.classList.add('collapsed');
                   }
                }
              }
              // Refresh home sidebar content to show updated selected rooms
              if (typeof updateHomeSidebarContent === 'function') {
                // Add a small delay to allow server-side changes to propagate
                setTimeout(function() {
                  updateHomeSidebarContent(!isAutoSave); // Pass inverse of isAutoSave for isFullRender
                }, 300); // 300ms delay
              } else {
                console.warn('updateHomeSidebarContent function not found, cannot refresh home tab after saving rooms.');
              }
            } else {
              showDashboardStatusMessage('Error: ' + (result.error || 'Failed to save selected rooms'), true, location);
            }
          })
          .withFailureHandler(function(error) {
            if (saveButton) {
                _setButtonLoadingState(saveButton, false, '', originalButtonHtml);
            } else if (location === 'main' && !isAutoSave) { // Only hide global loading if not auto-save
                hideDashboardLoading(); 
            }
            showDashboardStatusMessage('Error: ' + (error.message || error), true, location);
          })
          .saveSelectedRoomsCore(selectedRooms);
      }
      
      // New function to directly show the manage items interface
      function showManageItems() {
        // Update the page title
        document.getElementById('projectName').innerText = 'Manage Items';
        const mainContentContainer = document.getElementById('mainContent');

        setActiveMainContentButton('manageItemsBtn'); // Added this line
        
        // Collapse the sidebar when Manage Items is clicked
        document.querySelector('.sidebar').classList.add('collapsed');
        
        // Get the sheet ID from the project details modal
        const dialog = document.querySelector('.app-container');
        
        // Show global loading overlay and set loading for main container
        showDashboardLoading('Loading items management...');
        if (mainContentContainer) {
            // Use the specific loading state requested by the user
            mainContentContainer.innerHTML = `
              <div class="loading-state">
                <div class="spinner"></div>
                <p>Loading items...</p>
              </div>`;
        }
        
        // First get the currently selected rooms
        google.script.run
          .withSuccessHandler(function(selectedResult) {
            if (!selectedResult.success) {
              hideDashboardLoading();
              if (mainContentContainer) {
                renderUIState(mainContentContainer, 'error', '<strong>Error:</strong> ' + (selectedResult.error || 'Failed to get selected rooms'));
              } else {
                alert('Error: Failed to get selected rooms. Main content area missing.');
              }
              return;
            }
            
            // Keep track of the already selected rooms
            const currentlySelectedRooms = selectedResult.selectedRooms || [];
            
            // If there are no selected rooms yet, simply show the room manager
            if (currentlySelectedRooms.length === 0) {
              hideDashboardLoading(); // Hide global overlay since we are redirecting
              // showRoomManager will handle its own loading state for fileContent
              showRoomManager(); 
              return;
            }
            
            // Keep the same loading state we set earlier - don't change it

            google.script.run
              .withSuccessHandler(function(result) {
                hideDashboardLoading();
                if (mainContentContainer) {
                    if (result.success) {
                        // Don't use renderUIState - just proceed to item update which will replace the content
                        showItemUpdateInDashboard(true); // Pass true to prevent changing the loading message
                    } else {
                        renderUIState(mainContentContainer, 'error', '<strong>Error:</strong> ' + (result.error || 'Failed to load items data'));
                    }
                } else {
                     alert('Error loading items data. Main content area missing.');
                }
              })
              .withFailureHandler(function(error) {
                hideDashboardLoading();
                if (mainContentContainer) {
                    renderUIState(mainContentContainer, 'error', '<strong>Error:</strong> ' + (error.error || error.message || error.toString()));
                } else {
                     alert('Error loading items data. Main content area missing.');
                }
              })
              .getItemUpdateContentForDashboard();
          })
          .withFailureHandler(function(error) {
            hideDashboardLoading();
            if (mainContentContainer) {
                renderUIState(mainContentContainer, 'error', '<strong>Error:</strong> ' + (error.error || error.message || error.toString()));
            } else {
                 alert('Error loading items management. Main content area missing.');
            }
          })
          .getSelectedRooms();
      }

      // New function to show the item update interface in the dashboard
      function showItemUpdateInDashboard(keepLoadingState = false) {
        // Store the original project name if not already stored
        const projectNameElement = document.getElementById('projectName');
        if (projectNameElement && !window.originalProjectName) {
          window.originalProjectName = projectNameElement.innerText;
        }
        
        // Update the page title
        if (projectNameElement) {
          projectNameElement.innerText = 'Manage Items';
        }
        
        const mainContentContainer = document.getElementById('mainContent');
        
        // Get the sheet ID from the project details modal
        const dialog = document.querySelector('.app-container');
        const sheetId = dialog ? dialog.getAttribute('data-sheet-id') : null;
        
        console.log('showItemUpdateInDashboard: found sheetId:', sheetId);
        
        // Only proceed if we have a sheetId
        if (!sheetId) {
          if (mainContentContainer) {
            renderUIState(mainContentContainer, 'error', '<strong>Error:</strong> No sheet ID found. Unable to load items.');
          }
          return;
        }
        
        // Show global loading overlay (if desired) 
        showDashboardLoading('Loading items data...'); 
        
        // Set loading state for the specific container only if not already set
        if (mainContentContainer && !keepLoadingState) {
            // Use the same consistent loading message
            mainContentContainer.innerHTML = `
              <div class="loading-state">
                <div class="spinner"></div>
                <p>Loading items...</p>
              </div>`;
        }
        
        // Call server to get item data
        google.script.run
          .withSuccessHandler(function(data) {
            hideDashboardLoading(); // Hide global overlay
            if (mainContentContainer) {
                // Don't call renderUIState, just directly replace the content
                renderItemUpdateInterface(data); 
            } else {
                console.error('showItemUpdateInDashboard: fileContent container not found for success handler.');
            }
          })
          .withFailureHandler(function(error) {
            hideDashboardLoading(); // Hide global overlay
            if (mainContentContainer) {
                renderUIState(mainContentContainer, 'error', '<strong>Error:</strong> ' + (error.error || error.message || error.toString()));
            } else {
                console.error('showItemUpdateInDashboard: fileContent container not found for error handler.');
                // Optionally, show a generic alert if main container is missing
                alert('Error loading item data. Main content area missing.');
            }
          })
          .getItemUpdateContentForDashboard(sheetId);
      }
      
      /**
       * Sanitizes a single item object for saving.
       * Ensures quantity, budget values are correct, recalculates totals,
       * and removes temporary properties.
       * @param {object} item - The item object to sanitize.
       * @return {object} The sanitized item object.
       */
      function _sanitizeItemForSave(item) {
        // Create a deep copy to avoid modifying the original
        const sanitizedItem = JSON.parse(JSON.stringify(item));
        
        // Ensure quantity is at least 1
        sanitizedItem.quantity = Math.max(1, parseInt(sanitizedItem.quantity) || 1);
        
        // Convert budget values to numbers or null
        sanitizedItem.lowBudget = sanitizedItem.lowBudget !== null && sanitizedItem.lowBudget !== '' && !isNaN(sanitizedItem.lowBudget) 
          ? parseFloat(sanitizedItem.lowBudget) 
          : null;
          
        sanitizedItem.highBudget = sanitizedItem.highBudget !== null && sanitizedItem.highBudget !== '' && !isNaN(sanitizedItem.highBudget) 
          ? parseFloat(sanitizedItem.highBudget) 
          : null;
        
        // Recalculate totals
        sanitizedItem.lowBudgetTotal = sanitizedItem.lowBudget !== null 
          ? sanitizedItem.lowBudget * sanitizedItem.quantity 
          : null;
          
        sanitizedItem.highBudgetTotal = sanitizedItem.highBudget !== null 
          ? sanitizedItem.highBudget * sanitizedItem.quantity 
          : null;
          
        // Remove temporary properties that shouldn't be saved
        if ('isNew' in sanitizedItem) delete sanitizedItem.isNew;
        if ('id' in sanitizedItem && sanitizedItem.id.toString().startsWith('new_')) delete sanitizedItem.id;
        
        return sanitizedItem;
      }

      /**
       * Prepares the list of all items from dashboardItemData.
       * Rebuilds the main items array from itemsByRoom if necessary,
       * and ensures each item has a 'room' property.
       * @param {object} dashboardItemData - The global dashboard data object.
       * @return {object[]} The prepared array of all item objects.
       */
      function _getAndPrepareDashboardItems(dashboardItemData) {
        let allItems = [];
        let hasItemsWithoutRoom = false; // To track if any fixes were made

        // Check if we need to rebuild the main items array
        if (dashboardItemData.items && dashboardItemData.items.length === 0 && 
            dashboardItemData.itemsByRoom && Object.keys(dashboardItemData.itemsByRoom).length > 0) {
          console.log('Main items array is empty but room items exist - rebuilding');
          Object.keys(dashboardItemData.itemsByRoom).forEach(room => {
            const roomItems = dashboardItemData.itemsByRoom[room];
            if (Array.isArray(roomItems)) {
              roomItems.forEach(item => {
                // Ensure room property is set during rebuild
                if (!item.room) {
                  item.room = room;
                  hasItemsWithoutRoom = true; // Mark that a fix occurred
                }
                allItems.push(item);
              });
            }
          });
          
          if (hasItemsWithoutRoom) {
            console.log('Fixed items missing room property during rebuild');
          }
          // Update the main items array in dashboardItemData as well for consistency
          dashboardItemData.items = allItems;
          console.log('Rebuilt main items array with', allItems.length, 'items');
        } else {
          // If not rebuilding, use the existing items array, but still ensure deep copy for modification safety
          allItems = dashboardItemData.items ? JSON.parse(JSON.stringify(dashboardItemData.items)) : [];
        }

        // Pre-process: ensure all items (whether rebuilt or original) have a valid room property
        // This also catches cases where items might have been added without a room directly to dashboardItemData.items
        let fixedMissingRoomProperty = false;
        allItems.forEach(item => {
          if (!item.room && item._roomName) {
            item.room = item._roomName; // Use backup field if available
            fixedMissingRoomProperty = true;
          }
        });
        if (fixedMissingRoomProperty) {
            console.log('Fixed items with missing room property using _roomName backup.');
        }
        return allItems;
      }

      /**
       * Filters an array of items to include only those valid for saving.
       * A valid item must have a room and a non-empty item name.
       * @param {object[]} items - The array of item objects to filter.
       * @return {object[]} A new array containing only valid items.
       */
      function _filterValidItemsToSave(items) {
        if (!Array.isArray(items)) return [];
        return items.filter(item => {
          const isValid = item && item.room && item.item && item.item.trim() !== '';
          if (!isValid) {
            console.log('Filtering out invalid item during save process:', item);
          }
          return isValid;
        });
      }

      // Save all items data to the server
      function saveAllItemsFromDashboard() {
        console.log('Starting save process for all items');
        
        showDashboardLoading('Saving items...');
        const mainContentContainer = document.getElementById('mainContent');
        if (mainContentContainer) {
            // Use the specific loading state requested by the user
            mainContentContainer.innerHTML = `
              <div class="loading-state">
                <div class="spinner"></div>
                <p>Saving items...</p>
              </div>`;
        }
        
        // Sort dashboardItemData.items by room name, then by item name BEFORE sending to server
        if (Array.isArray(dashboardItemData.items)) {
            dashboardItemData.items.sort((a, b) => {
                const roomA = String(a.room || '').toUpperCase();
                const roomB = String(b.room || '').toUpperCase();
                if (roomA === roomB) {
                    const itemAname = String(a.item || '').toUpperCase();
                    const itemBname = String(b.item || '').toUpperCase();
                    return itemAname.localeCompare(itemBname);
                }
                return roomA.localeCompare(roomB);
            });
            console.log('dashboardItemData.items sorted by room and item name BEFORE creating itemsFromUIData.');
        }
        
        // Rebuild itemsByRoom from the sorted items to ensure internal consistency if needed elsewhere before save response
        // Though itemsFromUIData is the primary data source for the save call.
        dashboardItemData.itemsByRoom = {};
        if (Array.isArray(dashboardItemData.items)) {
            dashboardItemData.items.forEach(item => {
                const roomKey = item.room || 'Unassigned'; 
                if (!dashboardItemData.itemsByRoom[roomKey]) {
                    dashboardItemData.itemsByRoom[roomKey] = [];
                }
                dashboardItemData.itemsByRoom[roomKey].push(item);
            });
        }

        const itemsFromUIData = dashboardItemData.items ? [...dashboardItemData.items] : [];
        console.log('Items collected from dashboardItemData.items for saving (should be sorted):', itemsFromUIData.length);
        
        if (itemsFromUIData.length === 0) {
          hideDashboardLoading();
          showDashboardStatusMessage('No items to save.', false, 'main');
          return; 
        }

        google.script.run
          .withSuccessHandler(function(result) {
            console.log('Server response for saveItemsToMasterList operation:', result);
            hideDashboardLoading();
            
            if (result.success) {
              showDashboardStatusMessage(`Successfully saved ${result.count} items. Closing...`, false, 'main');
              
              // Update and sort dashboardItemData.items from server response (confirms server state)
              if (result.items) {
                dashboardItemData.items = result.items || [];
                if (Array.isArray(dashboardItemData.items)) {
                  dashboardItemData.items.sort((a, b) => {
                    const roomA = String(a.room || '').toUpperCase();
                    const roomB = String(b.room || '').toUpperCase();
                    if (roomA === roomB) {
                      const itemAname = String(a.item || '').toUpperCase();
                      const itemBname = String(b.item || '').toUpperCase();
                      return itemAname.localeCompare(itemBname);
                    }
                    return roomA.localeCompare(roomB);
                  });
                }
                // Rebuild itemsByRoom based on the newly sorted items from server.
                dashboardItemData.itemsByRoom = {};
                dashboardItemData.items.forEach(item => {
                  const roomKey = item.room || 'Unassigned'; 
                  if (!dashboardItemData.itemsByRoom[roomKey]) {
                    dashboardItemData.itemsByRoom[roomKey] = [];
                  }
                  dashboardItemData.itemsByRoom[roomKey].push(item);
                });
                console.log('dashboardItemData updated and sorted from server response.');
              }
              
              setTimeout(function() {
                google.script.host.close();
              }, 1500); 

            } else { // Save failed
              let errorMessage = 'Failed to save items.';
              if (result && result.error) {
                errorMessage = result.error;
              }
              if (result && result.backupSheetName) { 
                errorMessage += ` A backup was created: ${result.backupSheetName}`;
              }
              if (result && result.invalidItems && result.invalidItems.length > 0) {
                errorMessage += ` (${result.invalidItems.length} invalid items found). Check console for details.`;
                console.error('Invalid items reported by server:', result.invalidItems);
              }
              showDashboardStatusMessage(errorMessage, true, 'main');
              console.error('Save operation failed or returned error:', result);
            }
          })
          .withFailureHandler(function(error) {
            console.error('Client-side error during save operation:', error);
            hideDashboardLoading();
            showDashboardStatusMessage('Client Error: ' + (error.message || error), true, 'main');
          })
          .saveItemsToMasterList(itemsFromUIData); // Pass sorted items
      }

      // This function is now effectively replaced by the success handler logic within saveAllItemsFromDashboard
      // function updateItemIdsAfterSave(savedItemsByRoom) { ... } // Keep for reference or remove if fully replaced
      
      // Load dashboard when page opens
      document.addEventListener('DOMContentLoaded', function() {     
        initializeProjectDetailsSidebarInteractions();
      });

      /**
       * Sets the active button in the main content header.
       * @param {string} activeButtonId The ID of the button to set as active.
       */
      function setActiveMainContentButton(activeButtonId) {
        const headerButtons = document.querySelectorAll('#mainContentHeader .btn');
        console.log('headerButtons', headerButtons);

        // Determine if the "Select Items" button is currently active
        const selectItemsButton = document.getElementById('selectItemsBtn');
        const isItemSelectionActive = selectItemsButton && selectItemsButton.classList.contains('btn-active');

        // If item selection is active AND the new button is different, save draft
        if (isItemSelectionActive && activeButtonId !== 'selectItemsBtn') {
          console.log("[modal_scripts.js] setActiveMainContentButton: Navigating away from active 'Select Items' view. Attempting to save draft.");
          if (typeof window.handleSaveDraftItem === 'function') {
            window.handleSaveDraftItem();
          } else {
            console.warn("[modal_scripts.js] setActiveMainContentButton: handleSaveDraftItem function not found. Cannot save draft.");
          }
        }

        headerButtons.forEach(button => {
          button.classList.remove('btn-active');
        });

        const activeButton = document.getElementById(activeButtonId);
        if (activeButton) {
          console.log('activeButton', activeButton);
          activeButton.classList.add('btn-active');
        }

        // Update the visibility of the home sidebar button
        toggleCreateMasterListButtonVisibility();
      }

      // Functions for Project_Details_.html
      function loadProjectDetails() {
        // Show loading state
        showLoading(true);
        
        // Get projectId from the existing projectIdHolder element
        const projectIdElement = document.getElementById('projectIdHolder');
        const projectId = projectIdElement ? projectIdElement.getAttribute('data-project-id') : null;
        
        if (!projectId) {
          // If no projectId is available, get all projects and display the first one
          google.script.run
            .withSuccessHandler(function(result) {
              showLoading(false);
              
              if (!result.success) {
                showError(result.error || "Failed to load projects");
                return;
              }
              
              // If no projects found
              if (!result.projects || result.projects.length === 0) {
                showError('No projects found.');
                return;
              }
              
              // Store project data globally for sidebar access
              window.currentProject = result.projects[0];
              
              // Display the first project
              displayProjectDetails(result.projects[0]);
            })
            .withFailureHandler(function(error) {
              showLoading(false);
              showError('Error loading projects: ' + error);
            })
            .getProjects();
        } else {
          // If we have a projectId, get that specific project
          google.script.run
            .withSuccessHandler(function(result) {
              showLoading(false);
              
              if (!result.success) {
                showError(result.error || "Failed to load project");
                return;
              }
              
              // Store project data globally for sidebar access
              window.currentProject = result.project;
              
              // Display the project details
              displayProjectDetails(result.project);
            })
            .withFailureHandler(function(error) {
              showLoading(false);
              showError('Error loading project: ' + error);
            })
            .getProjectById(projectId);
        }
      }

      // Function to preview file content in the main area
      function showFilePreview(file) {
        // Store the original project name if not already stored
        const projectNameElement = document.getElementById('projectName');
        if (projectNameElement && !window.originalProjectName) {
          window.originalProjectName = projectNameElement.innerText;
        }
        
        // Update the page title
        if (projectNameElement) {
          projectNameElement.innerText = file.name;
        }
        
        // Show loading indicator in main content area
        const fileContent = document.getElementById('mainContent');
        renderUIState(fileContent, 'loading', 'Loading preview...');
        
        // Determine the content type
        if (file.embedUrl) {
          // Display the file using an iframe if it has an embed URL
          const iframe = document.createElement('iframe');
          iframe.style.width = '100%';
          iframe.style.height = '100%';
          iframe.style.border = 'none';
          
          iframe.onload = function() {
            renderUIState(fileContent, 'success'); // Clear loading/error
            fileContent.appendChild(iframe); // Add the loaded iframe
          };
          iframe.onerror = function() {
            const errorMessage = 'Unable to load file preview. <a href="' + file.url + '" target="_blank">Open in Google Drive</a> instead.';
            renderUIState(fileContent, 'error', errorMessage);
          };
          
          // Set iframe src after adding onload and error handlers to prevent race conditions
          iframe.src = file.embedUrl;

        } else if (file.thumbnailUrl) {
          // Show thumbnail for images
          renderUIState(fileContent, 'success'); // Clear loading state
          
          const imageContainer = document.createElement('div');
          imageContainer.style.padding = '20px';
          imageContainer.style.textAlign = 'center';
          
          const image = document.createElement('img');
          image.src = file.thumbnailUrl;
          image.style.maxWidth = '100%';
          image.style.maxHeight = '80vh';
          image.style.boxShadow = '0 2px 10px rgba(0,0,0,0.1)';
          
          const caption = document.createElement('p');
          caption.textContent = file.name;
          caption.style.marginTop = '10px';
          
          const openLink = document.createElement('a');
          openLink.href = file.url;
          openLink.target = '_blank';
          openLink.textContent = 'Open in Google Drive';
          openLink.className = 'btn';
          openLink.style.marginTop = '15px';
          openLink.style.display = 'inline-block';
          
          imageContainer.appendChild(image);
          imageContainer.appendChild(caption);
          imageContainer.appendChild(openLink);
          
          fileContent.innerHTML = '';
          fileContent.appendChild(imageContainer);
        } else {
          // Show a message that preview is not available
          renderUIState(fileContent, 'success'); // Clear loading state
          
          const noPreviewDiv = document.createElement('div');
          noPreviewDiv.className = 'empty-state';
          noPreviewDiv.style.padding = '20px';
          
          const noPreviewIcon = document.createElement('i');
          noPreviewIcon.className = 'material-icons';
          noPreviewIcon.textContent = 'visibility_off';
          noPreviewIcon.style.fontSize = '48px';
          noPreviewIcon.style.marginBottom = '15px';
          
          const noPreviewText = document.createElement('p');
          noPreviewText.textContent = 'Preview not available for this file type.';
          
          const openBtn = document.createElement('a');
          openBtn.href = file.url;
          openBtn.target = '_blank';
          openBtn.className = 'btn';
          openBtn.textContent = 'Open in Google Drive';
          openBtn.style.marginTop = '15px';
          openBtn.style.display = 'inline-block';
          
          noPreviewDiv.appendChild(noPreviewIcon);
          noPreviewDiv.appendChild(noPreviewText);
          noPreviewDiv.appendChild(openBtn);
          
          fileContent.appendChild(noPreviewDiv);
        }
      }

      // Function to show dashboard loading overlay
      function showDashboardLoading(message) {
        const loadingOverlay = document.getElementById('dashboardLoadingOverlay');
        const loadingMessage = document.getElementById('dashboardLoadingMessage');
        
        if (loadingMessage) {
          loadingMessage.textContent = message || 'Loading...';
        }
        
        if (loadingOverlay) {
          loadingOverlay.style.display = 'flex';
        }
      }
      
      // Function to hide dashboard loading overlay
      function hideDashboardLoading() {
        const loadingOverlay = document.getElementById('dashboardLoadingOverlay');
        
        if (loadingOverlay) {
          loadingOverlay.style.display = 'none';
        }
      }

      /**
       * Shows a status message in the dashboard.
       * @param {string} message - The message to display
       * @param {boolean} isError - Whether this is an error message
       * @param {string} location - Optional location ('main' or 'sidebar')
       */
      function showDashboardStatusMessage(message, isError = false, location = 'main') {
        console.log(`[showDashboardStatusMessage] Called with: message="${message}", isError=${isError}, location="${location}"`); // Log parameters

        // Hide any existing message after a delay
        if (window.statusMessageTimeout) {
          clearTimeout(window.statusMessageTimeout);
          window.statusMessageTimeout = null;
        }
        
        // Find the appropriate status container based on location
        const containerId = (location === 'sidebar') 
          ? 'sidebarStatusMessage' 
          : 'dashboardStatusMessage';
        console.log(`[showDashboardStatusMessage] Target container ID: "${containerId}" (location: "${location}")`); // Log target ID

        const statusContainer = document.getElementById(containerId);
          
        if (!statusContainer) {
          console.error(`[showDashboardStatusMessage] Status message container NOT FOUND for ID: "${containerId}" (location: "${location}")`); // Log if not found
          // Fallback to console.log if container is not found
          console.log(`${isError ? 'ERROR' : 'SUCCESS'}: ${message}`);
          return;
        } else {
          console.log(`[showDashboardStatusMessage] Status message container FOUND for ID: "${containerId}"`, statusContainer); // Log if found
        }
        
        // Update message content and style
        statusContainer.textContent = message;
        statusContainer.className = 'status-message ' + (isError ? 'error' : 'success');
        
        console.log(`[showDashboardStatusMessage] About to set display: block for "${containerId}"`); // Log before setting display
        statusContainer.style.display = 'block';
        
        // Auto-hide success messages after 5 seconds
        if (!isError) {
          window.statusMessageTimeout = setTimeout(() => {
            statusContainer.style.display = 'none';
          }, 5000);
        }
      }

      // Additional functions from scripts.js should be added here
      // ...
      
      // Initialize Project Details Page
      function initProjectDetailsPage(projectId) {
        // Get the modal element and check for sheetId
        const dialog = document.querySelector('.app-container');
        const sheetId = dialog ? dialog.getAttribute('data-sheet-id') : null;
        
        if (!sheetId) {
          console.error('Sheet ID not available for project', projectId);
          // Attempt to display error in a general page area if specific containers aren't available
          const errorDisplayArea = document.getElementById('mainContent') || document.body;
          renderUIState(errorDisplayArea, 'error', 'Project spreadsheet ID not available. Unable to load project details.');
          return;
        }
        
        // Setup containers for UI state rendering
        const summaryContainer = document.getElementById('projectSummaryActualContent');
        const roomsContainerParent = document.getElementById('rooms-content'); // Parent of the list
        let roomsListElement = roomsContainerParent ? roomsContainerParent.querySelector('.rooms-list') : null;

        // If roomsListElement doesn't exist, we might need to create it or have a fallback
        // For now, we proceed assuming it can be found or renderRoomsList will handle its absence.

        if (summaryContainer) {
          renderUIState(summaryContainer, 'loading', 'Loading project summary...');
        }
        
        // Load project summary passing the sheet ID
        google.script.run
          .withSuccessHandler(function(result) {
            if (!summaryContainer) return; // Should not happen if initial check passed
            
            if (!result.success) {
              renderUIState(summaryContainer, 'error', 'Error loading project summary: ' + (result.error || 'Unknown error'));
              return;
            }
            
            renderUIState(summaryContainer, 'success'); // Clear loading/error, ready for content
            
            // Update room count, item count, budget totals
            if (result.roomCount !== undefined) {
              const roomCountEl = document.getElementById('roomCount');
              if (roomCountEl) roomCountEl.textContent = result.roomCount;
            }
            
            if (result.itemCount !== undefined) {
              const itemCountEl = document.getElementById('itemCount');
              if (itemCountEl) itemCountEl.textContent = result.itemCount;
            }
            
            if (result.totalLowBudget !== undefined) {
              const lowBudgetEl = document.getElementById('lowBudgetTotal');
              if (lowBudgetEl) lowBudgetEl.textContent = formatCurrency(result.totalLowBudget);
            }
            
            if (result.totalHighBudget !== undefined) {
              const highBudgetEl = document.getElementById('highBudgetTotal');
              if (highBudgetEl) highBudgetEl.textContent = formatCurrency(result.totalHighBudget);
            }
            
            console.log('Project summary loaded successfully', result);
          })
          .withFailureHandler(function(error) {
            if (summaryContainer) {
              renderUIState(summaryContainer, 'error', 'Error loading project summary: ' + error.message || error.toString());
            }
          })
          .getProjectSummary(sheetId);

        // AT THE END of initProjectDetailsPage, call the new sidebar setup function:
        initializeProjectDetailsSidebarInteractions();
      }
      
      // Helper function to format currency
      function formatCurrency(value) {
        if (value === undefined || value === null) return '$0';
        return '$' + parseFloat(value).toLocaleString('en-US', {
          minimumFractionDigits: 0,
          maximumFractionDigits: 0
        });
      }
      
      // Function to render rooms list with checkboxes
      function renderRoomsList(rooms, selectedRooms, container) {
        if (!container) return;
        
        // Clear container (renderUIState will do this for 'empty' or 'success' before content is added)
        // container.innerHTML = ''; // No longer needed if renderUIState is used for empty state
        
        if (!rooms || rooms.length === 0) {
          renderUIState(container, 'empty', 'No rooms available');
          return;
        }

        // If we have rooms, clear any previous state (like 'empty') before adding new content.
        // The 'success' state with no message effectively clears the container.
        renderUIState(container, 'success');
        
        // Create room items
        rooms.forEach(room => {
          const isSelected = selectedRooms.includes(room);
          
          const roomItem = document.createElement('div');
          roomItem.className = 'room-item';
          
          // Create checkbox for room selection
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.id = 'room-' + room.replace(/\s+/g, '-').toLowerCase();
          checkbox.className = 'room-checkbox';
          checkbox.checked = isSelected;
          checkbox.setAttribute('data-room', room);
          
          // Create label for the checkbox
          const label = document.createElement('label');
          label.htmlFor = checkbox.id;
          label.textContent = room;
          
          // Append to room item
          roomItem.appendChild(checkbox);
          roomItem.appendChild(label);
          
          // Append to container
          container.appendChild(roomItem);
        });
        
        // Add save button
        // const saveButton = document.createElement('button');
        // saveButton.className = 'btn room-save-btn';
        // saveButton.innerHTML = '<i class="material-icons">save</i> Save Selection';
        // saveButton.onclick = function() {
        //   saveRoomsSelection(container);
        // };
        
        //container.appendChild(saveButton);
      }
      
      // Function to save selected rooms
      function saveRoomsSelection(container) {
        const containerName = container || document.getElementById('sidebarRoomList');
        const checkboxes = containerName.querySelectorAll('input[type="checkbox"]:checked');
        const selectedRooms = Array.from(checkboxes).map(cb => cb.getAttribute('data-room'));
        
        if (selectedRooms.length === 0) {
          alert('Please select at least one room');
          return;
        }
        
        // Show loading state
        const saveBtn = containerName.querySelector('.room-save-btn');
        if (saveBtn) {
          // Store original HTML, assuming it's <i class="material-icons">save</i> Save Selection
          // This could be made more robust by storing on the element or if it varies.
          const originalButtonHtml = '<i class="material-icons">save</i> Save Selection';
          const loadingButtonHtml = '<i class="material-icons rotating">sync</i> Saving...';
          _setButtonLoadingState(saveBtn, true, loadingButtonHtml, originalButtonHtml);
        }
        
        // Save selected rooms
        google.script.run
          .withSuccessHandler(function(result) {
            if (saveBtn) {
              const originalButtonHtml = '<i class="material-icons">save</i> Save Selection';
              _setButtonLoadingState(saveBtn, false, '', originalButtonHtml);
            }
            
            if (!result.success) {
              alert('Error saving rooms: ' + (result.error || 'Unknown error'));
              return;
            }
            
            alert('Rooms saved successfully');
          })
          .withFailureHandler(function(error) {
            if (saveBtn) {
              const originalButtonHtml = '<i class="material-icons">save</i> Save Selection';
              _setButtonLoadingState(saveBtn, false, '', originalButtonHtml);
            }
            
            alert('Error saving rooms: ' + error);
          })
          .saveSelectedRoomsCore(selectedRooms);
      }

      // Assuming handleBudgetError function exists or will be created:
      function handleBudgetError(error) {
        const budgetDisplay = document.getElementById('budgetSummaryDisplay');
        if (!budgetDisplay) return;
        let errorMessage = 'Error loading budget data.';
        if (typeof error === 'string') {
          errorMessage = error;
        } else if (error && error.message) {
          errorMessage = error.message;
        } else if (error && error.details) {
          errorMessage = error.details;
        }
        renderUIState(budgetDisplay, 'error', errorMessage);
        console.error('Budget Data Error:', error);
      }

      /**
       * Initializes sidebar interactions (toggle and tabs) specifically for the Project Details modal.
       * This should be called after the Project Details modal content is loaded.
       */
      function initializeProjectDetailsSidebarInteractions() {
        console.log('Initializing Project Details sidebar interactions...');
        const dialog = document.querySelector('.app-container');
        if (!dialog) {
          console.error('Project Details Modal not found. Cannot initialize sidebar interactions.');
          return;
        }

        const sidebar = dialog.querySelector('.sidebar'); // Scope to within the modal
        const sidebarToggle = dialog.querySelector('#sidebarToggle'); // Scope to within the modal

        // Main Sidebar Toggle Logic (scoped to this modal's sidebar)
        if (sidebarToggle && sidebar) {
          // Set initial state of the toggle button based on sidebar collapsed state
          const toggleIcon = sidebarToggle.querySelector('.material-icons');
          if (toggleIcon) {
            // Set correct initial icon based on sidebar state
            if (sidebar.classList.contains('collapsed')) {
              toggleIcon.textContent = 'chevron_right';
              sidebarToggle.classList.add('collapsed');
            } else {
              toggleIcon.textContent = 'chevron_left';
              sidebarToggle.classList.remove('collapsed');
            }
          }
          
          // Set up toggle button click event
          sidebarToggle.addEventListener('click', function() {
            sidebar.classList.toggle('collapsed');
            const toggleIcon = sidebarToggle.querySelector('.material-icons');
            
            if (toggleIcon) {
              if (sidebar.classList.contains('collapsed')) {
                toggleIcon.textContent = 'chevron_right';
                sidebarToggle.classList.add('collapsed');
              } else {
                toggleIcon.textContent = 'chevron_left';
                sidebarToggle.classList.remove('collapsed');
              }
            }
          });
        } else {
          console.warn('Sidebar toggle or sidebar container not found within #projectDetailsModal.');
        }

        // Sidebar Tab Logic using Event Delegation (scoped to this modal's sidebar)
        if (sidebar) {
          const sidebarTabsContainer = sidebar.querySelector('.sidebar-tabs'); // Assuming tabs are within .sidebar-tabs
          if (sidebarTabsContainer) {
            sidebarTabsContainer.addEventListener('click', function(event) {
              const clickedTab = event.target.closest('.sidebar-tab');
              if (!clickedTab) return; // Click was not on a tab or its child

              // Remove active class from all tabs and contents within this modal
              // dialog.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
              // dialog.querySelectorAll('.sidebar-content').forEach(c => c.classList.remove('active'));
              
              // Add active class to clicked tab
              // clickedTab.classList.add('active');
              
              // Show the corresponding content
              const tabName = clickedTab.getAttribute('data-tab');
              const contentElement = dialog.querySelector(`#${tabName}-content`);
              if (contentElement) {
                // contentElement.classList.add('active');
                
                // Load specific content based on tab
                if (tabName === 'home') {
                  // Display project details in the home tab sidebar
                  updateHomeSidebarContent();
                  if (typeof showWelcomeScreen === 'function') showWelcomeScreen(); else console.error('showWelcomeScreen function not found');
                } else if (tabName === 'rooms') {
                  if (typeof showRoomManager === 'function') showRoomManager('main'); else console.error('showRoomManager function not found');
                } else if (tabName === 'roomCategories') { // UPDATED LINE
                  if (typeof showRoomCategoriesMain === 'function') showRoomCategoriesMain(); else console.error('showRoomCategoriesMain function not found for sidebar click'); // UPDATED LINE
                } else if (tabName === 'folders') {
                  if (typeof loadFolders === 'function') loadFolders('sidebar'); else console.error('loadFolders function not found');
                } else if (tabName === 'tasks') {
                  if (typeof loadAsanaTasks === 'function') loadAsanaTasks(); else console.error('loadAsanaTasks function not found');
                } else if (tabName === 'budget') {
                  // Show loading state for budget before fetching
                  const budgetDisplay = document.getElementById('budgetSummaryDisplay');
                  // Small delay to ensure loading state is visible, then loadBudgetData will set its own loading state.
                  setTimeout(() => {
                    if (typeof loadBudgetData === 'function') loadBudgetData();
                    else console.error('loadBudgetData function not found');
                  }, 10);
                } // Add other tab-specific loading functions here if needed
              }
              
              // If sidebar is collapsed, expand it, UNLESS it's the items tab
              if (sidebar.classList.contains('collapsed') && tabName !== 'items') {
                sidebar.classList.remove('collapsed');
                if (sidebarToggle) {
                  const toggleIcon = sidebarToggle.querySelector('.material-icons');
                  if (toggleIcon) toggleIcon.textContent = 'chevron_left';
                  sidebarToggle.classList.remove('collapsed');
                }
              }
            });

            // Initially select the home tab and update its content
            if (sidebar.querySelector('.sidebar-tab[data-tab="home"].active')) {
              updateHomeSidebarContent();
            }
          } else {
            console.warn('.sidebar-tabs container not found within #projectDetailsModal .sidebar');
          }
        } else {
            console.warn('.sidebar container not found within #projectDetailsModal for tab delegation.');
        }
        
        // We'll handle adding the Select Items button when the rooms tab is activated
      }

      /**
       * Updates the home tab sidebar content with project details
       * @param {boolean} [isFullRender=true] - Whether to do a full render or just update dynamic parts.
       */
      function updateHomeSidebarContent(isFullRender = true) {
        const dialog = document.querySelector('.app-container');
        if (!dialog) {
          console.error('updateHomeSidebarContent: Dialog container not found.');
          return;
        }

        const sheetId = dialog.getAttribute('data-sheet-id'); // Main spreadsheet ID
        const homeSidebarContent = dialog.querySelector('#home-content .sidebar-body');

        if (!homeSidebarContent) {
          console.error('Home sidebar content element not found');
          return;
        }

        if (isFullRender) {
          console.log('Rendering simplified home sidebar view (full render).');
          const homeViewHTML = `
          <div class="project-info-item">
            <label for="sidebarProjectNameInput">Project Name:</label>
            <div class="input-with-button">
              <input type="text" id="sidebarProjectNameInput" class="sidebar-input" placeholder="Enter project name...">
              <button id="saveSidebarProjectNameBtn" class="btn btn-small" onclick="saveProjectName()">
                <i class="material-icons">save</i> Save
              </button>
            </div>
            <div id="projectNameStatus" class="status-message mini" style="display:none; margin-top: 5px;"></div>
          </div>
          <div id="homeSelectedRoomsListContainer" style="margin-top: 10px;">
             <div class="loading-state mini">
               <div class="spinner small"></div>
               <p>Loading selected rooms...</p>
             </div>
          </div>
        `;
          homeSidebarContent.innerHTML = homeViewHTML;
          loadProjectName(); // Load project name from ScriptProperties
        }

        // This part runs for both full render and partial update
        const selectedRoomsContainerId = 'homeSelectedRoomsListContainer'; 
        const selectedRoomsContainer = homeSidebarContent.querySelector('#' + selectedRoomsContainerId);

        if (selectedRoomsContainer) {
          // For partial render (isFullRender = false), we will not show a loading state here.
          // renderSelectedRoomsInHomeSidebar will directly update the content.
          // If isFullRender is true, the loading state is already part of homeViewHTML for the initial load.

          if (sheetId) {
            google.script.run
              .withSuccessHandler(renderSelectedRoomsInHomeSidebar) 
              .withFailureHandler(handleSelectedRoomsError)       
              .getSelectedRooms(sheetId);
          } else {
            // Still use renderUIState for the empty/error case if sheetId is missing.
            renderUIState(selectedRoomsContainerId, 'empty', 'Sheet ID missing, cannot load rooms.');
            console.warn('Home sidebar: Main sheet ID not available for fetching selected rooms.');
          }
        } else {
          console.error(`updateHomeSidebarContent: Container #${selectedRoomsContainerId} not found.`);
        }

        const homeContentTab = homeSidebarContent.parentElement;

        // Check if the button already exists within the stable parent (homeContentTab) before creating and appending it
        if (homeContentTab && !homeContentTab.querySelector('#createMasterItemListBtnSidebar')) {
          const homeActionsContainer = document.createElement('div');
          homeActionsContainer.className = 'sidebar-action-buttons'; // Use existing class for styling
          homeActionsContainer.style.marginTop = '20px'; // Add some top margin

          const createMasterListButton = document.createElement('button');
          createMasterListButton.id = 'createMasterItemListBtnSidebar';
          createMasterListButton.className = 'btn btn-primary'; // Use primary button styling
          createMasterListButton.style.width = '100%'; // Make button full width
          createMasterListButton.addEventListener('click', saveSelectedItemsFromDashboard);
          
          const createIcon = document.createElement('i');
          createIcon.className = 'material-icons';
          createIcon.textContent = 'add_circle_outline'; // Changed icon to reflect creation
          createIcon.style.marginRight = '8px';
          
          createMasterListButton.appendChild(createIcon);
          createMasterListButton.appendChild(document.createTextNode('Create Master Item List'));
          
          homeActionsContainer.appendChild(createMasterListButton);
          
          // Append to the parent of sidebar-body (which is #home-content)
          // homeContentTab is already defined above
          if (homeContentTab) {
              homeContentTab.appendChild(homeActionsContainer);
          } else {
              // This else block might be less likely to be hit if homeSidebarContent always has a parent,
              // but kept for safety if homeSidebarContent could be a root in some case.
              console.error('Could not find parent container for home sidebar action buttons. Appending to sidebar-body as fallback.');
              homeSidebarContent.appendChild(homeActionsContainer); // Fallback
          }
        } else if (!homeContentTab) {
            console.error('#home-content (parent of sidebar-body) not found. Cannot add Create Master Item List button.');
        }

        // Set initial visibility state for the button
        toggleCreateMasterListButtonVisibility();
      }

      /**
       * Loads the project name from ScriptProperties.
       */
      function loadProjectName() {
        const inputField = document.getElementById('sidebarProjectNameInput');
        const statusDiv = document.getElementById('projectNameStatus');
        if (!inputField || !statusDiv) {
            console.error("Project name input or status div not found for loading.");
            return;
        }
        statusDiv.textContent = 'Loading...';
        statusDiv.className = 'status-message mini loading';
        statusDiv.style.display = 'block';

        google.script.run
            .withSuccessHandler(function(name) {
                displayProjectName(name);
                statusDiv.style.display = 'none';
            })
            .withFailureHandler(function(error) {
                handleProjectNameLoadError(error);
            })
            .getProjectNameFromProperties(); // You'll need to create this server-side
      }

      /**
       * Displays the project name in the input field.
       * @param {string} name - The project name.
       */
      function displayProjectName(name) {
        const projectNameInput = document.getElementById('sidebarProjectNameInput');
        if (projectNameInput) {
          projectNameInput.value = name || '';
        }

        // Always update window.originalProjectName to the latest valid name or a default
        window.originalProjectName = name && name.trim() !== '' ? name.trim() : 'Project Dashboard';

        // Update the main header if it's not a specific view title
        const mainProjectNameHeader = document.getElementById('projectName');
        if (mainProjectNameHeader) {
            const currentHeaderText = mainProjectNameHeader.textContent;
            const specificViewTitles = ['Room Manager', 'Manage Items', 'Select Items']; // Add any other specific view titles here
            if (!specificViewTitles.includes(currentHeaderText)) {
                mainProjectNameHeader.textContent = window.originalProjectName;
                console.log('displayProjectName updated main header to:', window.originalProjectName);
            }
        }
      }

      /**
       * Handles errors when loading the project name.
       * @param {object|string} error - The error object or message.
       */
      function handleProjectNameLoadError(error) {
        const statusDiv = document.getElementById('projectNameStatus');
        if (statusDiv) {
            statusDiv.textContent = 'Error loading name.';
            statusDiv.className = 'status-message mini error';
            statusDiv.style.display = 'block';
        }
        console.error('Error loading project name:', error);
      }

      /**
       * Saves the project name to ScriptProperties.
       */
      function saveProjectName() {
        const projectNameInput = document.getElementById('sidebarProjectNameInput');
        const statusDiv = document.getElementById('projectNameStatus');
        const saveButton = document.getElementById('saveSidebarProjectNameBtn');

        if (!projectNameInput || !statusDiv || !saveButton) {
            console.error("Project name input, status div, or save button not found.");
            alert("Error: UI components for saving project name are missing.");
            return;
        }

        const newName = projectNameInput.value.trim();
        if (!newName) {
          statusDiv.textContent = 'Project name cannot be empty.';
          statusDiv.className = 'status-message mini error';
          statusDiv.style.display = 'block';
          setTimeout(() => { statusDiv.style.display = 'none'; }, 3000);
          return;
        }

        const originalButtonHtml = saveButton.innerHTML;
        saveButton.innerHTML = '<i class="material-icons rotating">sync</i> Saving...';
        saveButton.disabled = true;
        statusDiv.textContent = 'Saving...';
        statusDiv.className = 'status-message mini loading';
        statusDiv.style.display = 'block';

        google.script.run
            .withSuccessHandler(function(savedName) {
                saveButton.innerHTML = originalButtonHtml;
                saveButton.disabled = false;
                statusDiv.textContent = 'Project name saved!';
                statusDiv.className = 'status-message mini success';
                displayProjectName(savedName); // Update display with the (potentially processed) saved name
                
                // Update window.originalProjectName to the new saved name so welcome screen reset is correct
                window.originalProjectName = savedName || 'Project Dashboard';

                setTimeout(() => { statusDiv.style.display = 'none'; }, 3000);
            })
            .withFailureHandler(function(error) {
                saveButton.innerHTML = originalButtonHtml;
                saveButton.disabled = false;
                statusDiv.textContent = 'Error saving name.';
                statusDiv.className = 'status-message mini error';
                console.error('Error saving project name:', error);
                setTimeout(() => { statusDiv.style.display = 'none'; }, 5000);
            })
            .saveProjectNameToProperties(newName); // You'll need to create this server-side
      }

      /**
       * Copies the given text to the clipboard and provides visual feedback.
       * @param {string} textToCopy - The text to copy.
       * @param {HTMLElement} element - The clicked HTML element for visual feedback.
       */
      function copyEmailToClipboard(textToCopy, element) {
        navigator.clipboard.writeText(textToCopy).then(function() {
          // Success feedback
          const originalText = element.textContent;
          element.textContent = 'Copied!';
          element.classList.add('copied');
          setTimeout(function() {
            element.textContent = originalText;
            element.classList.remove('copied');
          }, 1500); // Revert after 1.5 seconds
        }).catch(function(err) {
          // Error feedback
          console.error('Failed to copy email: ', err);
          const originalText = element.textContent;
          element.textContent = 'Copy Failed'; 
          element.classList.add('copy-failed');
          setTimeout(function() {
            element.textContent = originalText;
            element.classList.remove('copy-failed');
          }, 1500);
        });
      }

      // Function to load room data into the sidebar
      function loadSidebarRoomManager() {
        // // Show a loading indicator in the sidebar room content
        // document.getElementById('sidebarRoomManagerContent').innerHTML = `
        //   <div class="loading">
        //     <i class="material-icons">sync</i> Loading rooms...
        //   </div>
        // `;
        
        // Fallback to no sheetId if not available
        google.script.run
          .withSuccessHandler(function(result) {
            renderRoomManager(result, document.getElementById('sidebarRoomManagerContent'), 'sidebar');
          })
          .withFailureHandler(function(error) {
            document.getElementById('sidebarRoomManagerContent').innerHTML = `
              <div class="error-box" style="margin: 10px;">
                <strong>Error:</strong> ${error.error || error}
              </div>`;
          })
          .getRoomsForDashboard();
      }
      
      /**
       * Renders the room manager UI in the specified target container and location.
       * @param {object} result - The data result from getRoomsForDashboard.
       * @param {HTMLElement} targetContainer - The DOM element to render into.
       * @param {string} location - 'sidebar' or 'main'.
       */
      function renderRoomManager(result, targetContainer, location) {
        console.log(`renderRoomManager called for ${location}. Target: ${targetContainer ? targetContainer.id : 'NULL'}. Result success: ${result ? result.success : 'N/A'}`); // ADD THIS LOG

        if (!targetContainer) {
            console.error(`renderRoomManager: Target container for ${location} is null or undefined.`);
            // Optionally, alert or show a global error if targetContainer is critical and missing
            return;
        }

        if (!result || !result.success) {
          const errorMsg = result && result.error ? result.error : `Failed to load rooms or invalid data for ${location}.`;
          console.error(`renderRoomManager (${location}): Invalid result or success=false. Error: ${errorMsg}. Full result:`, JSON.stringify(result, null, 2)); // ADD THIS LOG
          renderUIState(targetContainer, 'error', errorMsg);
          return;
        }

        console.log('renderRoomManager: result:', result);
        
        const rooms = result.rooms || [];
        const selectedRooms = result.selectedRooms || [];
        // const capLocation = capitalizeFirstLetter(location); // Not needed if not generating button/input IDs here

        // Dynamic IDs for core elements rendered by this function
        const roomListId = `${location}RoomList`; 
        const statusMessageId = `${location}StatusMessage`;
        
        // Basic structure for the room list and a status message placeholder
        if (location === 'main') {
          targetContainer.innerHTML = `
            <div class="main-content-container">
              <div id="${roomListId}" class="room-checklist">
                <!-- Room items will be populated here -->
              </div>
            </div>
            <div id="${statusMessageId}" class="status-message" style="display: none; margin-top: 10px;"></div>
          `;
        } else {
          targetContainer.innerHTML = `
            <div id="${roomListId}" class="room-checklist">
              <!-- Room items will be populated here -->
            </div>
            <div id="${statusMessageId}" class="status-message" style="display: none; margin-top: 10px;"></div>
          `;
        }
        
        const roomListContainer = document.getElementById(roomListId);
        
        if (!roomListContainer){
            console.error(`renderRoomManager: Could not find room list container with ID ${roomListId}`);
            renderUIState(targetContainer, 'error', 'Internal error: UI components missing.');
            return;
        }

        if (rooms.length === 0) {
          // Use renderUIState for empty state within the list container for better styling, or simple HTML as before.
          roomListContainer.innerHTML = `
            <div class="empty-state" style="padding: 15px 0;">
              <i class="material-icons">meeting_room</i>
              <p>No rooms found. If running in main content, add a room using controls below. If in sidebar, check project setup.</p>
            </div>
          `;
        } else {
          let roomListHtml = `<div class="room-category-header" style="padding-bottom: 5px; margin-bottom: 10px; border-bottom: 1px solid #eee; font-weight: 500;">Available Rooms</div>`;
          rooms.forEach((room, index) => {
            const isChecked = selectedRooms.includes(room) ? 'checked' : '';
            // Ensure checkbox IDs are unique if this function is called for different locations simultaneously
            // (though typically one instance of room manager would be active).
            const checkboxId = `${location}-room-${index.toString().replace(/\s+/g, '-')}`;
            roomListHtml += `
              <div class="room-checklist-item">
                <input type="checkbox" id="${checkboxId}" data-room="${room}" ${isChecked} class="room-checkbox">
                <label for="${checkboxId}" class="room-checklist-item-label">${room}</label>
              </div>
            `;
          });
          roomListContainer.innerHTML = roomListHtml;

          // Add debounced auto-save functionality
          const debouncedSave = debounce(() => {
            saveRoomsFromDashboard(location, true); // Pass true for isAutoSave
          }, 750); // 750ms debounce delay

          const checkboxes = roomListContainer.querySelectorAll('.room-checkbox');
          checkboxes.forEach(checkbox => {
            checkbox.addEventListener('change', () => {
              console.log(`Checkbox for room '${checkbox.getAttribute('data-room')}' in ${location} changed. Triggering debounced save.`);
              debouncedSave();
            });
          });
        }
        // Note: "Add New Room" and "Save" buttons are explicitly NOT part of this function's direct output as per user instruction.
        // They are expected to be part of the calling page structure or added by other functions if needed for a specific location.
      }
      
      // Debounce function to prevent multiple rapid saves
      const debounce = (func, delay) => {
        let debounceTimer;
        return function() {
          const context = this;
          const args = arguments;
          clearTimeout(debounceTimer);
          debounceTimer = setTimeout(() => func.apply(context, args), delay);
        };
      };
      
      // Function to show the saving overlay
      function showRoomsSavingOverlay(show = true) {
        const overlay = document.getElementById('roomsSavingOverlay');
        if (!overlay) return;
        
        overlay.style.display = show ? 'flex' : 'none';
        
        // Disable all checkboxes during save
        const checkboxes = document.querySelectorAll('#sidebarRoomList .room-checkbox'); // This might need to be generalized if autoSaveRooms is used outside sidebar
        checkboxes.forEach(checkbox => {
          checkbox.disabled = show;
        });
      }
      
      // Auto-save function that triggers when checkboxes change
      function autoSaveRooms() {
        // Collect all selected rooms
        const checkboxes = document.querySelectorAll('#sidebarRoomList .room-checkbox');
        const selectedRooms = Array.from(checkboxes)
          .filter(checkbox => checkbox.checked)
          .map(checkbox => checkbox.getAttribute('data-room'));
        
        // Show saving overlay and disable checkboxes
        showRoomsSavingOverlay(true);
        
        // Call server to save selected rooms
        google.script.run
          .withSuccessHandler(function(result) {
            // Hide saving overlay and re-enable checkboxes
            showRoomsSavingOverlay(false);
            
            if (result.success) {
              showSidebarStatusMessage('Rooms saved');
            } else {
              showSidebarStatusMessage('Error: ' + (result.error || 'Failed to save rooms'), true);
                }
              })
              .withFailureHandler(function(error) {
            // Hide saving overlay and re-enable checkboxes
            showRoomsSavingOverlay(false);
            showSidebarStatusMessage('Error: ' + error, true);
          })
          .saveSelectedRoomsCore(selectedRooms);
      }
      
      // Create a debounced version of autoSaveRooms to prevent saving on every checkbox change
      const debouncedAutoSaveRooms = debounce(autoSaveRooms, 500);

      // Function to add a new room from the sidebar
      function addNewRoom(location) {
        const newRoomName = document.getElementById(`newRoomName${capitalizeFirstLetter(location)}`).value.trim();
        
        if (!newRoomName) {
          showDashboardStatusMessage('Please enter a room name', true, location);
          return;
        }
        
        // Add loading state to the button
        const addButton = document.querySelector(`#${location}RoomManagerContent .add-room-container button`);
        const originalButtonHtml = addButton.innerHTML;
        addButton.innerHTML = '<i class="material-icons" style="margin-right: 8px;">sync</i> Adding...';
        addButton.disabled = true;
        
        // Call server to add room
        google.script.run
          .withSuccessHandler(function(result) {
            // Restore button state
            addButton.innerHTML = originalButtonHtml;
            addButton.disabled = false;
            
            if (result.success) {
              showDashboardStatusMessage(`Room "${result.roomName}" added successfully`, false, location);
              document.getElementById(`newRoomName${capitalizeFirstLetter(location)}`).value = '';
              // Refresh room manager to show the new room
              showRoomManager(location);
            } else {
              showDashboardStatusMessage(result.error || 'Error adding room', true, location);
            }
          })
          .withFailureHandler(function(error) {
            // Restore button state
            addButton.innerHTML = originalButtonHtml;
            addButton.disabled = false;
            showDashboardStatusMessage(`Error: ${error}`, true, location);
          })
          .addRoom(newRoomName);
      }

      // Function to filter rooms in the dashboard
      function filterRoomsInDashboard() {
        const selectedRoom = document.getElementById('room-filter').value;
        const roomContainers = document.querySelectorAll('.room-container');
        
        roomContainers.forEach(container => {
          if (selectedRoom === 'all' || container.dataset.room === selectedRoom) {
            container.style.display = 'block';
          } else {
            container.style.display = 'none';
          }
        });
      }
      
      // Create an item row
      function createItemRow(item, index, roomName) {
        // Create the main row container
        const row = document.createElement('div');
        row.className = 'item-row';
        row.dataset.index = index; // This is the index within the specific room's array in itemsByRoom
        row.dataset.room = roomName;

        // If the item has a rowNumber (from the server), store it as a data attribute
        if (item.rowNumber) {
          row.dataset.rowNumber = item.rowNumber; // Physical row number in the sheet
        }
        // Client-side temporary ID (e.g., 'new_...' or 'row_...' before first save)
        // This is already part of the item object and used by updateItemData implicitly if needed.
        // No specific data-attribute for item.id seems necessary here as it's in the JS object.
        
        // Item input container with autocomplete
        const itemInputContainer = document.createElement('div');
        itemInputContainer.className = 'item-input-container';
        
        const itemInput = document.createElement('input');
        itemInput.type = 'text';
        itemInput.className = 'item-input';
        itemInput.value = item.item || '';
        itemInput.dataset.field = 'item';
        itemInput.dataset.room = roomName;
        itemInput.dataset.index = index;
        
        // Add focus event to show autocomplete
        itemInput.addEventListener('focus', function() {
          showAutocomplete(this);
        });
        
        // Add keydown event for filtering as user types
        itemInput.addEventListener('input', function() {
          filterAutocompleteItems(this);
        });
        
        // Add keydown event for keyboard navigation
        itemInput.addEventListener('keydown', function(e) {
          handleAutocompleteKeydown(e, this);
        });
        
        // Add blur event to close the autocomplete dropdown when clicking outside
        itemInput.addEventListener('blur', function() {
          // Use a small delay to allow click events on autocomplete items to complete
          setTimeout(() => {
            if (activeAutocompleteInput === this) {
              const autocompleteList = this.parentElement.querySelector('.autocomplete-list');
              if (autocompleteList) {
                autocompleteList.style.display = 'none';
              }
              activeAutocompleteInput = null;
            }
          }, 200);
        });
        
        const autocompleteList = document.createElement('div');
        autocompleteList.className = 'autocomplete-list';
        
        itemInputContainer.appendChild(itemInput);
        itemInputContainer.appendChild(autocompleteList);
        
        // Type input container
        const typeInputContainer = document.createElement('div');
        typeInputContainer.className = 'item-input-container';
        
        // Type input
        const typeInput = document.createElement('input');
        typeInput.type = 'text';
        typeInput.className = 'type-input';
        typeInput.value = item.type || '';
        typeInput.dataset.field = 'type';
        typeInput.dataset.room = roomName;
        typeInput.dataset.index = index;
        
        typeInputContainer.appendChild(typeInput);
        
        // Quantity input
        const quantityInput = document.createElement('input');
        quantityInput.type = 'number';
        quantityInput.className = 'quantity-input';
        quantityInput.value = item.quantity || 1;
        quantityInput.min = '1';
        quantityInput.dataset.field = 'quantity';
        quantityInput.dataset.room = roomName;
        quantityInput.dataset.index = index;
        
        // Low budget input container
        const lowBudgetContainer = document.createElement('div');
        lowBudgetContainer.className = 'budget-input-container';
        
        const lowCurrencySymbol = document.createElement('span');
        lowCurrencySymbol.className = 'currency-symbol';
        lowCurrencySymbol.textContent = '$';
        
        const lowBudgetInput = document.createElement('input');
        lowBudgetInput.type = 'number';
        lowBudgetInput.className = 'budget-input';
        lowBudgetInput.value = item.lowBudget !== null ? item.lowBudget : '';
        lowBudgetInput.min = '0';
        lowBudgetInput.step = '0.01';
        lowBudgetInput.dataset.field = 'lowBudget';
        lowBudgetInput.dataset.room = roomName;
        lowBudgetInput.dataset.index = index;
        lowBudgetInput.placeholder = '0';
        
        lowBudgetContainer.appendChild(lowCurrencySymbol);
        lowBudgetContainer.appendChild(lowBudgetInput);
        
        // High budget input container
        const highBudgetContainer = document.createElement('div');
        highBudgetContainer.className = 'budget-input-container';
        
        const highCurrencySymbol = document.createElement('span');
        highCurrencySymbol.className = 'currency-symbol';
        highCurrencySymbol.textContent = '$';
        
        const highBudgetInput = document.createElement('input');
        highBudgetInput.type = 'number';
        highBudgetInput.className = 'budget-input';
        highBudgetInput.value = item.highBudget !== null ? item.highBudget : '';
        highBudgetInput.min = '0';
        highBudgetInput.step = '0.01';
        highBudgetInput.dataset.field = 'highBudget';
        highBudgetInput.dataset.room = roomName;
        highBudgetInput.dataset.index = index;
        highBudgetInput.placeholder = '0';
        
        highBudgetContainer.appendChild(highCurrencySymbol);
        highBudgetContainer.appendChild(highBudgetInput);

        // SPEC/FFE dropdown container
        const specFfeContainer = document.createElement('div');
        specFfeContainer.className = 'spec-ffe-input-container'; // Use a specific class for styling if needed

        const specFfeSelect = document.createElement('select');
        specFfeSelect.className = 'spec-ffe-select'; // Use a specific class for styling
        specFfeSelect.dataset.field = 'specFfe';
        specFfeSelect.dataset.room = roomName;
        specFfeSelect.dataset.index = index;

        // Add a blank default option
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = ''; // Or a placeholder like '--Select--'
        specFfeSelect.appendChild(defaultOption);

        // Add SPEC option
        const specOption = document.createElement('option');
        specOption.value = 'SPEC';
        specOption.textContent = 'SPEC';
        specFfeSelect.appendChild(specOption);

        // Add FFE option
        const ffeOption = document.createElement('option');
        ffeOption.value = 'FFE';
        ffeOption.textContent = 'FFE';
        specFfeSelect.appendChild(ffeOption);

        // Set the selected value based on item.specFfe
        specFfeSelect.value = item.specFfe || ''; // Default to empty string if item.specFfe is null/undefined
        
        specFfeContainer.appendChild(specFfeSelect);
        
        // Delete button container
        const deleteButtonContainer = document.createElement('div');
        deleteButtonContainer.className = 'delete-button-container';
        
        const deleteButton = document.createElement('button');
        deleteButton.className = 'delete-button';
        deleteButton.textContent = '';
        deleteButton.dataset.room = roomName;
        deleteButton.dataset.index = String(index); // For delegated event handler
        // deleteButton.addEventListener('click', function() { // REMOVED
        //   deleteItemRow(roomName, index);
        // });
        
        deleteButtonContainer.appendChild(deleteButton);
        
        // Add all elements to the row
        row.appendChild(itemInputContainer);
        row.appendChild(typeInputContainer);
        row.appendChild(quantityInput);
        row.appendChild(lowBudgetContainer);
        row.appendChild(highBudgetContainer);
        row.appendChild(specFfeContainer); // Added SPEC/FFE dropdown
        row.appendChild(deleteButtonContainer);
        
        // REMOVED direct event listeners for data updates
        // const inputs = [itemInput, typeInput, quantityInput, lowBudgetInput, highBudgetInput];
        // inputs.forEach(input => {
        //   input.addEventListener('change', function() {
        //     console.log('change event triggered');
        //     updateItemData(this.dataset.room, this.dataset.index, this.dataset.field, this.value);
        //     console.log(this.dataset.room, this.dataset.index, this.dataset.field, this.value);
        //   });
        //   
        //   // Also add input event to capture changes as they type
        //   input.addEventListener('input', function() {
        //     console.log('input event triggered');
        //     updateItemData(this.dataset.room, this.dataset.index, this.dataset.field, this.value);
        //   });
        // });
        
        return row;
      }
      
      // Add a new item to a room
      function addItemToRoom(roomName) {
        const dataRoomKey = roomName.toUpperCase(); // Use uppercase key for data access
        const roomItems = dashboardItemData.itemsByRoom[dataRoomKey] || [];
        console.log('dashboardItemData.itemsByRoom[', dataRoomKey, ']:', roomItems);
        
        // Create new item object with temporary ID
        const newItem = {
          id: 'new_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9), // Temporary unique ID
          room: roomName, // Keep original case for item.room property
          type: '',
          item: '',
          quantity: 1,
          lowBudget: null,
          highBudget: null,
          lowBudgetTotal: null,
          highBudgetTotal: null,
          specFfe: "", // Initialize specFfe for new items
          isNew: true // Flag to indicate this is a newly added item
        };
        
        // Make sure the room container exists in the data structure using the uppercase key
        if (!dashboardItemData.itemsByRoom[dataRoomKey]) {
          dashboardItemData.itemsByRoom[dataRoomKey] = [];
        }
        
        // Add the new item to the room's items array using the uppercase key
        dashboardItemData.itemsByRoom[dataRoomKey].push(newItem);
        
        // Make sure it's also added to the main items array
        dashboardItemData.items.push(newItem);

        console.log('dashboardItemData.itemsByRoom[', dataRoomKey, '] after push:', dashboardItemData.itemsByRoom[dataRoomKey]);
        // Get the container (DOM ID uses original case)
        const container = document.getElementById(`items-${roomName.replace(/\s+/g, '-')}`);
        // Get the newIndex from the array keyed by dataRoomKey (uppercase)
        const newIndex = dashboardItemData.itemsByRoom[dataRoomKey].length - 1;
        // createItemRow expects roomName in original case for dataset attributes
        const newRow = createItemRow(newItem, newIndex, roomName); 
        
        // Add new row to the DOM
        container.appendChild(newRow);
        
        // Focus on the new item input
        setTimeout(() => {
          const itemInput = newRow.querySelector('.item-input'); // Changed back to .item-input
          if (itemInput) {
            itemInput.focus();
          }
        }, 100);
        
        // After adding, make sure the room is visible if it was filtered out
        const currentFilter = document.getElementById('room-filter').value;
        if (currentFilter !== 'all' && currentFilter !== roomName) {
          // Switch the filter to the room where we just added an item
          document.getElementById('room-filter').value = roomName;
          filterRoomsInDashboard();
        }
        
        // Update the budget summary row for this room
        //updateRoomBudgetDisplay(roomName);
      }
      
      // Delete an item row
      function deleteItemRow(roomName, index) {
        if (confirm('Are you sure you want to delete this item?')) {
          const containerId = `items-${roomName.replace(/\s+/g, '-')}`;
          const roomContainer = document.getElementById(containerId);

          // Show loading state in the specific room container
          if (roomContainer) {
            renderUIState(roomContainer, 'loading', 'Deleting item...');
          }

          // Remove from data structure
          const roomItems = dashboardItemData.itemsByRoom[roomName] || [];
          if (roomItems[index]) {
            const itemToDelete = roomItems[index]; // Get a reference before splicing

            // Remove from room-specific array first
            roomItems.splice(index, 1);
            
            // Find and remove from the main 'dashboardItemData.items' array
            // It's crucial to find the exact item instance or a reliable unique ID.
            // If itemToDelete has a unique 'id' property (e.g., 'row_X' or 'new_Y'), use that.
            // Otherwise, match by content, which can be less reliable if items are identical.
            let overallIndex = -1;
            if (itemToDelete.id) {
              overallIndex = dashboardItemData.items.findIndex(item => item.id === itemToDelete.id);
            } else {
              // Fallback to content matching if no ID (less ideal)
              overallIndex = dashboardItemData.items.findIndex(item => 
                item.room === roomName && 
                item.item === itemToDelete.item &&
                item.type === itemToDelete.type // Add more fields for uniqueness if needed
                // Potentially compare quantity or other fields if items can be truly identical otherwise
              );
            }

            if (overallIndex !== -1) {
              dashboardItemData.items.splice(overallIndex, 1);
              console.log('Item removed from dashboardItemData.items at index:', overallIndex);
            } else {
              console.warn('Could not find the exact item to remove in dashboardItemData.items. Item details:', itemToDelete);
              // Potentially alert the user or log a more significant error if this happens,
              // as it indicates a discrepancy between itemsByRoom and items.
            }
            
            // --- Immediate UI Updates ---
            // refreshRoomItemsDisplay(roomName); // Refresh the specific room's display - Defer this until after save
            
            if (roomItems.length === 0) {
              const currentFilter = document.getElementById('room-filter').value;
              if (currentFilter === roomName) {
                document.getElementById('room-filter').value = 'all';
                filterRoomsInDashboard();
              }
            }
            //updateRoomBudgetDisplay(roomName);
            showDashboardStatusMessage('Item deleted. Saving changes...', false, 'main'); // Updated message

            // --- Call saveItemsToMasterList ---
            // showDashboardLoading('Saving changes to sheet...'); // Global loading is still useful

            google.script.run
              .withSuccessHandler(function(saveResult) {
                // hideDashboardLoading(); // Global loading is still useful
                if (saveResult.success && saveResult.items) {
                  showDashboardStatusMessage(`Item deleted and changes saved successfully. ${saveResult.count} items now on sheet.`, false, 'main');
                  console.log('Successfully deleted item and saved the list. Server response details:', saveResult);

                  // IMPORTANT: Update client-side data with the server's response
                  dashboardItemData.items = saveResult.items || [];
                  
                  // Rebuild itemsByRoom from the authoritative server response
                  dashboardItemData.itemsByRoom = {};
                  dashboardItemData.items.forEach(item => {
                    // Ensure item.room is treated as uppercase, as server returns it this way.
                    const rKey = (item.room || 'UNASSIGNED').toUpperCase(); 
                    if (!dashboardItemData.itemsByRoom[rKey]) {
                      dashboardItemData.itemsByRoom[rKey] = [];
                    }
                    dashboardItemData.itemsByRoom[rKey].push(item);
                  });
                  
                  // --- Enhanced Debug Logging ---
                  const uppercasedRefreshRoomKey = roomName.toUpperCase();
                  console.log("[Delete Success] Preparing to refresh UI for room:", roomName, "(Original Case)");
                  console.log("[Delete Success] Uppercase key for data:", uppercasedRefreshRoomKey);
                  console.log("[Delete Success] Available keys in itemsByRoom after rebuild:", Object.keys(dashboardItemData.itemsByRoom));
                  const itemsForThisRoomAfterRebuild = dashboardItemData.itemsByRoom[uppercasedRefreshRoomKey];
                  console.log("[Delete Success] Items for this room (using uppercase key) after rebuild:", JSON.parse(JSON.stringify(itemsForThisRoomAfterRebuild || [])));
                  
                  // Log a sample of what the server returned for this specific room to verify its presence and casing
                  const serverItemsForThisRoom = (saveResult.items || []).filter(item => (item.room || '').toUpperCase() === uppercasedRefreshRoomKey);
                  console.log("[Delete Success] Server items for this room (filtered from saveResult.items):", JSON.parse(JSON.stringify(serverItemsForThisRoom)));
                  // --- End Enhanced Debug Logging ---
                  
                  // Re-render the specific room's items. This will clear the loading state.
                  refreshRoomItemsDisplay(roomName); 
                  //updateRoomBudgetDisplay(roomName); 

                } else {
                  console.error('Failed to save after deletion:', saveResult.error);
                  showDashboardStatusMessage('Error: Could not save changes to the sheet after deleting item. ' + (saveResult.error || "Unknown server error."), true, 'main');
                  // ATTEMPT TO ROLLBACK (Conceptual - might be complex depending on item ID strategy)
                  // This is a simplified rollback: re-add itemToDelete to local data and refresh.
                  // A more robust rollback would involve re-fetching the state before delete.
                  dashboardItemData.itemsByRoom[roomName].splice(index, 0, itemToDelete); // Add back at original index
                  dashboardItemData.items.splice(overallIndex !== -1 ? overallIndex : 0, 0, itemToDelete); // Add back to main list
                  
                  // Refresh display, which should clear loading and show restored items or an error if refresh fails.
                  refreshRoomItemsDisplay(roomName);
                  //updateRoomBudgetDisplay(roomName);
                  // Optionally, explicitly show an error in the room container if refresh doesn't handle it well.
                  if (roomContainer) {
                     renderUIState(roomContainer, 'error', 'Save failed. Item restored locally.');
                  }
                  showDashboardStatusMessage('Save failed. Local changes have been temporarily restored. Please try saving all items manually or refresh.', true, 'main');
                }
              })
              .withFailureHandler(function(error) {
                // hideDashboardLoading(); // Global loading is still useful
                console.error('Error calling saveItemsToMasterList after delete:', error);
                showDashboardStatusMessage('Client Error: Failed to communicate with server to save deletion. ' + error.message, true, 'main');
                // ATTEMPT TO ROLLBACK (Conceptual)
                dashboardItemData.itemsByRoom[roomName].splice(index, 0, itemToDelete);
                dashboardItemData.items.splice(overallIndex !== -1 ? overallIndex : 0, 0, itemToDelete);

                // Refresh display, which should clear loading and show restored items or an error if refresh fails.
                refreshRoomItemsDisplay(roomName);
                //updateRoomBudgetDisplay(roomName);
                // Optionally, explicitly show an error in the room container if refresh doesn't handle it well.
                if (roomContainer) {
                  renderUIState(roomContainer, 'error', 'Save failed. Item restored locally.');
                }
                showDashboardStatusMessage('Communication error. Local changes have been temporarily restored. Please try saving all items manually or refresh.', true, 'main');
              })
              .saveItemsToMasterList(dashboardItemData.items); // Pass the globally updated and correct items array

          } else {
            console.warn("Item at index " + index + " in room " + roomName + " not found in dashboardItemData.itemsByRoom.");
          }
        }
      }
      
      // Refresh the display of all items for a room
      function refreshRoomItemsDisplay(roomName) { // roomName is the original case, used for DOM IDs
        const uppercasedDataKey = roomName.toUpperCase();
        const roomItems = dashboardItemData.itemsByRoom[uppercasedDataKey] || [];
        
        const containerId = `items-${roomName.replace(/\s+/g, '-')}`; // DOM ID uses original case
        const container = document.getElementById(containerId);
        
        if (!container) {
          console.error(`refreshRoomItemsDisplay: Items container '${containerId}' not found for room '${roomName}'. Cannot refresh.`);
          return; 
        }
        
        container.innerHTML = ''; // Clear previous items
        
        if (roomItems.length > 0) {
          const itemsFragment = document.createDocumentFragment();
          roomItems.forEach((item, index) => {
            // createItemRow needs the original roomName case for its data attributes if they affect DOM or subsequent lookups by original case
            const newRow = createItemRow(item, index, roomName); 
            itemsFragment.appendChild(newRow);
          });
          container.appendChild(itemsFragment);
        } else {
          // Display a message if there are no items for this room after the update
          container.innerHTML = '<div class="empty-state-compact" style="padding: 10px; text-align: center; color: #777;">No items in this room.</div>';
          console.log(`refreshRoomItemsDisplay: No items to display for room '${roomName}' (data key '${uppercasedDataKey}'). Displaying empty message.`);
        }
        
        // updateRoomBudgetDisplay is also called with original roomName case for DOM ID consistency.
        // It will internally use .toUpperCase() for data access.
        //updateRoomBudgetDisplay(roomName);
      }
      
      // Update item data when inputs change
      function updateItemData(roomName, index, field, value) { // roomName is original case from dataset
        const idx = parseInt(index);
        const dataRoomKey = roomName.toUpperCase(); // Use uppercase key for data access
        
        // Ensure the itemsByRoom[dataRoomKey] exists.
        if (!dashboardItemData.itemsByRoom || !dashboardItemData.itemsByRoom[dataRoomKey]) {
            console.error(`Room key '${dataRoomKey}' (from room '${roomName}') not found in dashboardItemData.itemsByRoom, or itemsByRoom is undefined. Cannot update item.`);
            return;
        }
        // Access the array for the uppercase key. The 'index' parameter is correct for THIS array.
        const roomItems = dashboardItemData.itemsByRoom[dataRoomKey]; 
        
        if (idx < 0 || idx >= roomItems.length) {
          console.error(`Invalid index: ${idx}. Room '${roomName}' (key '${dataRoomKey}') items length: ${roomItems.length}. This index came from dataset.index and should be valid for the array keyed by dataRoomKey.`);
          return;
        }
        
        const item = roomItems[idx]; // This should now be the correct item
        console.log(`Updating ${field} for item in ${roomName} (key ${dataRoomKey}) at index ${idx} to value: ${value}`);
        console.log('Item before update:', JSON.parse(JSON.stringify(item))); // Log a deep copy
        
        if (field === 'quantity') {
          item[field] = parseInt(value) || 1;
          
          // Recalculate totals
          if (item.lowBudget !== null && !isNaN(item.lowBudget)) {
            item.lowBudgetTotal = item.lowBudget * item.quantity;
          } else {
            item.lowBudgetTotal = null;
          }
          
          if (item.highBudget !== null && !isNaN(item.highBudget)) {
            item.highBudgetTotal = item.highBudget * item.quantity;
          } else {
            item.highBudgetTotal = null;
          }
        } else if (field === 'lowBudget' || field === 'highBudget') {
          item[field] = value === '' ? null : (parseFloat(value) || (parseFloat(value) === 0 ? 0 : null));
          
          const qty = item.quantity || 1;
          if (field === 'lowBudget') {
            if (item.lowBudget !== null && !isNaN(item.lowBudget)) {
              item.lowBudgetTotal = item.lowBudget * qty;
            } else {
              item.lowBudgetTotal = null;
            }
          } else { // highBudget
            if (item.highBudget !== null && !isNaN(item.highBudget)) {
              item.highBudgetTotal = item.highBudget * qty;
            } else {
              item.highBudgetTotal = null;
            }
          }
        } else {
          // For 'item' and 'type' fields, convert to uppercase
          if (field === 'item' || field === 'type') {
            item[field] = value.toUpperCase();
          } else {
            item[field] = value; // Handles specFfe, etc.
          }
        }
        
        console.log('Item after update:', JSON.parse(JSON.stringify(item))); // Log a deep copy
        
        const mainIndex = dashboardItemData.items.findIndex(i => 
          i === item || 
          (i.id && item.id && i.id === item.id) ||
          (i.room === roomName && item.item && i.item === item.item && item.type && i.type === item.type && i.quantity === item.quantity) 
        );
        
        if (mainIndex >= 0) {
          if (dashboardItemData.items[mainIndex] !== item) {
             console.log(`Updating item in main items array at index ${mainIndex} by replacing it.`);
             dashboardItemData.items[mainIndex] = item; 
          } else {
             console.log(`Item in main items array at index ${mainIndex} is the same reference, already updated.`);
          }
        } else {
          console.warn(`Couldn't find exact item in main items array to update. Room: ${roomName}, Index in room: ${idx}. This might be okay for new items if main list is robustly synced elsewhere.`);
        }
        
        //updateRoomBudgetDisplay(roomName); // Uses original case roomName for DOM ID
      }
      
      // Autocomplete functionality
      let currentFocus = -1;
      let lastActiveInput = null;
      
      // Show autocomplete list
      function showAutocomplete(input) {
        closeAllAutocompletes(); // Close any existing autocomplete lists
        
        const autocompleteList = input.parentElement.querySelector('.autocomplete-list');
        lastActiveInput = input;
        
        // Track this as the active autocomplete input
        activeAutocompleteInput = input;
        
        // Reset focus
        currentFocus = -1;
        
        // Show all available items initially
        let listHtml = '';
        console.log('Combined items:', dashboardItemData.combinedItems);
        dashboardItemData.combinedItems.forEach((item, index) => {
          listHtml += `<div class="autocomplete-item" data-index="${index}" data-value="${escapeHtml(item)}">${item}</div>`;
        });
        
        autocompleteList.innerHTML = listHtml;
        autocompleteList.style.display = 'block';
        
        // Add click listeners
        addClickListenersToItems(autocompleteList);
      }
      
      // Filter autocomplete items based on input
      function filterAutocompleteItems(input) {
        const value = input.value.toLowerCase();
        const autocompleteList = input.parentElement.querySelector('.autocomplete-list');
        
        // Reset focus
        currentFocus = -1;
        
        // Show all items if input is empty
        if (value === '') {
          let listHtml = '';
          dashboardItemData.combinedItems.forEach((item, index) => {
            listHtml += `<div class="autocomplete-item" data-index="${index}" data-value="${escapeHtml(item)}">${item}</div>`;
          });
          
          autocompleteList.innerHTML = listHtml;
          autocompleteList.style.display = 'block';
        } else {
          // Filter available items that match the input
          const filteredItems = dashboardItemData.combinedItems.filter(item => 
            item.toLowerCase().includes(value)
          );
          
          // Generate HTML for autocomplete list
          let listHtml = '';
          filteredItems.forEach((item, index) => {
            listHtml += `<div class="autocomplete-item" data-index="${index}" data-value="${escapeHtml(item)}">${item}</div>`;
          });
          
          autocompleteList.innerHTML = listHtml;
          autocompleteList.style.display = filteredItems.length > 0 ? 'block' : 'none';
        }
        
        // Add click listeners to all items
        addClickListenersToItems(autocompleteList);
      }
      
      // Handle keyboard navigation in autocomplete
      function handleAutocompleteKeydown(e, input) {
        const autocompleteList = input.parentElement.querySelector('.autocomplete-list');
        const items = autocompleteList.getElementsByClassName('autocomplete-item');
        
        if (items.length === 0) return;
        
        // Down arrow
        if (e.key === 'ArrowDown') {
          currentFocus++;
          // Wrap around if at the end
          if (currentFocus >= items.length) currentFocus = 0;
          setActiveItem(items);
          e.preventDefault();
        }
        // Up arrow
        else if (e.key === 'ArrowUp') {
          currentFocus--;
          // Wrap around if at the beginning
          if (currentFocus < 0) currentFocus = items.length - 1;
          setActiveItem(items);
          e.preventDefault();
        }
        // Enter key
        else if (e.key === 'Enter') {
          e.preventDefault();
          if (currentFocus > -1) {
            // Click the active item
            items[currentFocus].click();
          }
        }
        // Escape key
        else if (e.key === 'Escape') {
          closeAllAutocompletes();
        }
      }
      
      // Set the active item in the list
      function setActiveItem(items) {
        // Remove active class from all items
        Array.from(items).forEach(item => {
          item.classList.remove('autocomplete-active');
        });
        
        // Add active class to the current focus item
        if (currentFocus >= 0 && currentFocus < items.length) {
          items[currentFocus].classList.add('autocomplete-active');
          
          // Ensure the active item is visible (scroll to it if needed)
          items[currentFocus].scrollIntoView({ block: 'nearest' });
        }
      }
      
      // Add click listeners to autocomplete items
      function addClickListenersToItems(autocompleteList) {
        const items = autocompleteList.getElementsByClassName('autocomplete-item');
        Array.from(items).forEach(item => {
          // Use mousedown to prevent blur from firing first
          item.addEventListener('mousedown', function(e) {
            // Prevent default to avoid input blur
            e.preventDefault();
          });
          
          item.addEventListener('click', function(e) {
            // Select the item
            selectAutocompleteItem(this);
            
            // Focus back on the input after selection
            if (lastActiveInput) {
              lastActiveInput.focus();
            }
          });
        });
      }
      
      // Handle item selection from autocomplete
      function selectAutocompleteItem(selectedItem) {
        if (!lastActiveInput) return;
        
        const value = selectedItem.getAttribute('data-value');
        
        // Extract room and index from input attributes
        const roomName = lastActiveInput.getAttribute('data-room');
        const index = lastActiveInput.getAttribute('data-index');
        
        // Extract item parts (type and name) from combined format
        const parts = value.split(' : ');
        
        // Update the input field with just the item name
        lastActiveInput.value = parts.length > 1 ? parts[1] : value;
        
        // If we have a type, set it in the type field
        if (parts.length > 1) {
          const typeInput = document.querySelector(`.type-input[data-room="${roomName}"][data-index="${index}"]`);
          if (typeInput) {
            typeInput.value = parts[0];
          }
          
          // Update data
          updateItemData(roomName, index, 'item', parts[1]);
          updateItemData(roomName, index, 'type', parts[0]);
        } else {
          // Update just the item
          updateItemData(roomName, index, 'item', value);
        }
        
        // Close all autocomplete lists
        closeAllAutocompletes();
      }
      
      // Close all autocomplete lists
      function closeAllAutocompletes() {
        // Hide all autocomplete lists
        const lists = document.getElementsByClassName('autocomplete-list');
        Array.from(lists).forEach(list => {
          list.style.display = 'none';
        });
      }

      function displayBudgetSummary(data) {
        // Defensive: ensure the element exists before setting innerHTML
        var budgetSummaryContainer = document.getElementById('budgetSummaryDisplay');
        if (!budgetSummaryContainer) {
          console.warn('budgetSummaryDisplay not found in displayBudgetSummary');
          return;
        }
        
        // Check if we have valid data
        if (!data) {
          handleBudgetError('No budget data received');
          return;
        }
        
        console.log('Budget data received:', data);
        
        // Check if there was an error in the response
        if (data.error) {
          handleBudgetError(data.error);
          return;
        }
        
        // Check for required properties
        if (!data.summary || !data.rooms) {
          handleBudgetError('Incomplete budget data: missing summary or rooms information');
          return;
        }
        
        // Budget Summary Box
        const summaryHtml = `
          <div class="budget-summary-box">
            <div class="budget-summary-row">
              <div class="budget-label">Low Budget Total:</div>
              <div class="budget-value">$${formatCurrency(data.summary.totalLowBudget)}</div>
            </div>
            <div class="budget-summary-row">
              <div class="budget-label">High Budget Total:</div>
              <div class="budget-value">$${formatCurrency(data.summary.totalHighBudget)}</div>
            </div>
                    </div>
                  `;
        
        // Room Cards for Sidebar with section header
        let roomCardsHtml = `
          <div class="budget-section-header">
            <h3>Budget by Room</h3>
          </div>
        `;
        
        // Check if we have rooms to display
        if (data.rooms.length === 0) {
          roomCardsHtml += `
            <div class="empty-state">
              <i class="material-icons">info_outline</i>
              <p>No room budget data available</p>
            </div>
          `;
        } else {
          data.rooms.forEach(room => {
            roomCardsHtml += `
              <div class="budget-card">
                <div class="budget-header">
                  <div class="room-name">
                    ${room.name}
                  </div>
                </div>
                <div class="budget-metrics">
                  <div>Low: $${formatCurrency(room.lowBudget)}</div>
                  <div>High: $${formatCurrency(room.highBudget)}</div>
                </div>
              </div>
            `;
          });
        }
        
        // Calculate budget by item type
        const typeData = {};
        let typeCardsHtml = `
          <div class="budget-section-header">
            <h3>Budget by Item Type</h3>
          </div>
        `;
        
        // Process all items across all rooms to group by type
        if (data.rooms && data.rooms.length > 0) {
          data.rooms.forEach(room => {
            if (room.items && Array.isArray(room.items)) {
              room.items.forEach(item => {
                const itemType = item.type ? item.type.trim() : 'Uncategorized';
                
                if (!typeData[itemType]) {
                  typeData[itemType] = {
                    name: itemType,
                    lowBudget: 0,
                    highBudget: 0
                  };
                }
                
                typeData[itemType].lowBudget += item.lowTotal || 0;
                typeData[itemType].highBudget += item.highTotal || 0;
              });
            }
          });
          
          // Convert to array and sort by high budget (highest first)
          const typeArray = Object.values(typeData).sort((a, b) => b.highBudget - a.highBudget);
          
          if (typeArray.length === 0) {
            typeCardsHtml += `
              <div class="empty-state">
                <i class="material-icons">info_outline</i>
                <p>No item type data available</p>
              </div>
            `;
          } else {
            typeArray.forEach(type => {
              typeCardsHtml += `
                <div class="budget-card">
                  <div class="budget-header">
                    <div class="type-name">
                      ${type.name}
                    </div>
                  </div>
                  <div class="budget-metrics">
                    <div>Low: $${formatCurrency(type.lowBudget)}</div>
                    <div>High: $${formatCurrency(type.highBudget)}</div>
                  </div>
                </div>
              `;
            });
          }
        } else {
          typeCardsHtml += `
            <div class="empty-state">
              <i class="material-icons">info_outline</i>
              <p>No item type data available</p>
            </div>
          `;
        }
        
        // Combine all sections
        budgetSummaryContainer.innerHTML = `
          <style>
            .budget-section-header {
              margin-top: 20px;
              margin-bottom: 10px;
              border-bottom: 1px solid rgba(0,0,0,0.1);
              padding-bottom: 5px;
            }
            .budget-section-header h3 {
              font-size: 16px;
              font-weight: 500;
              color: #333;
              margin: 0;
            }
            .budget-card {
              margin-bottom: 8px;
            }
          </style>
          ${summaryHtml}
          ${roomCardsHtml}
          ${typeCardsHtml}
        `;
      }
      
      // Helper function to escape HTML content
      function escapeHtml(str) {
        if (!str) return '';
        return str
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
      }

      // Function to show status message in the sidebar
      function showSidebarStatusMessage(message, isError = false) {
        const statusDiv = document.getElementById('sidebarStatusMessage');
        if (!statusDiv) {
          console.error('Sidebar status message container not found');
          return;
        }

        // Clear any existing classes first
        statusDiv.className = 'status-message';
        
        // Add appropriate styling based on message type
        if (isError) {
          statusDiv.classList.add('error');
        } else {
          statusDiv.classList.add('success');
        }
        
        // Set message content
        statusDiv.textContent = message;
        statusDiv.style.display = 'block';
        
        // Auto-hide the message after 5 seconds
        setTimeout(() => {
          statusDiv.style.display = 'none';
        }, 5000);
      }
      
      /**
       * Calculates the total low and high budget for a room's items.
       * @param {Array} roomItems - The array of items in the room.
       * @return {Object} Object with lowTotal and highTotal properties.
       */
      function calculateRoomBudgetTotals(roomItems) {
        let lowTotal = 0;
        let highTotal = 0;
        
        if (!roomItems || !Array.isArray(roomItems)) {
          return { lowTotal, highTotal };
        }
        
        roomItems.forEach(item => {
          if (item.lowBudgetTotal !== null && !isNaN(item.lowBudgetTotal)) {
            lowTotal += parseFloat(item.lowBudgetTotal);
          }
          
          if (item.highBudgetTotal !== null && !isNaN(item.highBudgetTotal)) {
            highTotal += parseFloat(item.highBudgetTotal);
          }
        });
        
        return { lowTotal, highTotal };
      }
      
      // Helper function for consistent currency formatting
      function formatCurrency(value) {
        if (value === undefined || value === null) return '0';
        return parseFloat(value).toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
      }

      /**
       * Updates the budget summary row for a specific room
       * @param {string} roomName - The name of the room to update the budget summary for
       */
      function updateRoomBudgetDisplay(roomName) { // roomName is original case, used for DOM IDs
        const roomContainerId = `room-container-${roomName.replace(/\s+/g, '-')}`;
        const roomContainer = document.getElementById(roomContainerId);
        if (!roomContainer) {
          console.warn(`updateRoomBudgetDisplay: Room container '${roomContainerId}' not found for room '${roomName}'.`);
          return;
        }
        
        const uppercasedDataKey = roomName.toUpperCase();
        const roomItems = dashboardItemData.itemsByRoom[uppercasedDataKey] || [];
        
        // Calculate updated budget totals
        const roomTotals = calculateRoomBudgetTotals(roomItems);
        
        // Find the add-more-row element to ensure proper placement
        const addMoreRow = roomContainer.querySelector('.add-more-row');
        if (!addMoreRow) {
          console.warn(`Add-more-row not found for ${roomName}, cannot place budget summary`);
          return;
        }
        
        // Remove any existing budget summary rows to avoid duplicates
        const existingBudgetRows = roomContainer.querySelectorAll('.room-budget-summary');
        existingBudgetRows.forEach(row => row.remove());
        
        // Create a new budget summary row
        const budgetSummaryRow = document.createElement('div');
        budgetSummaryRow.className = 'room-budget-summary';
        budgetSummaryRow.style.display = 'flex';
        budgetSummaryRow.style.justifyContent = 'flex-end';
        budgetSummaryRow.style.padding = '10px 12px';
        budgetSummaryRow.style.borderTop = '1px solid rgba(38, 113, 125, 0.2)';
        budgetSummaryRow.style.marginTop = '10px';
        budgetSummaryRow.style.fontWeight = '500';
        
        // Insert after the add-more-row
        if (addMoreRow.nextSibling) {
          roomContainer.insertBefore(budgetSummaryRow, addMoreRow.nextSibling);
        } else {
          roomContainer.appendChild(budgetSummaryRow);
        }
        
        // Update the budget summary content
        budgetSummaryRow.innerHTML = `
          <div style="margin-right: 50px;">Room Totals:</div>
          <div style="width: 130px; text-align: right;">$${formatCurrency(roomTotals.lowTotal)}</div>
          <div style="width: 130px; text-align: right;">$${formatCurrency(roomTotals.highTotal)}</div>
          <div style="width: 190px;"></div>
        `;
      }

      function displayProjectDetails(project) {
        // Add code here to display project details in the main content area
        const projectNameElement = document.getElementById('projectName');
        if (projectNameElement) {
          projectNameElement.textContent = project.name || 'Project Details';
        }
        
        // Set project data attributes on the dialog for use in other functions
        const dialog = document.querySelector('.app-container');
        if (dialog) {
          dialog.setAttribute('data-project-id', project.id);
          dialog.setAttribute('data-sheet-id', project.sheetId || '');
          
          // Update home sidebar with project details
          updateHomeSidebarContent();
        }
        
        // Your existing code to display project details...
      }

      // Add after the global variables at the top of the file
      // Define room-specific suggested items
      function getSuggestedItemsForRoom(roomName) {
        const roomLower = roomName.toLowerCase();
        const suggestedItems = {
          'living room': [
            { name: 'Sofa' }, { name: 'Coffee Table' }, { name: 'Side Table' }, { name: 'Rug' }, 
            { name: 'TV Console' }, { name: 'Armchair' }, { name: 'Floor Lamp', type: 'Lighting' }
          ],
          'dining room': [
            { name: 'Dining Table', type: 'Tables' }, { name: 'Dining Chairs', type: 'FURNITURE - SOFT GOODS' }, { name: 'Buffet', type: 'Furniture - Soft Goods' },
            { name: 'Chandelier', type: 'Lighting' }, { name: 'Rug', type: 'Decor - Soft Goods' }, { name: 'Framed Art', type: 'Other Decor' }
          ],
          'kitchen': [
            { name: 'Bar Stools' }, { name: 'Pendant Lights', type: 'Lighting' }, { name: 'Kitchen Island' }, 
            { name: 'Rack' }, { name: 'Storage Container' }
          ],
          'bedroom': [
            { name: 'Bed' }, { name: 'Nightstand' }, { name: 'Dresser' }, { name: 'Armoire' }, 
            { name: 'Bench' }, { name: 'Table Lamp', type: 'Lighting' }, { name: 'Rug' }
          ],
          'bathroom': [
            { name: 'Mirror' }, { name: 'Vanity' }, { name: 'Shower Curtain' }, { name: 'Bath Mat' }, 
            { name: 'Storage Cabinet' }
          ],
          'office': [
            { name: 'Desk' }, { name: 'Office Chair' }, { name: 'Bookshelf' }, 
            { name: 'Desk Lamp', type: 'Lighting' }, { name: 'Filing Cabinet' }
          ],
          'entryway': [
            { name: 'Console Table' }, { name: 'Mirror' }, { name: 'Bench' }, { name: 'Coat Rack' }, { name: 'Rug' }
          ],
          'hallway': [
            { name: 'Runner Rug' }, { name: 'Console Table' }, { name: 'Wall Sconce', type: 'Lighting' }
          ],
          'guest room': [
            { name: 'Bed' }, { name: 'Nightstand' }, { name: 'Dresser' }, { name: 'Mirror' }, { name: 'Luggage Rack' }
          ],
          'nursery': [
            { name: 'Crib' }, { name: 'Changing Table' }, { name: 'Rocking Chair' }, { name: 'Dresser' }, { name: 'Rug' }
          ],
          'playroom': [
            { name: 'Storage Unit' }, { name: 'Play Table' }, { name: 'Rug' }, { name: 'Bookshelf' }, { name: 'Seating' }
          ],
          'mudroom': [
            { name: 'Bench' }, { name: 'Coat Hooks' }, { name: 'Storage Baskets' }, { name: 'Shoe Rack' }
          ]
        };
        
        // Check for exact room matches first
        if (suggestedItems[roomLower]) {
          return suggestedItems[roomLower];
        }
        
        // If no exact match, check if the room name contains any of the keys
        for (const key in suggestedItems) {
          if (roomLower.includes(key)) {
            return suggestedItems[key];
          }
        }
        
        // Return empty array if no match found (no default suggestions)
        return [];
      }

      /**
       * Checks if an item already exists in the room items list
       * @param {Array} roomItems - The items in the room
       * @param {string} itemName - The name of the item to check
       * @returns {boolean} - True if the item already exists
       */
      function itemExistsInRoom(roomItems, suggestedItemObject) {
        if (!roomItems || !Array.isArray(roomItems)) return false;
        
        return roomItems.some(roomItem => {
          // Case-insensitive comparison
          return roomItem.item && roomItem.item.toLowerCase() === suggestedItemObject.name.toLowerCase();
        });
      }

      /**
       * Adds a specific named item to a room
       * @param {string} roomName - The name of the room to add the item to
       * @param {string} itemName - The name of the item to add
       */
      function addSpecificItemToRoom(roomName, itemName, itemType = '') {
        // Get current room items
        const roomItems = dashboardItemData.itemsByRoom[roomName] || [];

        console.log('roomItems:', roomItems);
        
        // Create new item object with temporary ID and the specified item name
        const newItem = {
          id: 'new_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9), // Temporary unique ID
          room: roomName,
          type: itemType ? itemType.toUpperCase() : '', // Convert to uppercase, ensure empty string if no type
          item: itemName.toUpperCase(),             // Convert item name to uppercase
          quantity: 1,
          lowBudget: null,
          highBudget: null,
          lowBudgetTotal: null,
          highBudgetTotal: null,
          specFfe: "", // Initialize specFfe for new items
          isNew: true // Flag to indicate this is a newly added item
        };
        
        // Make sure the room container exists in the data structure
        if (!dashboardItemData.itemsByRoom[roomName]) {
          dashboardItemData.itemsByRoom[roomName] = [];
        }
        
        // Add the new item to the room's items array
        dashboardItemData.itemsByRoom[roomName].push(newItem);

        console.log('dashboardItemData.itemsByRoom[roomName]:', dashboardItemData.itemsByRoom[roomName]);
        
        // Make sure it's also added to the main items array
        dashboardItemData.items.push(newItem);
        
        // Get the container and add the new row
        const container = document.getElementById(`items-${roomName.replace(/\s+/g, '-')}`);
        const newIndex = dashboardItemData.itemsByRoom[roomName].length - 1;
        const newRow = createItemRow(newItem, newIndex, roomName);
        
        // Add new row to the DOM
        container.appendChild(newRow);
        
        // Focus on the type input since the item name is already set
        setTimeout(() => {
          const typeInput = newRow.querySelector('.type-input');
          if (typeInput) {
            typeInput.focus();
          }
        }, 100);
        
        // After adding, make sure the room is visible if it was filtered out
        const currentFilter = document.getElementById('room-filter').value;
        if (currentFilter !== 'all' && currentFilter !== roomName) {
          // Switch the filter to the room where we just added an item
          document.getElementById('room-filter').value = roomName;
          filterRoomsInDashboard();
        }
        
        // Update the budget summary row for this room
        //updateRoomBudgetDisplay(roomName);
        
        // Refresh the quick-add buttons to remove the one we just added
        //refreshQuickAddButtons(roomName);
      }

      /**
       * Refreshes the quick-add buttons for a room to remove buttons for items that now exist
       * @param {string} roomName - The name of the room to refresh buttons for
       */
      function refreshQuickAddButtons(roomName) {
        const roomContainer = document.getElementById(`room-container-${roomName.replace(/\s+/g, '-')}`);
        if (!roomContainer) return;
        
        const addMoreRow = roomContainer.querySelector('.add-more-row');
        if (!addMoreRow) return;
        
        // Remove existing quick-add container
        const existingContainer = addMoreRow.querySelector('.quick-add-container');
        if (existingContainer) {
          existingContainer.remove();
        }
        
        // Get all suggested items for this room
        const allSuggestedItems = getSuggestedItemsForRoom(roomName);
        const roomItems = dashboardItemData.itemsByRoom[roomName] || [];
        
        // Filter out items that already exist in the room
        const availableSuggestions = allSuggestedItems.filter(item => 
          !itemExistsInRoom(roomItems, item)
        );
        
        // Initialize visible items tracking if needed
        if (!dashboardItemData.visibleSuggestedItems) {
          dashboardItemData.visibleSuggestedItems = {};
        }
        
        // If we don't have a list for this room or the list is empty, initialize it
        if (!dashboardItemData.visibleSuggestedItems[roomName] || 
            dashboardItemData.visibleSuggestedItems[roomName].length === 0) {
          // Start with up to 5 items
          dashboardItemData.visibleSuggestedItems[roomName] = availableSuggestions.slice(0, 5);
        } else {
          // Filter out any items that are no longer available
          dashboardItemData.visibleSuggestedItems[roomName] = 
            dashboardItemData.visibleSuggestedItems[roomName].filter(item => 
              availableSuggestions.includes(item)
            );
          
          // If we have less than 5 items, add more from available suggestions
          if (dashboardItemData.visibleSuggestedItems[roomName].length < 5) {
            // Find items that are available but not currently visible
            const additionalSuggestions = availableSuggestions.filter(item => 
              !dashboardItemData.visibleSuggestedItems[roomName].includes(item)
            );
            
            // Add as many as needed to get to 5 (or as many as are available)
            const neededCount = 5 - dashboardItemData.visibleSuggestedItems[roomName].length;
            const itemsToAdd = additionalSuggestions.slice(0, neededCount);
            
            // Add them to the visible items
            dashboardItemData.visibleSuggestedItems[roomName] = 
              dashboardItemData.visibleSuggestedItems[roomName].concat(itemsToAdd);
          }
        }
        
        // Create a new container
        const quickAddContainer = document.createElement('div');
        quickAddContainer.className = 'quick-add-container';
        
        // Create buttons for all visible items (max 5)
        dashboardItemData.visibleSuggestedItems[roomName].forEach(itemObj => { // itemObj is now an object {name, type?}
          const quickAddButton = document.createElement('button');
          quickAddButton.className = 'quick-add-btn';
          quickAddButton.textContent = `Add ${itemObj.name}`;
          
          // Add click handler
          quickAddButton.addEventListener('click', function() {
            addSpecificItemToRoom(roomName, itemObj.name, itemObj.type); // Pass name and type
          });
          
          quickAddContainer.appendChild(quickAddButton);
        });
        
        // Only add the container if it has buttons
        if (quickAddContainer.children.length > 0) {
          addMoreRow.appendChild(quickAddContainer);
        }
      }

      /**
       * Renders the item selection interface in the dashboard without budget fields
       * and adds checkboxes for selecting items to add to the sheet.
       * @param {Object} data - The data to populate the interface with.
       */
      function renderItemSelectionInterface(data, optionalOnSuccessCallback) { // MODIFIED: Add optionalOnSuccessCallback
        
        if (!data.success) {
          document.getElementById('mainContent').innerHTML = `
            <div class="error-box" style="margin: 20px;">
              <strong>Error:</strong> ${data.error || 'Failed to load item data'}
            </div>`;
          return;
        }
        console.log('renderItemSelectionInterface called with:', data);
        console.log('itemsByRoom:', data.itemsByRoom);
        console.log('Data received in renderItemSelectionInterface:', data);
        
        // Store the data for later use
        dashboardItemSelectionData = data;
        
        // Check if we have combinedItems property
        if (!dashboardItemSelectionData.combinedItems || !Array.isArray(dashboardItemSelectionData.combinedItems)) {
          console.warn('combinedItems is missing or not an array, initializing from availableItems');
          
          // Initialize combinedItems from availableItems if needed
          if (dashboardItemSelectionData.availableItems && Array.isArray(dashboardItemSelectionData.availableItems)) {
            dashboardItemSelectionData.combinedItems = dashboardItemSelectionData.availableItems.map(item => {
              if (typeof item === 'string') return item;
              return item.type && item.item ? `${item.type} : ${item.item}` : (item.item || '');
            });
            console.log('Created combinedItems with', dashboardItemSelectionData.combinedItems.length, 'items');
          } else {
            console.warn('availableItems is also missing or not an array, initializing empty array');
            dashboardItemSelectionData.combinedItems = [];
          }
        }
        
        // Create container for all room sections
        const container = document.createElement('div');
        container.className = 'item-selection-content';
        container.style.padding = '0 20px';
        
        // Group items by room first
        const itemsByRoom = {};
        data.selectedRooms.forEach(room => {
          itemsByRoom[room] = data.itemsByRoom[room] || [];
        });
        
        // Create the sticky filter and save button container
        const stickyContainer = document.createElement('div');
        stickyContainer.id = 'sticky-filter-save-container';
        stickyContainer.style.position = 'sticky';
        stickyContainer.style.top = '0';
        stickyContainer.style.backgroundColor = 'white';
        stickyContainer.style.zIndex = '100';
        stickyContainer.style.padding = '10px 0';
        stickyContainer.style.display = 'flex';
        stickyContainer.style.justifyContent = 'start';
        stickyContainer.style.alignItems = 'center';
        stickyContainer.style.borderBottom = '1px solid rgba(0,0,0,0.1)';
        
        // Add room filter
        const filterContainer = document.createElement('div');
        filterContainer.id = 'filter-container';
        filterContainer.style.display = 'flex';
        filterContainer.style.alignItems = 'center';
        
        const filterLabel = document.createElement('label');
        filterLabel.className = 'filter-label';
        filterLabel.htmlFor = 'room-filter';
        filterLabel.textContent = 'Filter by Room:';
        filterLabel.style.marginRight = '10px';
        
        const roomFilter = document.createElement('select');
        roomFilter.id = 'room-filter';
        roomFilter.style.marginRight = '20px';
        roomFilter.addEventListener('change', filterRoomsInSelectionInterface);
        
        const allRoomsOption = document.createElement('option');
        allRoomsOption.value = 'all';
        allRoomsOption.textContent = 'All Rooms';
        roomFilter.appendChild(allRoomsOption);
        
        filterContainer.appendChild(filterLabel);
        filterContainer.appendChild(roomFilter);

        // Create "Save Draft" button
        const saveDraftButton = document.createElement('button');
        saveDraftButton.className = 'btn btn-secondary'; // Added btn-secondary for different styling, adjust as needed
        saveDraftButton.id = 'saveDraftButton'; // Added an ID for easier selection if needed
        saveDraftButton.style.marginLeft = '10px'; // Add some space between buttons

        const draftIcon = document.createElement('i');
        draftIcon.className = 'material-icons';
        draftIcon.textContent = 'save'; // Or another suitable icon like 'save_alt'
        draftIcon.style.marginRight = '5px';

        saveDraftButton.appendChild(draftIcon);
        saveDraftButton.appendChild(document.createTextNode('Save Items'));

        // Event listener for Save Draft button
        saveDraftButton.addEventListener('click', function() {
          if (typeof handleSaveDraftItem === 'function') {
            handleSaveDraftItem();
            // Optionally, provide user feedback e.g., a toast notification
            // showToastNotification('Draft saved!'); 
          } else {
            console.error('handleSaveDraftItem function is not defined. Make sure DashboardScripts.js.html is loaded and the function is global.');
            alert('Error: Could not save draft. Function not available.');
          }
        });
        
        // Actions container in the sticky header
        const actionsContainer = document.createElement('div');
        actionsContainer.style.display = 'flex';
        actionsContainer.style.gap = '10px';
        actionsContainer.appendChild(saveDraftButton); 
        
        // Add filter and actions to sticky container
        stickyContainer.appendChild(filterContainer);
        stickyContainer.appendChild(actionsContainer);
        
        // Add sticky container to main container
        container.appendChild(stickyContainer);
        
        // Populate filter dropdown with rooms
        Object.keys(itemsByRoom).sort().forEach(room => {
          const option = document.createElement('option');
          option.value = room;
          option.textContent = room;
          roomFilter.appendChild(option);
        });
        
        // Create a DocumentFragment to hold all room containers before appending to the main container
        const roomsFragment = document.createDocumentFragment();
        
        // Create room sections
        Object.keys(itemsByRoom).sort().forEach(room => {
          const currentRoomItems = itemsByRoom[room];
          
          // Create room container
          const roomContainer = document.createElement('div');
          roomContainer.className = 'room-container';
          roomContainer.id = `room-container-${room.replace(/\s+/g, '-')}`;
          roomContainer.dataset.room = room;
          
          // Add room title
          const roomTitle = document.createElement('div');
          roomTitle.className = 'room-title';
          roomTitle.textContent = room;
          roomContainer.appendChild(roomTitle);
          
          // Add column headers
          const headers = document.createElement('div');
          headers.className = 'column-headers';
          
          // Add a checkbox header
          const checkboxHeader = document.createElement('div');
          checkboxHeader.className = 'column-header checkbox-header';
          checkboxHeader.textContent = 'Add';
          
          const roomHeader = document.createElement('div');
          roomHeader.className = 'column-header room-header';
          roomHeader.textContent = 'Room';

          const typeHeader = document.createElement('div');
          typeHeader.className = 'column-header type-header';
          typeHeader.textContent = 'Type';
          
          const itemHeader = document.createElement('div');
          itemHeader.className = 'column-header item-header';
          itemHeader.textContent = 'Item';
          
          const quantityHeader = document.createElement('div');
          quantityHeader.className = 'column-header quantity-header';
          quantityHeader.textContent = 'QTY';
          
          // const actionsHeader = document.createElement('div');
          // actionsHeader.className = 'column-header actions-header';
          // actionsHeader.textContent = 'Remove Item';
          
          headers.appendChild(checkboxHeader);
          headers.appendChild(roomHeader); // Added new room header
          headers.appendChild(typeHeader);
          headers.appendChild(itemHeader);
          headers.appendChild(quantityHeader);
          // headers.appendChild(actionsHeader);
          
          roomContainer.appendChild(headers);
          
          // Add items container
          const itemsContainer = document.createElement('div');
          itemsContainer.className = 'items-container';
          itemsContainer.id = `items-${room.replace(/\s+/g, '-')}`;
          
          // Use a DocumentFragment for batching item row appends
          const itemsFragment = document.createDocumentFragment();
          // Add each item
          currentRoomItems.forEach((item, index) => {
            const itemRow = createItemSelectionRow(item, index, room);
            itemsFragment.appendChild(itemRow);
          });
          itemsContainer.appendChild(itemsFragment); // Append all item rows at once
          
          // Add delegated event listeners to itemsContainer
          itemsContainer.addEventListener('change', function(event) {
            const target = event.target;
            if (target.classList.contains('room-input') ||
                target.classList.contains('item-input') ||
                target.classList.contains('type-input') ||
                target.classList.contains('quantity-input') ||
                target.classList.contains('item-checkbox')) {
              if (target.dataset.room && target.dataset.index !== undefined && target.dataset.field) {
                updateItemSelectionData(target.dataset.room, target.dataset.index, target.dataset.field, 
                                       target.type === 'checkbox' ? target.checked : target.value);
              }
            }
          });

          itemsContainer.addEventListener('input', function(event) {
            const target = event.target;
            if (
              target.classList.contains('room-input') ||
              target.classList.contains('item-input') ||
              target.classList.contains('type-input') ||
              target.classList.contains('quantity-input') ||
              target.classList.contains('spec-ffe-select')) { // Added .spec-ffe-select
              if (target.dataset.room && target.dataset.index !== undefined && target.dataset.field) {
                updateItemSelectionData(target.dataset.room, target.dataset.index, target.dataset.field, target.value);
              }
            }
          });

          // itemsContainer.addEventListener('click', function(event) {
          //   const target = event.target;
          //   if (target.classList.contains('delete-button')) {
          //     if (target.dataset.room && target.dataset.index !== undefined) {
          //       deleteItemSelectionRow(target.dataset.room, target.dataset.index);
          //     }
          //   }
          // });

          roomContainer.appendChild(itemsContainer);
          
          roomsFragment.appendChild(roomContainer); // Append room container to the fragment
        });
        
        container.appendChild(roomsFragment); // Append all room containers at once
        
        // Update the content area
        document.getElementById('mainContent').innerHTML = '';
        document.getElementById('mainContent').appendChild(container);

        // AFTER all DOM is updated, call the callback
        if (typeof optionalOnSuccessCallback === 'function') {
          console.log("[modal_scripts.js] renderItemSelectionInterface: DOM rendering complete. Calling onSuccessCallback.");
          optionalOnSuccessCallback();
        }
      }
      
      /**
       * Creates a row for the item selection interface with a checkbox.
       * @param {Object} item - The item data.
       * @param {number} index - The index of the item.
       * @param {string} roomName - The name of the room.
       * @return {HTMLElement} The created row element.
       */
      function createItemSelectionRow(item, index, roomName) {
        // Create the main row container
        const row = document.createElement('div');
        row.className = 'item-row';
        row.dataset.index = index;
        row.dataset.room = roomName;
        
        // Add checkbox container
        const checkboxContainer = document.createElement('div');
        checkboxContainer.className = 'checkbox-container';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'item-checkbox';
        checkbox.checked = item.isSelected || false;
        checkbox.dataset.field = 'isSelected';
        checkbox.dataset.room = roomName;
        checkbox.dataset.index = index;
        
        checkboxContainer.appendChild(checkbox);
        
        // Room input container (New)
        const roomInputContainer = document.createElement('div');
        roomInputContainer.className = 'item-input-container'; // Use same class for styling consistency

        const roomInput = document.createElement('input');
        roomInput.type = 'text';
        roomInput.className = 'room-input'; // New class for specific styling if needed
        roomInput.value = item.room.toUpperCase() || roomName.toUpperCase() || ''; // Populate with item's room or passed roomName
        roomInput.disabled = true; // Make it disabled
        roomInput.dataset.field = 'room'; // Add data-field for consistency
        roomInput.dataset.room = roomName;
        roomInput.dataset.index = index;

        roomInputContainer.appendChild(roomInput);
        
        // Type input container
        const typeInputContainer = document.createElement('div');
        typeInputContainer.className = 'item-input-container';
        
        // Type input
        const typeInput = document.createElement('input');
        typeInput.type = 'text';
        typeInput.className = 'type-input';
        typeInput.value = item.type || '';
        typeInput.dataset.field = 'type';
        typeInput.dataset.room = roomName;
        typeInput.dataset.index = index;
        
        typeInputContainer.appendChild(typeInput);
        
        // Item input container with autocomplete
        const itemInputContainer = document.createElement('div');
        itemInputContainer.className = 'item-input-container';
        
        const itemInput = document.createElement('input');
        itemInput.type = 'text';
        itemInput.className = 'item-input';
        itemInput.value = item.item || '';
        itemInput.dataset.field = 'item';
        itemInput.dataset.room = roomName;
        itemInput.dataset.index = index;
        
        // Add focus event to show autocomplete
        itemInput.addEventListener('focus', function() {
          showAutocomplete(this);
        });
        
        // Add keydown event for filtering as user types
        itemInput.addEventListener('input', function() {
          filterAutocompleteItems(this);
        });
        
        // Add keydown event for keyboard navigation
        itemInput.addEventListener('keydown', function(e) {
          handleAutocompleteKeydown(e, this);
        });
        
        // Add blur event to close the autocomplete dropdown when clicking outside
        itemInput.addEventListener('blur', function() {
          // Use a small delay to allow click events on autocomplete items to complete
          setTimeout(() => {
            if (activeAutocompleteInput === this) {
              const autocompleteList = this.parentElement.querySelector('.autocomplete-list');
              if (autocompleteList) {
                autocompleteList.style.display = 'none';
              }
              activeAutocompleteInput = null;
            }
          }, 200);
        });
        
        const autocompleteList = document.createElement('div');
        autocompleteList.className = 'autocomplete-list';
        
        itemInputContainer.appendChild(itemInput);
        itemInputContainer.appendChild(autocompleteList);
        
        // Quantity input
        const quantityInput = document.createElement('input');
        quantityInput.type = 'number';
        quantityInput.className = 'quantity-input';
        quantityInput.value = item.quantity || 1;
        quantityInput.min = '1';
        quantityInput.dataset.field = 'quantity';
        quantityInput.dataset.room = roomName;
        quantityInput.dataset.index = index;
        
        // Delete button container
        // const deleteButtonContainer = document.createElement('div');
        // deleteButtonContainer.className = 'delete-button-container';
        
        // const deleteButton = document.createElement('button');
        // deleteButton.className = 'delete-button';
        // deleteButton.textContent = '';
        // deleteButton.dataset.room = roomName;
        // deleteButton.dataset.index = String(index); // For delegated event handler
        
        // deleteButtonContainer.appendChild(deleteButton);
        
        // Add all elements to the row in new order: checkbox, room, type, item, quantity
        row.appendChild(checkboxContainer);
        row.appendChild(roomInputContainer); // Added new room input container
        row.appendChild(typeInputContainer);
        row.appendChild(itemInputContainer);
        row.appendChild(quantityInput);
        // row.appendChild(deleteButtonContainer);
        
        return row;
      }
      
      /**
       * Updates item selection data when inputs change.
       * @param {string} roomName - The name of the room.
       * @param {number|string} index - The index of the item.
       * @param {string} field - The field to update.
       * @param {*} value - The new value.
       */
      function updateItemSelectionData(roomName, index, field, value) {
        const idx = parseInt(index);
        const roomItems = dashboardItemSelectionData.itemsByRoom[roomName] || [];
        
        if (idx < 0 || idx >= roomItems.length) {
          console.error(`Invalid index: ${idx}. Room ${roomName} items length: ${roomItems.length}`);
          return;
        }
        
        const item = roomItems[idx];
        console.log(`Updating ${field} for item in ${roomName} at index ${idx} to value:`, value);
        
        // Explicitly handle the 'room' field case, though it's disabled
        if (field === 'room') {
          // Even though disabled, ensure the underlying data model is not unintentionally changed if an event fires.
          // The item.room should reflect the correct, original room name.
          // We also compare against roomName (the original room context for this row) to be safe.
          if (item.room !== value && roomName !== value) { 
             console.warn(`Attempted to update disabled 'room' field for item '${item.item}'. Original: '${item.room}', Attempted: '${value}'. Change ignored.`);
          }
          // No actual update to item.room should happen here as it's a disabled, display-only field.
        } else if (field === 'quantity') {
          item[field] = parseInt(value) || 1;
        } else if (field === 'isSelected') {
          item[field] = value; // Boolean for checkbox
        } else {
          // For 'item' and 'type' fields, convert to uppercase
          if (field === 'item' || field === 'type') {
            item[field] = value.toUpperCase();
          } else {
            // For any other fields
            item[field] = value;
          }
        }
        
        // Find the same item in the main items array and update it too
        const mainIndex = dashboardItemSelectionData.items.findIndex(i => 
          i === item || 
          (i.id && item.id && i.id === item.id) ||
          (i.room === roomName && i.item === item.item && i.type === item.type)
        );
        
        if (mainIndex >= 0) {
          console.log(`Updating main items array at index ${mainIndex}`);
          // Update the corresponding fields, not just the one field
          dashboardItemSelectionData.items[mainIndex] = { ...item };
        } else {
          console.warn(`Couldn't find item in main items array. Room: ${roomName}, Index: ${idx}, Field: ${field}`);
        }
      }
      
      /**
       * Filters rooms in the selection interface.
       */
      function filterRoomsInSelectionInterface() {
        const selectedRoom = document.getElementById('room-filter').value;
        const roomContainers = document.querySelectorAll('.room-container');
        
        roomContainers.forEach(container => {
          if (selectedRoom === 'all' || container.dataset.room === selectedRoom) {
            container.style.display = 'block';
          } else {
            container.style.display = 'none';
          }
        });
      }
      
      /**
       * Deletes an item row from the selection interface.
       * @param {string} roomName - The name of the room.
       * @param {number|string} index - The index of the item to delete.
       */
      function deleteItemSelectionRow(roomName, index) {
        if (confirm('Are you sure you want to delete this item?')) {
          // Remove from data structure
          const roomItems = dashboardItemSelectionData.itemsByRoom[roomName] || [];
          if (roomItems[index]) {
            // Find the item in the overall items array
            const itemToRemove = roomItems[index];
            const overallIndex = dashboardItemSelectionData.items.findIndex(item => 
              item === itemToRemove || 
              (item.room === roomName && item.item === itemToRemove.item && item.type === itemToRemove.type) // More specific match
            );
            
            if (overallIndex !== -1) {
              dashboardItemSelectionData.items.splice(overallIndex, 1);
            }
            
            // Remove from room items
            roomItems.splice(index, 1);
            
            // Refresh the entire room section to update indices
            refreshItemSelectionDisplay(roomName);
            
            // If this was the last item in the room and we're filtering by this room,
            // switch back to "All Rooms" view
            if (roomItems.length === 0) {
              const currentFilter = document.getElementById('room-filter').value;
              if (currentFilter === roomName) {
                document.getElementById('room-filter').value = 'all';
                filterRoomsInSelectionInterface();
              }
            }
            
            // Show status message
            showDashboardStatusMessage('Item deleted successfully');
          }
        }
      }
      
      /**
       * Refreshes the display of all items for a room in the selection interface.
       * @param {string} roomName - The name of the room to refresh.
       */
      function refreshItemSelectionDisplay(roomName) {
        const roomItems = dashboardItemSelectionData.itemsByRoom[roomName] || [];
        const container = document.getElementById(`items-${roomName.replace(/\s+/g, '-')}`);
        
        // Clear the container
        container.innerHTML = '';
        
        // Use a DocumentFragment for batching item row appends
        const itemsFragment = document.createDocumentFragment();
        // Regenerate all item rows
        roomItems.forEach((item, index) => {
          const newRow = createItemSelectionRow(item, index, roomName);
          itemsFragment.appendChild(newRow);
        });
        container.appendChild(itemsFragment); // Append all item rows at once
      }
      
      /**
       * Saves selected items from the dashboard to the sheet.
       */
      function saveSelectedItemsFromDashboard() {
        console.log('Starting save process for selected items');

        // Check if item selection data is loaded
        if (typeof dashboardItemSelectionData === 'undefined' || !dashboardItemSelectionData || !dashboardItemSelectionData.items) {
            console.log('dashboardItemSelectionData is not defined or empty. Loading item selection interface first.');
            // Show a status message to the user that we are loading data first.
            // Using 'main' as location because this is a global action potentially affecting main content.
            showDashboardStatusMessage('Loading item data, then will create list...', false, 'main');

            // Call showItemSelectionInterface.
            // Pass a new function as the callback which will then call saveSelectedItemsFromDashboard again.
            showItemSelectionInterface(function() {
                console.log('Item selection interface loaded by saveSelectedItemsFromDashboard. Retrying save.');
                // Update status or clear previous one
                showDashboardStatusMessage('Item data loaded. Proceeding to create Master Item List...', false, 'main');
                saveSelectedItemsFromDashboard(); // Re-call the function now that data should be loaded
            });
            return; // Important: exit the current execution, the callback will handle the rest.
        }
        
        // Get sheetId from the dialog if available
        const dialog = document.querySelector('.app-container');
        const sheetId = dialog ? dialog.getAttribute('data-sheet-id') : null;
        console.log('saveSelectedItemsFromDashboard: found sheetId:', sheetId);
        
        showDashboardLoading('Saving selected items...');
        
        // Get all items that are selected
        const allItems = dashboardItemSelectionData.items || [];
        const selectedItems = allItems.filter(item => item.isSelected === true && item.room && item.item && item.item.trim() !== ''); // Ensure room and item are present
        
        console.log('Selected items to save:', selectedItems.length);
        
        if (selectedItems.length === 0) {
          hideDashboardLoading();
          showDashboardStatusMessage('No items selected. Please select items before saving.', true);
          return;
        }
        
        // Make sure all selected items have valid data
        const itemsToSave = selectedItems.filter(item => item.item && item.item.trim() !== '');
        
        if (itemsToSave.length === 0) {
          hideDashboardLoading();
          showDashboardStatusMessage('No valid items to save. Please ensure selected items have names.', true);
          return;
        }
        
        // Sanitize items - remove any budget fields
        const sanitizedItems = itemsToSave.map(item => {
          // Create a deep copy to avoid modifying the original
          const sanitizedItem = JSON.parse(JSON.stringify(item));
          
          // Ensure quantity is at least 1
          sanitizedItem.quantity = Math.max(1, parseInt(sanitizedItem.quantity) || 1);
          
          // Remove budget properties that we don't need for this interface
          if ('lowBudget' in sanitizedItem) delete sanitizedItem.lowBudget;
          if ('highBudget' in sanitizedItem) delete sanitizedItem.highBudget;
          if ('lowBudgetTotal' in sanitizedItem) delete sanitizedItem.lowBudgetTotal;
          if ('highBudgetTotal' in sanitizedItem) delete sanitizedItem.highBudgetTotal;
          
          // Remove temporary properties that shouldn't be saved
          if ('isNew' in sanitizedItem) delete sanitizedItem.isNew;
          if ('id' in sanitizedItem && sanitizedItem.id.toString().startsWith('new_')) delete sanitizedItem.id;
          
          return sanitizedItem;
        });
        
        console.log('Sanitized items ready for saving:', sanitizedItems.length);
        console.log('Sample sanitized item:', sanitizedItems.length > 0 ? sanitizedItems[0] : 'No items');
        
        // Call the server-side function with the sanitized items
        google.script.run
          .withSuccessHandler(function(result) {
            console.log('Server response for save operation:', result);
            hideDashboardLoading();
            
            if (result.success) {
              // Show a success message
              showDashboardStatusMessage(`${result.message || `Successfully created Master Item List with ${result.itemCount} items`}`, false);
              
              // Close the dialog - the sheet should already be active since the server function activated it
              google.script.host.close();
              
              // Mark saved items as no longer selected
              dashboardItemSelectionData.items.forEach(item => {
                if (item.isSelected) item.isSelected = false;
              });
              
              // Refresh the display to show updated selection state
              Object.keys(dashboardItemSelectionData.itemsByRoom).forEach(room => {
                refreshItemSelectionDisplay(room);
              });
            } else {
              console.error('Server reported error:', result.error || 'Unknown error');
              showDashboardStatusMessage('Error: ' + (result.error || 'Failed to save items'), true);
            }
          })
          .withFailureHandler(function(error) {
            console.error('Error during save operation:', error);
            hideDashboardLoading();
            showDashboardStatusMessage('Error: ' + (error.message || error), true);
          })
          .saveSelectedItemsWithTemplateCopy(sanitizedItems);
      }

      /**
       * Shows the item selection interface in the dashboard.
       * This interface allows users to select items from category lists to add to the project.
       */
      function showItemSelectionInterface(optionalOnSuccessCallback) { // MODIFIED: Add optionalOnSuccessCallback
        // Store the original project name if not already stored
        const projectNameElement = document.getElementById('projectName');
        if (projectNameElement && !window.originalProjectName) {
          window.originalProjectName = projectNameElement.innerText;
        }
        
        // Update the page title
        if (projectNameElement) {
          projectNameElement.innerText = 'Select Items';
        }
        setActiveMainContentButton('selectItemsBtn'); // Added this line
        
        const mainContentContainer = document.getElementById('mainContent');
        
        // Get the sheet ID from the project details modal
        const dialog = document.querySelector('.app-container');
        const sheetId = dialog ? dialog.getAttribute('data-sheet-id') : null;
        
        console.log('showItemSelectionInterface: found sheetId:', sheetId);
        
        // Only proceed if we have a sheetId
        if (!sheetId) {
          if (mainContentContainer) {
            renderUIState(mainContentContainer, 'error', '<strong>Error:</strong> No sheet ID found. Unable to load items.');
          }
          return;
        }
        
        // Show global loading overlay and set loading for main container
        showDashboardLoading('Loading item selection...');
        if (mainContentContainer) {
            mainContentContainer.innerHTML = `
              <div class="loading-state">
                <div class="spinner"></div>
                <p>Loading items...</p>
              </div>`;
        }
        
        // First get the currently selected rooms
        google.script.run
          .withSuccessHandler(function(selectedResult) {
            if (!selectedResult.success) {
              hideDashboardLoading();
              if (mainContentContainer) {
                renderUIState(mainContentContainer, 'error', '<strong>Error:</strong> ' + (selectedResult.error || 'Failed to get selected rooms'));
              } else {
                alert('Error: Failed to get selected rooms. Main content area missing.');
              }
              return;
            }
            
            // Keep track of the already selected rooms
            const currentlySelectedRooms = selectedResult.selectedRooms || [];
            
            // If there are no selected rooms yet, simply show the room manager
            if (currentlySelectedRooms.length === 0) {
              hideDashboardLoading();
              // Navigate to Room Categories tab instead of Room Manager
              if (typeof switchSidebarTab === 'function') {
                switchSidebarTab('roomCategories');
              } else {
                console.warn('switchSidebarTab function not found, cannot navigate to Room Categories.');
                // Fallback to original behavior if switchSidebarTab is not available
                showRoomManager(); 
              }
              return;
            }
            
            // Keep the same loading state we set earlier - don't change it
            google.script.run
              .withSuccessHandler(function(result) {
                hideDashboardLoading();
                if (mainContentContainer) {
                    if (result.success) {
                        // Initialize the interface with room data and pass the callback
                        renderItemSelectionInterface(result, optionalOnSuccessCallback); // MODIFIED: Pass callback
                    } else {
                        renderUIState(mainContentContainer, 'error', '<strong>Error:</strong> ' + (result.error || 'Failed to load items data'));
                    }
                } else {
                     alert('Error loading items data. Main content area missing.');
                }
              })
              .withFailureHandler(function(error) {
                hideDashboardLoading();
                if (mainContentContainer) {
                    renderUIState(mainContentContainer, 'error', '<strong>Error:</strong> ' + (error.error || error.message || error.toString()));
                } else {
                     alert('Error loading items data. Main content area missing.');
                }
              })
              .getItemSelectionData(sheetId, currentlySelectedRooms);
          })
          .withFailureHandler(function(error) {
            hideDashboardLoading();
            if (mainContentContainer) {
                renderUIState(mainContentContainer, 'error', '<strong>Error:</strong> ' + (error.error || error.message || error.toString()));
            } else {
                 alert('Error loading item selection. Main content area missing.');
            }
          })
          .getSelectedRooms(sheetId);
      }

      function renderSelectedRoomsInHomeSidebar(result) {
        const container = document.querySelector('#home-content .sidebar-body #homeSelectedRoomsListContainer');
        if (!container) {
          console.error('renderSelectedRoomsInHomeSidebar: Container #homeSelectedRoomsListContainer not found.');
          return;
        }

        if (result && result.success) {
          const selectedRooms = result.selectedRooms || [];
          const roomCategories = result.roomCategories || {}; // Expecting { roomName: ['cat1', 'cat2'], ... }

          if (selectedRooms.length > 0) {
            let listHtml = '<h4 class="selected-room-header">Project Rooms:</h4><ul class="selected-rooms-list-sidebar">';
            selectedRooms.forEach(room => {
              listHtml += `<li><i class="material-icons" style="font-size: 1.1em; vertical-align: text-bottom; margin-right: 5px; color: #26717D;">check_circle_outline</i>${escapeHtml(room)}`;
              
              // Add bulleted list of categories if they exist for this room
              if (roomCategories[room] && roomCategories[room].length > 0) {
                listHtml += '<ul class="category-list-sidebar" style="margin-left: 35px; padding-left: 0; list-style-type: disc;">';
                roomCategories[room].forEach(category => {
                  listHtml += `<li style="font-size: 0.8em; color: #555;">${escapeHtml(category)}</li>`;
                });
                listHtml += '</ul>';
              }
              listHtml += '</li>';
            });
            listHtml += '</ul>';
            container.innerHTML = listHtml;
          } else {
            renderUIState(container, 'empty', 'No rooms currently selected.');
          }
        } else {
          const errorMessage = result && result.error ? result.error : 'Failed to load selected rooms.';
          renderUIState(container, 'error', errorMessage);
          console.error('renderSelectedRoomsInHomeSidebar: Error -', errorMessage, 'Full result:', result);
        }
      }

      function handleSelectedRoomsError(error) {
        const container = document.querySelector('#home-content .sidebar-body #homeSelectedRoomsListContainer');
        if (!container) {
          console.error('handleSelectedRoomsError: Container #homeSelectedRoomsListContainer not found.');
          return;
        }
        let errorMessage = 'Error loading selected rooms.';
        if (typeof error === 'string') {
          errorMessage = error;
        } else if (error && error.message) {
          errorMessage = error.message;
        } else if (error && error.details) {
          errorMessage = error.details;
        }
        renderUIState(container, 'error', errorMessage);
        console.error('handleSelectedRoomsError:', error);
      }

      /**
       * Clears the active state from any button in the main content header.
       */
      function clearActiveMainContentButton() {
        setActiveMainContentButton(null);
      }

      /**
       * Toggles the visibility of the 'Create Master Item List' button in the home sidebar
       * based on whether the 'Select Items' main content button is active.
       */
      function toggleCreateMasterListButtonVisibility() {
        const selectItemsBtn = document.getElementById('selectItemsBtn');
        const createMasterListBtn = document.getElementById('createMasterItemListBtnSidebar');

        if (!createMasterListBtn) {
          // Button might not be created yet if home sidebar hasn't rendered its content fully.
          // This function will be called again when it does.
          return;
        }

        if (selectItemsBtn && selectItemsBtn.classList.contains('btn-active')) {
          createMasterListBtn.style.display = 'block'; // Or 'flex' if its parent is a flex container and it should behave as a flex item
        } else {
          createMasterListBtn.style.display = 'none';
        }
      }

  // Render the item update interface in the dashboard
  function renderItemUpdateInterface(data) {
    if (!data.success) {
      document.getElementById('mainContent').innerHTML = `
        <div class="error-box" style="margin: 20px;">
          <strong>Error:</strong> ${data.error || 'Failed to load item data'}
        </div>`;
      return;
    }
    
    console.log('Data received in renderItemUpdateInterface:', JSON.parse(JSON.stringify(data)));
    
    // Normalize itemsByRoom keys to be UPPERCASE, but ensure item.room property remains original case.
    const normalizedItemsByRoom = {};
    if (data.itemsByRoom && data.selectedRooms) {
        data.selectedRooms.forEach(selectedRoomNameOriginalCase => { 
            const selectedRoomNameUppercase = selectedRoomNameOriginalCase.toUpperCase();
            
            const actualKeyFromServer = Object.keys(data.itemsByRoom).find(
                k => k.toUpperCase() === selectedRoomNameUppercase
            );
            
            let itemsFromServerForThisRoom = [];
            if (actualKeyFromServer) {
                itemsFromServerForThisRoom = Array.isArray(data.itemsByRoom[actualKeyFromServer]) 
                                   ? data.itemsByRoom[actualKeyFromServer] 
                                   : [];
            }

            normalizedItemsByRoom[selectedRoomNameUppercase] = itemsFromServerForThisRoom.map(item => ({
                ...item,
                // Crucially, ensure the item.room property reflects the original/display case,
                // even if the source data had inconsistent casing for item.room.
                // We trust selectedRoomNameOriginalCase as the canonical display name for this room.
                room: selectedRoomNameOriginalCase 
            }));
        });
    }

    // Update the global dashboardItemData
    dashboardItemData = {
        ...data, 
        itemsByRoom: normalizedItemsByRoom, // Keys are now UPPERCASE
        selectedRooms: data.selectedRooms ? [...data.selectedRooms].sort((a,b) => String(a).localeCompare(String(b))) : [], // Keep original case, sorted for UI
        items: [] 
    };

    // Rebuild dashboardItemData.items from the newly normalized itemsByRoom
    // Ensure item.room in this flat list is the original case name.
    Object.keys(dashboardItemData.itemsByRoom).forEach(roomKeyUppercase => {
        const itemsInRoom = dashboardItemData.itemsByRoom[roomKeyUppercase];
        if (Array.isArray(itemsInRoom)) {
            itemsInRoom.forEach(item => { // item already has item.room as original case from mapping above
                dashboardItemData.items.push(item); 
            });
        }
    });

    // Sort dashboardItemData.items by original room name (item.room), then by item name
    if (Array.isArray(dashboardItemData.items)) {
        dashboardItemData.items.sort((a, b) => {
            const roomA = String(a.room || '').toUpperCase(); // For sorting, using uppercase is robust
            const roomB = String(b.room || '').toUpperCase();
            if (roomA === roomB) {
                const itemAname = String(a.item || '').toUpperCase();
                const itemBname = String(b.item || '').toUpperCase();
                return itemAname.localeCompare(itemBname);
            }
            return roomA.localeCompare(roomB);
        });
        console.log('dashboardItemData.items sorted. Count:', dashboardItemData.items.length);
    }
    
    if (!dashboardItemData.combinedItems || !Array.isArray(dashboardItemData.combinedItems)) {
      console.warn('combinedItems is missing or not an array, initializing from availableItems in normalized dashboardItemData');
      if (dashboardItemData.availableItems && Array.isArray(dashboardItemData.availableItems)) {
        dashboardItemData.combinedItems = dashboardItemData.availableItems.map(item => {
          if (typeof item === 'string') return item;
          const typeStr = item.type || '';
          const itemStr = item.item || '';
          return typeStr && itemStr ? `${typeStr} : ${itemStr}` : (itemStr || typeStr || '');
        });
        console.log('Created combinedItems with', dashboardItemData.combinedItems.length, 'items from normalized data');
      } else {
        console.warn('availableItems is also missing or not an array in normalized data, initializing empty combinedItems');
        dashboardItemData.combinedItems = [];
      }
    }
    
    const container = document.createElement('div');
    container.className = 'item-update-content';
    container.style.padding = '20px';
    
    const helpContainer = document.createElement('div');
    helpContainer.className = 'tooltip';
    helpContainer.style.position = 'absolute';
    helpContainer.style.top = '16px';
    helpContainer.style.right = '16px';
    
    const helpIcon = document.createElement('div');
    helpIcon.className = 'help-icon';
    helpIcon.innerHTML = '?';
    
    const tooltipText = document.createElement('div');
    tooltipText.className = 'tooltip-text';
    tooltipText.innerHTML = '<p>Review and update your items below. Make any necessary changes to the item details, then click Save All Items to update the spreadsheet.</p>';
    
    helpContainer.appendChild(helpIcon);
    helpContainer.appendChild(tooltipText);
    container.appendChild(helpContainer);
    
    // Build itemsByRoomForUiDisplay: keys are original-case room names (for UI titles, dataset.room)
    // Values are arrays of items fetched from dashboardItemData.itemsByRoom (which uses UPPERCASE keys)
    const itemsByRoomForUiDisplay = {}; 
    if (dashboardItemData.selectedRooms && dashboardItemData.itemsByRoom) {
        // dashboardItemData.selectedRooms contains original case names (e.g., "Basement Bath"), sorted.
        dashboardItemData.selectedRooms.forEach(originalCaseRoomName => { 
            const uppercaseRoomKey = originalCaseRoomName.toUpperCase();
            itemsByRoomForUiDisplay[originalCaseRoomName] = dashboardItemData.itemsByRoom[uppercaseRoomKey] || [];
        });
    }
    
    const stickyContainer = document.createElement('div');
    stickyContainer.id = 'sticky-filter-save-container';
    stickyContainer.style.position = 'sticky';
    stickyContainer.style.top = '0';
    stickyContainer.style.backgroundColor = 'white';
    stickyContainer.style.zIndex = '100';
    stickyContainer.style.padding = '10px 0';
    stickyContainer.style.display = 'flex';
    stickyContainer.style.justifyContent = 'space-between';
    stickyContainer.style.alignItems = 'center';
    stickyContainer.style.borderBottom = '1px solid rgba(0,0,0,0.1)';
    stickyContainer.style.marginBottom = '15px';
    
    const filterContainer = document.createElement('div');
    filterContainer.id = 'filter-container';
    filterContainer.style.display = 'flex';
    filterContainer.style.alignItems = 'center';
    
    const filterLabel = document.createElement('label');
    filterLabel.className = 'filter-label';
    filterLabel.htmlFor = 'room-filter';
    filterLabel.textContent = 'Filter by Room:';
    filterLabel.style.marginRight = '10px';
    
    const roomFilter = document.createElement('select');
    roomFilter.id = 'room-filter';
    roomFilter.style.marginRight = '20px';
    roomFilter.addEventListener('change', filterRoomsInDashboard);
    
    const allRoomsOption = document.createElement('option');
    allRoomsOption.value = 'all';
    allRoomsOption.textContent = 'All Rooms';
    roomFilter.appendChild(allRoomsOption);
    
    filterContainer.appendChild(filterLabel);
    filterContainer.appendChild(roomFilter);
    
    const saveButton = document.createElement('button');
    saveButton.className = 'btn';
    saveButton.addEventListener('click', saveAllItemsFromDashboard);
    
    const saveIcon = document.createElement('i');
    saveIcon.className = 'material-icons';
    saveIcon.textContent = 'save';
    saveIcon.style.marginRight = '5px';
    
    saveButton.appendChild(saveIcon);
    saveButton.appendChild(document.createTextNode('Save All Items'));
       
    const actionsContainer = document.createElement('div');
    actionsContainer.style.display = 'flex';
    actionsContainer.style.gap = '10px';
    actionsContainer.appendChild(saveButton);
    
    stickyContainer.appendChild(filterContainer);
    stickyContainer.appendChild(actionsContainer);
    container.appendChild(stickyContainer);
    
    // Populate filter dropdown with original-case room names from itemsByRoomForUiDisplay keys
    Object.keys(itemsByRoomForUiDisplay).forEach(originalCaseRoomName => {
      const option = document.createElement('option');
      option.value = originalCaseRoomName; // Filter will use original case
      option.textContent = originalCaseRoomName;
      roomFilter.appendChild(option);
    });
    
    const roomsFragment = document.createDocumentFragment();
    
    // Create room sections. Iterate using itemsByRoomForUiDisplay (keys are original case)
    Object.keys(itemsByRoomForUiDisplay).forEach(roomDisplayNameOriginalCase => {
      const currentRoomItems = itemsByRoomForUiDisplay[roomDisplayNameOriginalCase];
      
      const roomContainer = document.createElement('div');
      roomContainer.className = 'room-container';
      // DOM ID and dataset.room use original case for consistency with filterRoomsInDashboard
      roomContainer.id = `room-container-${roomDisplayNameOriginalCase.replace(/\s+/g, '-')}`; // CORRECTED REGEX (single backslash)
      roomContainer.dataset.room = roomDisplayNameOriginalCase; 
      
      const roomTitle = document.createElement('div');
      roomTitle.className = 'room-title';
      roomTitle.textContent = roomDisplayNameOriginalCase; // Display original case
      roomContainer.appendChild(roomTitle);
      
      const headers = document.createElement('div');
      headers.className = 'column-headers';
      
      const itemHeader = document.createElement('div');
      itemHeader.className = 'column-header item-header';
      itemHeader.textContent = 'Item';
      
      const typeHeader = document.createElement('div');
      typeHeader.className = 'column-header type-header';
      typeHeader.textContent = 'Type';
      
      const quantityHeader = document.createElement('div');
      quantityHeader.className = 'column-header quantity-header';
      quantityHeader.textContent = 'QTY';
      
      const lowBudgetHeader = document.createElement('div');
      lowBudgetHeader.className = 'column-header budget-header';
      lowBudgetHeader.textContent = 'Low Budget';
      
      const highBudgetHeader = document.createElement('div');
      highBudgetHeader.className = 'column-header budget-header';
      highBudgetHeader.textContent = 'High Budget';
      
      const specFfeHeader = document.createElement('div');
      specFfeHeader.className = 'column-header spec-ffe-header';
      specFfeHeader.textContent = 'SPEC/FFE';

      const actionsHeader = document.createElement('div');
      actionsHeader.className = 'column-header actions-header';
      actionsHeader.textContent = 'Delete';
      
      headers.appendChild(itemHeader);
      headers.appendChild(typeHeader);
      headers.appendChild(quantityHeader);
      headers.appendChild(lowBudgetHeader);
      headers.appendChild(highBudgetHeader);
      headers.appendChild(specFfeHeader);
      headers.appendChild(actionsHeader);
      
      roomContainer.appendChild(headers);
      
      const itemsContainer = document.createElement('div');
      itemsContainer.className = 'items-container';
      itemsContainer.id = `items-${roomDisplayNameOriginalCase.replace(/\s+/g, '-')}`; // CORRECTED REGEX (single backslash)
      
      const itemsFragmentInner = document.createDocumentFragment();
      currentRoomItems.forEach((item, index) => {
        // createItemRow gets roomDisplayNameOriginalCase for its roomName param.
        // This sets dataset.room to original case.
        // The 'index' is the 0-based index from currentRoomItems array.
        const itemRow = createItemRow(item, index, roomDisplayNameOriginalCase); 
        itemsFragmentInner.appendChild(itemRow);
      });
      itemsContainer.appendChild(itemsFragmentInner); 
      
      // Event listeners remain the same, they use dataset.room (original case)
      // which then gets converted to uppercase in updateItemData/deleteItemRow for itemsByRoom access.
      itemsContainer.addEventListener('change', function(event) {
        const target = event.target;
        if (target.classList.contains('item-input') ||
            target.classList.contains('type-input') ||
            target.classList.contains('quantity-input') ||
            target.classList.contains('budget-input') ||
            target.classList.contains('spec-ffe-select')) { 
          if (target.dataset.room && target.dataset.index !== undefined && target.dataset.field) {
            updateItemData(target.dataset.room, target.dataset.index, target.dataset.field, target.value);
          }
        }
      });

      itemsContainer.addEventListener('input', function(event) {
        const target = event.target;
        if (target.classList.contains('item-input') ||
            target.classList.contains('type-input') ||
            target.classList.contains('quantity-input') ||
            target.classList.contains('budget-input') ||
            target.classList.contains('spec-ffe-select')) { 
          if (target.dataset.room && target.dataset.index !== undefined && target.dataset.field) {
            updateItemData(target.dataset.room, target.dataset.index, target.dataset.field, target.value);
          }
        }
      });

      itemsContainer.addEventListener('click', function(event) {
        const target = event.target;
        if (target.classList.contains('delete-button')) {
          if (target.dataset.room && target.dataset.index !== undefined) {
            // deleteItemRow internally converts target.dataset.room (original case) to uppercase for itemsByRoom access.
            deleteItemRow(target.dataset.room, target.dataset.index);
          }
        }
      });

      roomContainer.appendChild(itemsContainer);
      
      const addMoreRow = document.createElement('div');
      addMoreRow.className = 'add-more-row';
      
      const addItemButton = document.createElement('button');
      addItemButton.className = 'add-item-btn';
      addItemButton.addEventListener('click', function() {
        // addItemToRoom internally converts roomDisplayNameOriginalCase to uppercase for itemsByRoom access.
        addItemToRoom(roomDisplayNameOriginalCase);
      });
      
      const buttonIcon = document.createElement('i');
      buttonIcon.className = 'material-icons';
      buttonIcon.textContent = 'add';
      
      addItemButton.appendChild(buttonIcon);
      addItemButton.appendChild(document.createTextNode(' Add Item'));
      addMoreRow.appendChild(addItemButton);
      
      roomContainer.appendChild(addMoreRow);
      // updateRoomBudgetDisplay expects original case room name for DOM lookups
      updateRoomBudgetDisplay(roomDisplayNameOriginalCase); 
      roomsFragment.appendChild(roomContainer);
    });
    
    container.appendChild(roomsFragment);
    
    document.getElementById('mainContent').innerHTML = '';
    document.getElementById('mainContent').appendChild(container);
    
  }

  // Function to filter rooms in the dashboard
  function filterRoomsInDashboard() {
    const selectedRoom = document.getElementById('room-filter').value;
    const roomContainers = document.querySelectorAll('.room-container');
    
    roomContainers.forEach(container => {
      if (selectedRoom === 'all' || container.dataset.room === selectedRoom) {
        container.style.display = 'block';
      } else {
        container.style.display = 'none';
      }
    });
  }
</script> 